[
  {
    "id": "%s: all warnings being treated as errors",
    "pattern": "all warnings being treated as errors",
    "replacement": "所有的警告都被当作是错误"
  },
  {
    "id": "%s: some warnings being treated as errors",
    "pattern": "some warnings being treated as errors",
    "replacement": "有些警告被当作是错误"
  },
  {
    "id": "compilation terminated due to -fmax-errors=%u.\\n",
    "pattern": "compilation terminated due to -fmax-errors=(\\d+).\\n",
    "replacement": "编译中止，因为 -fmax-errors=$1。\\n"
  },
  {
    "id": "compilation terminated due to -Wfatal-errors.\\n",
    "pattern": "compilation terminated due to -Wfatal-errors.\\n",
    "replacement": "编译中止，因为 -Wfatal-errors。\\n"
  },
  {
    "id": "Please submit a full bug report,\\nwith preprocessed source if appropriate.\\n",
    "pattern": "Please submit a full bug report,\\nwith preprocessed source if appropriate.\\n",
    "replacement": "请提交一份完整的错误报告，\\n如有可能请附上经预处理后的源文件。\\n"
  },
  {
    "id": "See %s for instructions.\\n",
    "pattern": "See (.*?) for instructions.\\n",
    "replacement": "参阅 $1 以获取指示。\\n"
  },
  {
    "id": "compilation terminated.\\n",
    "pattern": "compilation terminated.\\n",
    "replacement": "编译中止。\\n"
  },
  {
    "id": "                 from",
    "pattern": "                 from",
    "replacement": "　　　　　　自"
  },
  {
    "id": "In file included from",
    "pattern": "In file included from",
    "replacement": "下述文件包含自"
  },
  {
    "id": "        included from",
    "pattern": "        included from",
    "replacement": "　　　　包含自"
  },
  {
    "id": "In module",
    "pattern": "In module",
    "replacement": "此模块中"
  },
  {
    "id": "of module",
    "pattern": "of module",
    "replacement": "于模块"
  },
  {
    "id": "In module imported at",
    "pattern": "In module imported at",
    "replacement": "此处导入的模块中"
  },
  {
    "id": "imported at",
    "pattern": "imported at",
    "replacement": "此处导入"
  },
  {
    "id": "%s:%d: confused by earlier errors, bailing out\\n",
    "pattern": "confused by earlier errors, bailing out",
    "replacement": "不能从先前的错误中恢复，退出"
  },
  {
    "id": "Internal compiler error: Error reporting routines re-entered.\\n",
    "pattern": "Internal compiler error: Error reporting routines re-entered.",
    "replacement": "内部编译器错误：重入错误报告程序。\\n"
  },
  {
    "id": "in %s, at %s:%d",
    "pattern": "in (.*?), at ",
    "replacement": "在 $1 中，于 "
  },
  {
    "id": "In member function %qs",
    "pattern": "In member function '(.+?)'",
    "replacement": "在成员函数 '$1' 中"
  },
  {
    "id": "In function %qs",
    "pattern": "In function '(.+?)'",
    "replacement": "在函数 '$1' 中"
  },
  {
    "id": "    inlined from %qs at %r%s:%d:%d%R",
    "pattern": "    inlined from '(.+?)' at ",
    "replacement": "    内联自 '$1' 于 "
  },
  {
    "id": "    inlined from %qs",
    "pattern": "    inlined from '(.+?)'",
    "replacement": "    内联自 '$1' "
  },
  {
    "id": "<anonymous>",
    "pattern": "<anonymous>",
    "replacement": "<匿名>"
  },
  {
    "id": "fatal error: ",
    "pattern": "fatal error: ",
    "replacement": "致命错误："
  },
  {
    "id": "internal compiler error: ",
    "pattern": "internal compiler error: ",
    "replacement": "编译器内部错误："
  },
  {
    "id": "error: ",
    "pattern": "error: ",
    "replacement": "错误："
  },
  {
    "id": "sorry, unimplemented: ",
    "pattern": "sorry, unimplemented: ",
    "replacement": "对不起，尚未实现："
  },
  {
    "id": "warning: ",
    "pattern": "warning: ",
    "replacement": "警告："
  },
  {
    "id": "anachronism: ",
    "pattern": "anachronism: ",
    "replacement": "历史遗留："
  },
  {
    "id": "note: ",
    "pattern": "note: ",
    "replacement": "附注："
  },
  {
    "id": "debug: ",
    "pattern": "debug: ",
    "replacement": "调试："
  },
  {
    "id": "path: ",
    "pattern": "path: ",
    "replacement": "路径："
  },
  {
    "id": "pedwarn: ",
    "pattern": "pedwarn: ",
    "replacement": "保守警告："
  },
  {
    "id": "permerror: ",
    "pattern": "permerror: ",
    "replacement": "永久错误："
  },
  {
    "id": "format",
    "pattern": "format '",
    "replacement": "格式 '"
  },
  {
    "id": "field width specifier",
    "pattern": "field width specifier '",
    "replacement": "字段宽度限定符 '"
  },
  {
    "id": "field precision specifier",
    "pattern": "field precision specifier '",
    "replacement": "字段精度限定符 '"
  },
  {
    "id": "' ' flag",
    "pattern": "' ' flag",
    "replacement": "' ' 标记"
  },
  {
    "id": "the ' ' printf flag",
    "pattern": "the ' ' printf flag",
    "replacement": "' ' printf 标记"
  },
  {
    "id": "'+' flag",
    "pattern": "'\\+' flag",
    "replacement": "'+' 标记"
  },
  {
    "id": "the '0' printf flag",
    "pattern": "the '0' printf flag",
    "replacement": "'0' printf 标记"
  },
  {
    "id": "'-' flag",
    "pattern": "'-' flag",
    "replacement": "'-' 标记"
  },
  {
    "id": "the '-' printf flag",
    "pattern": "the '-' printf flag",
    "replacement": "'-' printf 标记"
  },
  {
    "id": "the ''' printf flag",
    "pattern": "the ''' printf flag",
    "replacement": "''' printf 标记"
  },
  {
    "id": "'I' flag",
    "pattern": "'I' flag",
    "replacement": "'I' 标记"
  },
  {
    "id": "the 'I' printf flag",
    "pattern": "the 'I' printf flag",
    "replacement": "'I' printf 标记"
  },
  {
    "id": "'q' flag",
    "pattern": "'q' flag",
    "replacement": "'q' 标记"
  },
  {
    "id": "the 'q' diagnostic flag",
    "pattern": "the 'q' diagnostic flag",
    "replacement": "'q' 诊断标记"
  },
  {
    "id": "assignment suppression",
    "pattern": "assignment suppression",
    "replacement": "赋值抑制"
  },
  {
    "id": "the assignment suppression scanf feature",
    "pattern": "the assignment suppression scanf feature",
    "replacement": "scanf 的赋值抑制特性"
  },
  {
    "id": "'a' flag",
    "pattern": "'a' flag",
    "replacement": "'a' 标记"
  },
  {
    "id": "the 'a' scanf flag",
    "pattern": "the 'a' scanf flag",
    "replacement": "'a' scanf 标记"
  },
  {
    "id": "'m' flag",
    "pattern": "'m' flag",
    "replacement": "'m' 标记"
  },
  {
    "id": "the 'm' scanf flag",
    "pattern": "the 'm' scanf flag",
    "replacement": "'m' scanf 标记"
  },
  {
    "id": "field width in scanf format",
    "pattern": "field width in scanf format",
    "replacement": "scanf 格式的字段宽度"
  },
  {
    "id": "length modifier in scanf format",
    "pattern": "length modifier in scanf format",
    "replacement": "scanf 格式的长度修饰符"
  },
  {
    "id": "the ''' scanf flag",
    "pattern": "the ''' scanf flag",
    "replacement": "''' scanf 标记"
  },
  {
    "id": "the 'I' scanf flag",
    "pattern": "the 'I' scanf flag",
    "replacement": "'I' scanf 标记"
  },
  {
    "id": "'_' flag",
    "pattern": "'_' flag",
    "replacement": "'_' 标记"
  },
  {
    "id": "the '_' strftime flag",
    "pattern": "the '_' strftime flag",
    "replacement": "'_' strftime 标记"
  },
  {
    "id": "the '-' strftime flag",
    "pattern": "the '-' strftime flag",
    "replacement": "'-' strftime 标记"
  },
  {
    "id": "the '0' strftime flag",
    "pattern": "the '0' strftime flag",
    "replacement": "'0' strftime 标记"
  },
  {
    "id": "'^' flag",
    "pattern": "'^' flag",
    "replacement": "'^' 标记"
  },
  {
    "id": "the '^' strftime flag",
    "pattern": "the '^' strftime flag",
    "replacement": "'^' strftime 标记"
  },
  {
    "id": "the '#' strftime flag",
    "pattern": "the '#' strftime flag",
    "replacement": "'#' strftime 标记"
  },
  {
    "id": "field width in strftime format",
    "pattern": "field width in strftime format",
    "replacement": "strftime 格式的字段宽度"
  },
  {
    "id": "'E' modifier",
    "pattern": "'E' modifier",
    "replacement": "'E' 修饰符"
  },
  {
    "id": "the 'E' strftime modifier",
    "pattern": "the 'E' strftime modifier",
    "replacement": "'E' strftime 修饰符"
  },
  {
    "id": "'O' modifier",
    "pattern": "'O' modifier",
    "replacement": "'O' 修饰符"
  },
  {
    "id": "the 'O' strftime modifier",
    "pattern": "the 'O' strftime modifier",
    "replacement": "'O' strftime 修饰符"
  },
  {
    "id": "the 'O' modifier",
    "pattern": "the 'O' modifier",
    "replacement": "'O' 修饰符"
  },
  {
    "id": "fill character",
    "pattern": "fill character",
    "replacement": "填充字符"
  },
  {
    "id": "fill character in strfmon format",
    "pattern": "fill character in strfmon format",
    "replacement": "strfmon 格式的填充字符"
  },
  {
    "id": "the '^' strfmon flag",
    "pattern": "the '^' strfmon flag",
    "replacement": "'^' strfmon 标记"
  },
  {
    "id": "the '+' strfmon flag",
    "pattern": "the '\\+' strfmon flag",
    "replacement": "'+' strfmon 标记"
  },
  {
    "id": "'(' flag",
    "pattern": "'\\(' flag",
    "replacement": "'(' 标记"
  },
  {
    "id": "the '(' strfmon flag",
    "pattern": "the '\\(' strfmon flag",
    "replacement": "'(' strfmon 标记"
  },
  {
    "id": "'!' flag",
    "pattern": "'!' flag",
    "replacement": "'!' 标记"
  },
  {
    "id": "the '!' strfmon flag",
    "pattern": "the '!' strfmon flag",
    "replacement": "'!' strfmon 标记"
  },
  {
    "id": "the '-' strfmon flag",
    "pattern": "the '-' strfmon flag",
    "replacement": "'-' strfmon 标记"
  },
  {
    "id": "field width in strfmon format",
    "pattern": "field width in strfmon format",
    "replacement": "strfmon 格式的字段宽度"
  },
  {
    "id": "left precision",
    "pattern": "left precision",
    "replacement": "左精度"
  },
  {
    "id": "left precision in strfmon format",
    "pattern": "left precision in strfmon format",
    "replacement": "strfmon 格式的左精度"
  },
  {
    "id": "right precision",
    "pattern": "right precision",
    "replacement": "右精度"
  },
  {
    "id": "right precision in strfmon format",
    "pattern": "right precision in strfmon format",
    "replacement": "strfmon 格式的右精度"
  },
  {
    "id": "length modifier in strfmon format",
    "pattern": "length modifier in strfmon format",
    "replacement": "strfmon 格式的长度修饰符"
  },
  {
    "id": "<command-line>",
    "pattern": "<command-line>",
    "replacement": "<命令行>"
  },
  {
    "id": "expected %<;%>",
    "pattern": "expected ';'",
    "replacement": "期望 ';'"
  },
  {
    "id": "expected %<)%>",
    "pattern": "expected '\\)'",
    "replacement": "期望 ')'"
  },
  {
    "id": "expected %<]%>",
    "pattern": "expected '\\]'",
    "replacement": "期望 ']'"
  },
  {
    "id": "expected %<(%>",
    "pattern": "expected '\\('",
    "replacement": "期望 '('"
  },
  {
    "id": "expected %<[%>",
    "pattern": "expected '\\['",
    "replacement": "期望 '['"
  },
  {
    "id": "expected %<{%>",
    "pattern": "expected '\\{'",
    "replacement": "期望 '{'"
  },
  {
    "id": "expected %<:%>",
    "pattern": "expected ':'",
    "replacement": "期望 ':'"
  },
  {
    "id": "expected %<while%>",
    "pattern": "expected 'while'",
    "replacement": "期望 'while'"
  },
  {
    "id": "expected %<,%>",
    "pattern": "expected ','",
    "replacement": "期望 ','"
  },
  {
    "id": "expected %<@end%>",
    "pattern": "expected '@end'",
    "replacement": "期望 '@end'"
  },
  {
    "id": "expected %<>%>",
    "pattern": "expected '>'",
    "replacement": "期望 '>'"
  },
  {
    "id": "expected %<,%> or %<)%>",
    "pattern": "expected ',' or '\\)'",
    "replacement": "期望 ',' 或 ')'"
  },
  {
    "id": "expected %<=%>",
    "pattern": "expected '='",
    "replacement": "期望 '='"
  },
  {
    "id": "expected %<}%>",
    "pattern": "expected '\\}'",
    "replacement": "期望 '}'"
  },
  {
    "id": "expected %<#pragma omp section%> or %<}%>",
    "pattern": "expected '#pragma omp section' or '\\}'",
    "replacement": "期望 '#pragma omp section' 或 '}'"
  },
  {
    "id": "expected %<<%>",
    "pattern": "expected '<'",
    "replacement": "期望 '<'"
  },
  {
    "id": "candidate:",
    "pattern": "candidate:",
    "replacement": "备选："
  },
  {
    "id": "  after user-defined conversion:",
    "pattern": "  after user-defined conversion:",
    "replacement": " 启用用户自定义指令："
  },
  {
    "id": "candidate is:",
    "pattern": "candidate( is|s are):",
    "replacement": "备选为："
  },
  {
    "id": "candidate 1:",
    "pattern": "candidate 1:",
    "replacement": "备选 1："
  },
  {
    "id": "candidate 2:",
    "pattern": "candidate 2:",
    "replacement": "备选 2："
  },
  {
    "id": "jump to label %qD",
    "pattern": "jump to label '(.+?)'",
    "replacement": "跳转至标号 '$1'"
  },
  {
    "id": "jump to case label",
    "pattern": "jump to case label",
    "replacement": "跳转至 case 标号"
  },
  {
    "id": "<missing>",
    "pattern": "<missing>",
    "replacement": "<丢失>"
  },
  {
    "id": "<brace-enclosed initializer list>",
    "pattern": "<brace-enclosed initializer list>",
    "replacement": "<花括号内的初始值列表>"
  },
  {
    "id": "<unresolved overloaded function type>",
    "pattern": "<unresolved overloaded function type>",
    "replacement": "<未解决的重载函数类型>"
  },
  {
    "id": "<type error>",
    "pattern": "<type error>",
    "replacement": "<类型错误>"
  },
  {
    "id": "<lambda",
    "pattern": "<lambda",
    "replacement": "<lambda"
  },
  {
    "id": "<unnamed>",
    "pattern": "<unnamed>",
    "replacement": "<无名>"
  },
  {
    "id": "<unnamed %s>",
    "pattern": "<unnamed (.*?)>",
    "replacement": "<无名>"
  },
  {
    "id": "<typeprefixerror>",
    "pattern": "<typeprefixerror>",
    "replacement": "<类型前缀错误>"
  },
  {
    "id": "(static initializers for %s)",
    "pattern": "(static initializers for (.*?))",
    "replacement": "((.*?) 的静态初始化器)"
  },
  {
    "id": "(static destructors for %s)",
    "pattern": "(static destructors for (.*?))",
    "replacement": "((.*?) 的静态析构函数)"
  },
  {
    "id": "<structured bindings>",
    "pattern": "<structured bindings>",
    "replacement": "<结构化绑定>"
  },
  {
    "id": "vtable for ",
    "pattern": "vtable for ",
    "replacement": "虚表 "
  },
  {
    "id": "<return value> ",
    "pattern": "<return value> ",
    "replacement": "<返回值> "
  },
  {
    "id": "{anonymous}",
    "pattern": "\\{anonymous\\}",
    "replacement": "{匿名}"
  },
  {
    "id": "(anonymous namespace)",
    "pattern": "(anonymous namespace)",
    "replacement": "(匿名命名空间)"
  },
  {
    "id": "<template arguments error>",
    "pattern": "<template arguments error>",
    "replacement": "<模板实参错误>"
  },
  {
    "id": "<enumerator>",
    "pattern": "<enumerator>",
    "replacement": "<枚举值>"
  },
  {
    "id": "<declaration error>",
    "pattern": "<declaration error>",
    "replacement": "<声明错误>"
  },
  {
    "id": "<template parameter error>",
    "pattern": "<template parameter error>",
    "replacement": "<模板形参错误>"
  },
  {
    "id": "<statement>",
    "pattern": "<statement>",
    "replacement": "<语句>"
  },
  {
    "id": "<unknown>",
    "pattern": "<unknown>",
    "replacement": "<未知>"
  },
  {
    "id": "<throw-expression>",
    "pattern": "<throw-expression>",
    "replacement": "<throw 表达式>"
  },
  {
    "id": "<ubsan routine call>",
    "pattern": "<ubsan routine call>",
    "replacement": "<ubsan routine 调用>"
  },
  {
    "id": "<unparsed>",
    "pattern": "<unparsed>",
    "replacement": "<未解析>"
  },
  {
    "id": "<lambda>",
    "pattern": "<lambda>",
    "replacement": "<lambda>"
  },
  {
    "id": "*this",
    "pattern": "\\*this",
    "replacement": "*this"
  },
  {
    "id": "<expression error>",
    "pattern": "<expression error>",
    "replacement": "<表达式错误>"
  },
  {
    "id": "<unknown operator>",
    "pattern": "<unknown operator>",
    "replacement": "<未知的运算符>"
  },
  {
    "id": "At global scope:",
    "pattern": "At global scope:",
    "replacement": "在全局作用域："
  },
  {
    "id": "In static member function %qs",
    "pattern": "In static member function '(.+?)'",
    "replacement": "在静态成员函数 '$1' 中"
  },
  {
    "id": "In copy constructor %qs",
    "pattern": "In copy constructor '(.+?)'",
    "replacement": "在复制构造函数 '$1' 中"
  },
  {
    "id": "In constructor %qs",
    "pattern": "In constructor '(.+?)'",
    "replacement": "在构造函数 '$1' 中"
  },
  {
    "id": "In destructor %qs",
    "pattern": "In destructor '(.+?)'",
    "replacement": "在析构函数 '$1' 中"
  },
  {
    "id": "In lambda function",
    "pattern": "In lambda function",
    "replacement": "在 lambda 函数中"
  },
  {
    "id": "%s: In substitution of %qS:\\n",
    "pattern": "(.*): In substitution of '(.+?)'",
    "replacement": "$1: 在 '$2' 的匹配中"
  },
  {
    "id": "%s: In instantiation of %q#D:\\n",
    "pattern": "(.*): In instantiation of '(.+?)'",
    "replacement": "$1: 在 '$2' 的实例化中"
  },
  {
    "id": "recursively required by substitution of %qS\\n",
    "pattern": "recursively required by substitution of '(.+?)'",
    "replacement": "递归地被 $1 的匹配所要求"
  },
  {
    "id": "required by substitution of %qS\\n",
    "pattern": "required by substitution of '(.+?)'",
    "replacement": "被 $1 的匹配所要求"
  },
  {
    "id": "recursively required from %q#D\\n",
    "pattern": "recursively required from '(.+?)'",
    "replacement": "递归地于 $1 要求"
  },
  {
    "id": "required from %q#D\\n",
    "pattern": "required from '(.+?)'",
    "replacement": "于 $1 要求"
  },
  {
    "id": "recursively required from here\\n",
    "pattern": "recursively required from here",
    "replacement": "递归地于此处要求"
  },
  {
    "id": "required from here\\n",
    "pattern": "required from here",
    "replacement": "于此处要求"
  },
  {
    "id": "%r%s:%d:%d:%R   [ skipping %d instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]\\n",
    "pattern": "skipping (\\d+) instantiation contexts, use -ftemplate-backtrace-limit=0 to disable",
    "replacement": "跳过 $1 个实例化上下文，使用 -ftemplate-backtrace-limit=0 来禁用"
  },
  {
    "id": "%r%s:%d:%d:%R   in %<constexpr%> expansion of %qs",
    "pattern": "in 'constexpr' expansion of '(.+?)'",
    "replacement": "在 '$1' 的常量表达式展开中"
  },
  {
    "id": "parameter %qD may not appear in this context",
    "pattern": "parameter '(.+?)' may not appear in this context",
    "replacement": "形参 '$1' 不应出现在此上下文中"
  },
  {
    "id": "local variable %qD may not appear in this context",
    "pattern": "local variable '(.+?)' may not appear in this context",
    "replacement": "局部变量 '$1' 不应出现在此上下文中"
  },
  {
    "id": "%<using enum%> only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "'using enum' only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'using enum' 只在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "%<using enum%> of dependent type %qT",
    "pattern": "'using enum' of dependent type '(.+?)'",
    "replacement": "'using enum' 作用于待决类型 '$1'"
  },
  {
    "id": "%<using enum%> of non-enumeration type %q#T",
    "pattern": "'using enum' of non-enumeration type '(.+?)'",
    "replacement": "'using enum' 作用于非枚举类型 '$1'"
  },
  {
    "id": "%<using enum%> of incomplete type %qT",
    "pattern": "'using enum' of incomplete type '(.+?)'",
    "replacement": "'using enum' 作用于不完整类型 '$1'"
  },
  {
    "id": "%<using enum%> of %qT before its enum-specifier",
    "pattern": "'using enum' of '(.+?)' before its enum-specifier",
    "replacement": "'$1' 的 'using enum' 在枚举声明符前出现"
  },
  {
    "id": "candidates are:",
    "pattern": "candidates are:",
    "replacement": "备选为："
  },
  {
    "id": "target is not pointer or reference to class",
    "pattern": "target is not pointer or reference to class",
    "replacement": "目标不是指向类的指针或引用"
  },
  {
    "id": "target is not pointer or reference to complete type",
    "pattern": "target is not pointer or reference to complete type",
    "replacement": "目标不是指向完整类型的指针或引用"
  },
  {
    "id": "target is not pointer or reference",
    "pattern": "target is not pointer or reference",
    "replacement": "目标不是一个指针或引用"
  },
  {
    "id": "source is not a pointer",
    "pattern": "source is not a pointer",
    "replacement": "源不是一个指针"
  },
  {
    "id": "source is not a pointer to class",
    "pattern": "source is not a pointer to class",
    "replacement": "源不是一个指向类的指针"
  },
  {
    "id": "source is a pointer to incomplete type",
    "pattern": "source is a pointer to incomplete type",
    "replacement": "源是一个指向不完整类型的指针"
  },
  {
    "id": "source is not of class type",
    "pattern": "source is not of class type",
    "replacement": "源不具有类类型"
  },
  {
    "id": "source is of incomplete class type",
    "pattern": "source is of incomplete class type",
    "replacement": "源有不完全的类类型"
  },
  {
    "id": "conversion casts away constness",
    "pattern": "conversion casts away constness",
    "replacement": "类型转换丢失了只读性"
  },
  {
    "id": "source type is not polymorphic",
    "pattern": "source type is not polymorphic",
    "replacement": "源类型不是多态的"
  },
  {
    "id": "wrong type argument to unary minus",
    "pattern": "wrong type argument to unary minus",
    "replacement": "一元减的操作数类型错误"
  },
  {
    "id": "wrong type argument to unary plus",
    "pattern": "wrong type argument to unary plus",
    "replacement": "一元加的操作数类型错误"
  },
  {
    "id": "wrong type argument to bit-complement",
    "pattern": "wrong type argument to bit-complement",
    "replacement": "按位取反的实参类型错误"
  },
  {
    "id": "wrong type argument to abs",
    "pattern": "wrong type argument to abs",
    "replacement": "不能对该类型的实参求绝对值"
  },
  {
    "id": "wrong type argument to conjugation",
    "pattern": "wrong type argument to conjugation",
    "replacement": "不能对该类型的实参求共轭"
  },
  {
    "id": "in argument to unary !",
    "pattern": "in argument to unary !",
    "replacement": "一元 ! 的实参中"
  },
  {
    "id": "no pre-increment operator for type",
    "pattern": "no pre-increment operator for type",
    "replacement": "类型没有前缀自增运算符"
  },
  {
    "id": "no post-increment operator for type",
    "pattern": "no post-increment operator for type",
    "replacement": "类型没有后缀自增运算符"
  },
  {
    "id": "no pre-decrement operator for type",
    "pattern": "no pre-decrement operator for type",
    "replacement": "类型没有前缀自减运算符"
  },
  {
    "id": "no post-decrement operator for type",
    "pattern": "no post-decrement operator for type",
    "replacement": "类型没有后缀自减运算符"
  },
  {
    "id": "value computed is not used",
    "pattern": "value computed is not used",
    "replacement": "计算出的值未被使用"
  },
  {
    "id": "expected integer",
    "pattern": "expected integer",
    "replacement": "需要整数"
  },
  {
    "id": "too many arguments",
    "pattern": "too many arguments",
    "replacement": "实参太多"
  },
  {
    "id": "previous declaration here",
    "pattern": "previous declaration here",
    "replacement": "之前在此声明"
  },
  {
    "id": "%qE attribute does not apply to types",
    "pattern": "'(.+?)' attribute does not apply to types",
    "replacement": "特性 '$1' 不能应用于类型"
  },
  {
    "id": "previous declaration of %qD",
    "pattern": "previous declaration of '(.+?)'",
    "replacement": "之前 '$1' 的声明"
  },
  {
    "id": "%qE declared here",
    "pattern": "'(.+?)' declared here",
    "replacement": "'$1' 在此声明"
  },
  {
    "id": "declared here",
    "pattern": "declared here",
    "replacement": "在此声明"
  },
  {
    "id": "%q+D aliased to undefined symbol %qE",
    "pattern": "'(.+?)' aliased to undefined symbol '(.+?)' ",
    "replacement": "'$1' 是未定义符号 '$2' 的别名"
  },
  {
    "id": "debug path",
    "pattern": "debug path",
    "replacement": "调试路径"
  },
  {
    "id": "assuming signed overflow does not occur when simplifying range test",
    "pattern": "assuming signed overflow does not occur when simplifying range test",
    "replacement": "简化范围检查时假定有符号数从不溢出"
  },
  {
    "id": "cannot use %<-%> as input filename for a precompiled header",
    "pattern": "cannot use '-' as input filename for a precompiled header",
    "replacement": "在预编译头中不能使用 '-' 作为输入文件名"
  },
  {
    "id": "%G%qD specified bound %E equals destination size",
    "pattern": "'(.+?)' specified bound (.+?) equals destination size",
    "replacement": "'$1' 指明边界 $2 等于目标大小"
  },
  {
    "id": "array %qD declared here",
    "pattern": "array '(.+?)' declared here",
    "replacement": "数组 '$1' 在此声明"
  },
  {
    "id": "%qD declared here",
    "pattern": "'(.+?)' declared here",
    "replacement": "'$1' 在此声明"
  },
  {
    "id": "cannot read %s: %m",
    "pattern": "cannot read (.+?): (.+?)",
    "replacement": "无法读取 $1：$2"
  },
  {
    "id": "%<depend(%s)%> is only allowed in %<omp ordered%>",
    "pattern": "'depend(.*?)' is only allowed in 'omp ordered'",
    "replacement": "'depend($1)' 仅在 'omp ordered' 下允许"
  },
  {
    "id": "switch %qs is no longer supported",
    "pattern": "switch (.*?) is no longer supported",
    "replacement": "开关 $1 不再被支持"
  },
  {
    "id": "ignoring return value of function declared with attribute %<warn_unused_result%>",
    "pattern": "ignoring return value of function declared with attribute 'warn_unused_result'",
    "replacement": "忽略声明有 'warn_unused_result' 特性的函数的返回值"
  },
  {
    "id": "SSA corruption",
    "pattern": "SSA corruption",
    "replacement": "SSA 损坏"
  },
  {
    "id": "invalid fn spec attribute \\\"%s\\",
    "pattern": "invalid fn spec attribute \"(.*?)",
    "replacement": "无效的函数特性 \"$1"
  },
  {
    "id": "invalid fn spec attribute \\\"%s\\\" arg %i",
    "pattern": "invalid fn spec attribute \"(.*?)\" arg (\\d+)",
    "replacement": "无效的函数特性 \"$1\" 实参 $2"
  },
  {
    "id": "%G%qs pointer is null",
    "pattern": "'(.+?)' pointer is null",
    "replacement": "'$1' 指针为空"
  },
  {
    "id": "in a call to non-static member function %qD",
    "pattern": "in a call to non-static member function '(.+?)'",
    "replacement": "对非静态成员函数 '$1' 的调用中"
  },
  {
    "id": "%Gargument %u null where non-null expected",
    "pattern": "argument (\\d+) null where non-null expected",
    "replacement": "实参 $1 为空，但期望非空"
  },
  {
    "id": "in a call to built-in function %qD",
    "pattern": "in a call to built-in function '(.+?)'",
    "replacement": "对内建函数 '$1' 的调用中"
  },
  {
    "id": "in a call to function %qD declared %qs",
    "pattern": "in a call to function '(.+?)' declared '(.+?)'",
    "replacement": "对声明为 '$2' 的函数 '$1' 的调用中"
  },
  {
    "id": "iteration %s invokes undefined behavior",
    "pattern": "iteration (.*?) invokes undefined behavior",
    "replacement": "$1 上的迭代触发未定义行为"
  },
  {
    "id": "within this loop",
    "pattern": "within this loop",
    "replacement": "在此循环中"
  },
  {
    "id": "%<l1-cache-size%> parameter is not a power of two %d",
    "pattern": "'l1-cache-size' parameter is not a power of two",
    "replacement": "'l1-cache-size' 形参不是 2 的幂"
  },
  {
    "id": "virtual definition of statement not up to date",
    "pattern": "virtual definition of statement not up to date",
    "replacement": "虚定义的语句无法更新"
  },
  {
    "id": "virtual def operand missing for statement",
    "pattern": "virtual def operand missing for statement",
    "replacement": "虚定义中用于语句中操作数丢失"
  },
  {
    "id": "virtual use of statement not up to date",
    "pattern": "virtual use of statement not up to date",
    "replacement": "使用的语句无法更新"
  },
  {
    "id": "virtual use operand missing for statement",
    "pattern": "virtual use operand missing for statement",
    "replacement": "虚使用中用于语句中操作数丢失"
  },
  {
    "id": "excess use operand for statement",
    "pattern": "excess use operand for statement",
    "replacement": "用于语句的使用操作数越界"
  },
  {
    "id": "use operand missing for statement",
    "pattern": "use operand missing for statement",
    "replacement": "用于语句的使用操作数丢失"
  },
  {
    "id": "statement volatile flag not up to date",
    "pattern": "statement volatile flag not up to date",
    "replacement": "语句 volatile 标记无法更新"
  },
  {
    "id": "%G%qD writing one too many bytes into a region of a size that depends on %<strlen%>",
    "pattern": "writing one too many bytes into a region of a size that depends on strlen'",
    "replacement": "向大小依赖于 strlen 的区域写入过多字节"
  },
  {
    "id": "%G%qD writing %wu byte into a region of size %wu",
    "pattern": "writing (.*?) bytes? into a region of size (.*?)",
    "replacement": "向 $2 大小的区域写入 $1 字节"
  },
  {
    "id": "%G%qD writing %wu byte into a region of size between %wu and %wu",
    "pattern": "writing (.*?) bytes? into a region of size between (.*?) and (.*?)",
    "replacement": "向大小介于 $2 和 $3 的区域写入 $1 字节"
  },
  {
    "id": "%G%qD writing between %wu and %wu bytes into a region of size %wu",
    "pattern": "writing between (.*?) and (.*?) bytes into a region of size (.*?)",
    "replacement": "向 $3 大小的区域写入 $1 ~ $2 字节"
  },
  {
    "id": "%G%qD writing between %wu and %wu bytes into a region of size between %wu and %wu",
    "pattern": "writing between (.*?) and (.*?) bytes into a region of size between (.*?) and (.*?)",
    "replacement": "向大小介于 $3 和 $4 的区域写入 $1 ~ $2 字节"
  },
  {
    "id": "%G%qD output truncated before terminating nul copying %E byte from a string of the same length",
    "pattern": "output truncated before terminating nul copying (.*?) bytes? from a string of the same length",
    "replacement": "从 $1 长度的字符串复制时，输出在空字符前截断"
  },
  {
    "id": "%G%qD output truncated copying %E byte from a string of length %wu",
    "pattern": "output truncated copying (.*?) bytes? from a string of length (.*?)",
    "replacement": "从 $2 长度的字符串复制 $1 字节时，输出截断"
  },
  {
    "id": "%G%qD output truncated copying between %wu and %wu bytes from a string of length %wu",
    "pattern": "output truncated copying between (.*?) and (.*?) bytes from a string of length (.*?)",
    "replacement": "从 $3 长度的字符串复制 $1 ~ $2 字节时，输出截断"
  },
  {
    "id": "%G%qD output may be truncated copying %E byte from a string of length %wu",
    "pattern": "output may be truncated copying (.*?) bytes? from a string of length (.*?)",
    "replacement": "从 $2 长度的字符串复制 $1 字节时，输出可能被截断"
  },
  {
    "id": "%G%qD output may be truncated copying between %wu and %wu bytes from a string of length %wu",
    "pattern": "output may be truncated copying between (.*?) and (.*?) bytes from a string of length (.*?)",
    "replacement": "从 $3 长度的字符串复制 $1 ~ $2 字节时，输出可能被"
  },
  {
    "id": "%G%qD output truncated before terminating nul copying as many bytes from a string as its length",
    "pattern": "output truncated before terminating nul copying as many bytes from a string as its length",
    "replacement": "从字符串复制同样长度的字节时，输出在空字符前截断"
  },
  {
    "id": "%G%qD specified bound depends on the length of the source argument",
    "pattern": "specified bound depends on the length of the source argument",
    "replacement": "指定边界依赖于源实参的长度"
  },
  {
    "id": "length computed here",
    "pattern": "length computed here",
    "replacement": "长度在此计算"
  },
  {
    "id": "%G%qD of a string of length %wu or more and an array of size %wu evaluates to nonzero",
    "pattern": "'(.+?)' of a string of length (.*?) or more and an array of size (.*?) evaluates to nonzero",
    "replacement": "长度不小于 $2 的字符串的 '$1' 和大小 $3 的数组求值为非零"
  },
  {
    "id": "%G%qD of a string of length %wu and an array of size %wu evaluates to nonzero",
    "pattern": "'(.+?)' of a string of length (.*?) and an array of size (.*?) evaluates to nonzero",
    "replacement": "长度 $2 的字符串的 '$1' 和大小 $3 的数组求值为非零"
  },
  {
    "id": "%G%qD of strings of length %wu and %wu and bound of %wu evaluates to nonzero",
    "pattern": "'(.+?)' of strings of length (.*?) and (.*?) and bound of (.*?) evaluates to nonzero",
    "replacement": "长度 $2 和 $3 的字符串的 '$1' 和 $3 的界求值为非零"
  },
  {
    "id": "%G%qD of a string of length %wu, an array of size %wu and bound of %wu evaluates to nonzero",
    "pattern": "'(.+?)' of a string of length (.*?), an array of size (.*?) and bound of (.*?) evaluates to nonzero",
    "replacement": "长度 $2 和 $3 的字符串的 '$1' 和大小 $3 的数组和 $3 的界求值为非零"
  },
  {
    "id": "in this expression",
    "pattern": "in this expression",
    "replacement": "在此表达式中"
  },
  {
    "id": "%qD was declared here",
    "pattern": "'(.+?)' was declared here",
    "replacement": "'$1' 在此声明"
  },
  {
    "id": "%G%qE is used uninitialized",
    "pattern": "'(.+?)' is used uninitialized",
    "replacement": "'$1' 在使用时未初始化"
  },
  {
    "id": "%G%qE may be used uninitialized",
    "pattern": "'(.+?)' may be used uninitialized",
    "replacement": "'$1' 在使用时可能未初始化"
  },
  {
    "id": "in a call to %qD declared with attribute %<%s%> here",
    "pattern": "in a call to '(.+?)' declared with attribute '(.+?)' here",
    "replacement": "在对 '$1' 的调用中，此处声明有错误的 '$2' 特性"
  },
  {
    "id": "in a call to %qT declared with attribute %<%s%>",
    "pattern": "in a call to '(.+?)' declared with attribute '(.+?)'",
    "replacement": "在对 '$1' 的调用中，声明有错误的 '$2' 特性"
  },
  {
    "id": "by argument %u of type %s to %qD declared here",
    "pattern": "by argument (\\d+) of type (.*?) to '(.+?)' declared here",
    "replacement": "由在此声明的类型为 '$3' 的 $2 的第 $1 个实参"
  },
  {
    "id": "by argument %u of type %s to %qT",
    "pattern": "by argument (\\d+) of type (.*?) to '(.+?)'",
    "replacement": "由类型为 '$3' 的 $2 的第 $1 个实参"
  },
  {
    "id": "%qD may be used uninitialized in this function",
    "pattern": "'(.+?)' may be used uninitialized in this function",
    "replacement": "'$1' 在此函数中使用时未初始化"
  },
  {
    "id": "unsupported record layout",
    "pattern": "unsupported record layout",
    "replacement": "不支持的记录布局"
  },
  {
    "id": "%qE attribute argument is invalid",
    "pattern": "'(.+?)' attribute argument is invalid",
    "replacement": "'$1' 特性的实参无效"
  },
  {
    "id": "%qE attribute argument %i is invalid",
    "pattern": "'(.+?)' attribute argument (\\d+) is invalid",
    "replacement": "'$1' 特性的第 $2 个实参无效"
  },
  {
    "id": "%qE attribute argument has type %qT",
    "pattern": "'(.+?)' attribute argument has type '(.+?)'",
    "replacement": "特性 '$1' 的实参具有类型 '$2'"
  },
  {
    "id": "%qE attribute argument %i has type %qT",
    "pattern": "'(.+?)' attribute argument (\\d+) has type '(.+?)'",
    "replacement": "特性 '$1' 的第 $2 个实参具有类型 '$3'"
  },
  {
    "id": "%qE attribute argument value %qE is not an integer constant",
    "pattern": "'(.+?)' attribute argument value '(.+?)' is not an integer constant",
    "replacement": "'$1' 特性的实参 '$2' 不是整数类型常量"
  },
  {
    "id": "%qE attribute argument %i value %qE is not an integer constant",
    "pattern": "'(.+?)' attribute argument (\\d+) value '(.+?)' is not an integer constant",
    "replacement": "'$1' 特性的第 $2 个实参 '$3' 不是整数类型常量"
  },
  {
    "id": "%qE attribute argument value %qE does not refer to a function parameter",
    "pattern": "'(.+?)' attribute argument value '(.+?)' does not refer to a function parameter",
    "replacement": "'$1' 特性的实参 '$2' 不指示一个函数形参"
  },
  {
    "id": "%qE attribute argument %i value %qE does not refer to a function parameter",
    "pattern": "'(.+?)' attribute argument (\\d+) value '(.+?)' does not refer to a function parameter",
    "replacement": "'$1' 特性的第 $2 个实参 '$3' 不指示一个函数形参"
  },
  {
    "id": "%qE attribute argument value %qE exceeds the number of function parameters %u",
    "pattern": "'(.+?)' attribute argument value '(.+?)' exceeds the number of function parameters (\\d+)",
    "replacement": "'$1' 特性的实参 '$2' 超过了函数形参的个数（$3）"
  },
  {
    "id": "%qE attribute argument %i value %qE exceeds the number of function parameters %u",
    "pattern": "'(.+?)' attribute argument (\\d+) value '(.+?)' exceeds the number of function parameters (\\d+)",
    "replacement": "'$1' 特性的第 $2 个实参 '$3' 超过了函数形参的个数（$4）"
  },
  {
    "id": "%qE attribute argument value %qE does not refer to a variable argument list",
    "pattern": "'(.+?)' attribute argument value '(.+?)' does not refer to a variable argument list",
    "replacement": "'$1' 特性的实参 '$2' 不指示一个变长实参列表"
  },
  {
    "id": "%qE attribute argument %i value %qE does not refer to a variable argument list",
    "pattern": "'(.+?)' attribute argument (\\d+) value '(.+?)' does not refer to a variable argument list",
    "replacement": "'$1' 特性的第 $2 个实参 '$3' 不指示一个变长实参列表"
  },
  {
    "id": "%qE attribute argument value %qE refers to parameter type %qT",
    "pattern": "'(.+?)' attribute argument value '(.+?)' refers to parameter type '(.+?)'",
    "replacement": "'$1' 特性的实参 '$2' 指示一个形参类型 '$3'"
  },
  {
    "id": "%qE attribute argument %i value %qE refers to parameter type %qT",
    "pattern": "'(.+?)' attribute argument (\\d+) value '(.+?)' refers to parameter type '(.+?)'",
    "replacement": "'$1' 特性的第 $2 个实参 '$3' 指示一个形参类型 '$4'"
  },
  {
    "id": "%qE attribute argument value %qE refers to a variadic function parameter of unknown type",
    "pattern": "'(.+?)' attribute argument value '(.+?)' refers to a variadic function parameter of unknown type",
    "replacement": "'$1' 特性的实参 '$2' 指示一个未知类型的函数变长形参"
  },
  {
    "id": "%qE attribute argument %i value %qE refers to a variadic function parameter of unknown type",
    "pattern": "'(.+?)' attribute argument (\\d+) value '(.+?)' refers to a variadic function parameter of unknown type",
    "replacement": "'$1' 特性的第 $2 个实参 '$3' 指示一个未知类型的函数变长形参"
  },
  {
    "id": "ignoring attribute %qs because it conflicts with previous %qs",
    "pattern": "ignoring attribute '(.+?)' because it conflicts with previous '(.+?)'",
    "replacement": "忽略 '$1' 特性，因其与之前的 '$2' 冲突"
  },
  {
    "id": "%qE attribute only supported on boolean types",
    "pattern": "'(.+?)' attribute only supported on boolean types",
    "replacement": "'$1' 特性仅支持布尔类型"
  },
  {
    "id": "%qE attribute with unsupported boolean precision",
    "pattern": "'(.+?)' attribute with unsupported boolean precision",
    "replacement": "'$1' 特性使用了不支持的布尔精度"
  },
  {
    "id": "%qE attribute ignored for type %qT",
    "pattern": "'(.+?)' attribute ignored for type '(.+?)'",
    "replacement": "'$1' 特性为类型 '$2' 所忽略"
  },
  {
    "id": "%qE attribute ignored for field of type %qT",
    "pattern": "'(.+?)' attribute ignored for field of type '(.+?)'",
    "replacement": "'$1' 特性为类型为 '$2' 的字段所忽略"
  },
  {
    "id": "%qE argument not a string",
    "pattern": "'(.+?)' argument not a string",
    "replacement": "'$1' 特性的实参不是字符串"
  },
  {
    "id": "%qE attribute ignored due to conflict with attribute %qs",
    "pattern": "'(.+?)' attribute ignored due to conflict with attribute '(.+?)'",
    "replacement": "'$1' 特性被忽略，因其与 '$2' 特性冲突"
  },
  {
    "id": "%qE attribute ignored. Use %<-fcf-protection%> option to enable it",
    "pattern": "'(.+?)' attribute ignored. Use '-fcf-protection' option to enable it",
    "replacement": "'$1' 特性被忽略。使用 '-fcf-protection' 选项来启用它"
  },
  {
    "id": "%qE attribute have effect only on public objects",
    "pattern": "'(.+?)' attribute have effect only on public objects",
    "replacement": "'$1' 特性只在公开对象上有效"
  },
  {
    "id": "%qE attribute only affects top level objects",
    "pattern": "'(.+?)' attribute only affects top level objects",
    "replacement": "'$1' 特性只在顶层对象上有效"
  },
  {
    "id": "%qE attribute on function returning %<void%>",
    "pattern": "'(.+?)' attribute on function returning 'void'",
    "replacement": "'$1' 特性作用于返回 'void' 的函数上"
  },
  {
    "id": "%qE attribute is not supported because endianness is not uniform",
    "pattern": "'(.+?)' attribute is not supported because endianness is not uniform",
    "replacement": "'$1' 特性不支持，因端序不是统一的"
  },
  {
    "id": "attribute %qE argument must be one of %qs or %qs",
    "pattern": "attribute '(.+?)' argument must be one of '(.+?)' or '(.+?)'",
    "replacement": "'$1' 特性的实参只能是 '$2' 或 '$3' 中的一个"
  },
  {
    "id": "destructor priorities are not supported",
    "pattern": "destructor priorities are not supported",
    "replacement": "不支持析构函数优先级"
  },
  {
    "id": "constructor priorities are not supported",
    "pattern": "constructor priorities are not supported",
    "replacement": "不支持构造函数优先级"
  },
  {
    "id": "destructor priorities from 0 to %d are reserved for the implementation",
    "pattern": "destructor priorities from 0 to (\\d+) are reserved for the implementation",
    "replacement": "析构函数优先级 0 到 $1 为实现所保留"
  },
  {
    "id": "constructor priorities from 0 to %d are reserved for the implementation",
    "pattern": "constructor priorities from 0 to (\\d+) are reserved for the implementation",
    "replacement": "构造函数优先级 0 到 $1 为实现所保留"
  },
  {
    "id": "destructor priorities must be integers from 0 to %d inclusive",
    "pattern": "destructor priorities must be integers from 0 to (\\d+) inclusive",
    "replacement": "析构函数优先级必须为 0 到 $1 间的整数"
  },
  {
    "id": "constructor priorities must be integers from 0 to %d inclusive",
    "pattern": "constructor priorities must be integers from 0 to (\\d+) inclusive",
    "replacement": "构造函数优先级必须为 0 到 $1 间的整数"
  },
  {
    "id": "unknown machine mode %qE",
    "pattern": "unknown machine mode '(.+?)'",
    "replacement": "未知的机器模式 '$1'"
  },
  {
    "id": "specifying vector types with %<__attribute__ ((mode))%> is deprecated",
    "pattern": "specifying vector types with '__attribute__ ((mode))' is deprecated",
    "replacement": "已弃用在指定向量类型时使用 '__attribute__ ((mode))'"
  },
  {
    "id": "use %<__attribute__ ((vector_size))%> instead",
    "pattern": "use '__attribute__ ((vector_size))' instead",
    "replacement": "改用 '__attribute__ ((vector_size))'"
  },
  {
    "id": "unable to emulate %qs",
    "pattern": "unable to emulate '(.+?)'",
    "replacement": "无法枚举 '$1'"
  },
  {
    "id": "invalid pointer mode %qs",
    "pattern": "invalid pointer mode '(.+?)'",
    "replacement": "无效的指针模式 '$1'"
  },
  {
    "id": "signedness of type and machine mode %qs don%'t match",
    "pattern": "signedness of type and machine mode '(.+?)' don't match",
    "replacement": "类型的符号与机器模式 '$1' 不匹配"
  },
  {
    "id": "no data type for mode %qs",
    "pattern": "no data type for mode '(.+?)'",
    "replacement": "没有模式为 '$1' 的数据类型"
  },
  {
    "id": "cannot use mode %qs for enumerated types",
    "pattern": "cannot use mode '(.+?)' for enumerated types",
    "replacement": "无法为枚举类型使用模式 '$1'"
  },
  {
    "id": "mode %qs applied to inappropriate type",
    "pattern": "mode '(.+?)' applied to inappropriate type",
    "replacement": "对不合适的类型应用模式 '$1'"
  },
  {
    "id": "section attributes are not supported for this target",
    "pattern": "section attributes are not supported for this target",
    "replacement": "此目标机不支持节属性"
  },
  {
    "id": "section attribute not allowed for %q+D",
    "pattern": "section attribute not allowed for '(.+?)'",
    "replacement": "'$1' 不能有 section 特性"
  },
  {
    "id": "section attribute argument not a string constant",
    "pattern": "section attribute argument not a string constant",
    "replacement": "section 特性需要一个字符串常量作为实参"
  },
  {
    "id": "section attribute cannot be specified for local variables",
    "pattern": "section attribute cannot be specified for local variables",
    "replacement": "不能为局部变量指定 section 特性"
  },
  {
    "id": "section of %q+D cannot be overridden",
    "pattern": "section of '(.+?)' cannot be overridden",
    "replacement": "节 '$1' 无法被重写"
  },
  {
    "id": "alignment may not be specified for %q+D",
    "pattern": "alignment may not be specified for '(.+?)'",
    "replacement": "不能为 '$1' 指定对齐"
  },
  {
    "id": "ignoring attribute %<%E (%u)%> because it conflicts with attribute %<%E (%u)%>",
    "pattern": "ignoring attribute '(.+?) \\((\\d+)\\)' because it conflicts with attribute '(.+?) \\((\\d+)\\)'",
    "replacement": "忽略特性 '$1 ($2)'，因其与特性 '$3 ($4)' 冲突"
  },
  {
    "id": "alignment for %q+D was previously specified as %d and may not be decreased",
    "pattern": "alignment for '(.+?)' was previously specified as (\\d+) and may not be decreased",
    "replacement": "'$1' 的对齐边界之前被指定为 $2 而不能被减小"
  },
  {
    "id": "%<warn_if_not_aligned%> may not be specified for %q+D",
    "pattern": "'warn_if_not_aligned' may not be specified for '(.+?)'",
    "replacement": "不能为 '$1' 指定 'warn_if_not_aligned'"
  },
  {
    "id": "inline function %q+D declared weak",
    "pattern": "inline function '(.+?)' declared weak",
    "replacement": "内联函数 '$1' 声明为弱符号"
  },
  {
    "id": "indirect function %q+D cannot be declared weak",
    "pattern": "indirect function '(.+?)' cannot be declared weak",
    "replacement": "内联函数 '$1' 不能声明为有弱链接"
  },
  {
    "id": "ignoring %qE attribute not set on a variable",
    "pattern": "ignoring '(.+?)' attribute not set on a variable",
    "replacement": "忽略 '$1' 特性未设置在变量上"
  },
  {
    "id": "%qE attribute cannot be specified for local variables",
    "pattern": "'(.+?)' attribute cannot be specified for local variables",
    "replacement": "不能为局部变量指定 '$1' 特性"
  },
  {
    "id": "%qE attribute is specific to ELF targets",
    "pattern": "'(.+?)' attribute is specific to ELF targets",
    "replacement": "只能在 ELF 目标上使用 '$1' 特性"
  },
  {
    "id": "ignoring %qE attribute set on const variable",
    "pattern": "ignoring '(.+?)' attribute set on const variable",
    "replacement": "忽略 '$1' 特性设置在只读变量上"
  },
  {
    "id": "ignoring %qE attribute set on initialized variable",
    "pattern": "ignoring '(.+?)' attribute set on initialized variable",
    "replacement": "忽略 '$1' 特性设置在已初始化变量上"
  },
  {
    "id": "ignoring %qE attribute set on uninitialized variable",
    "pattern": "ignoring '(.+?)' attribute set on uninitialized variable",
    "replacement": "忽略 '$1' 特性设置在已初始化变量上"
  },
  {
    "id": "%qE attribute is only applicable on functions",
    "pattern": "'(.+?)' attribute is only applicable on functions",
    "replacement": "'$1' 特性只能应用于函数"
  },
  {
    "id": "%<symver%> attribute only applies to functions and variables",
    "pattern": "'symver' attribute only applies to functions and variables",
    "replacement": "'symver' 特性只能应用于函数和变量"
  },
  {
    "id": "%<symver%> attribute is only applicable to symbols",
    "pattern": "'symver' attribute is only applicable to symbols",
    "replacement": "'symver' 特性只能用于符号"
  },
  {
    "id": "%<symver%> attribute argument not a string constant",
    "pattern": "'symver' attribute argument not a string constant",
    "replacement": "'symver' 特性的实参不是一个字符串常量"
  },
  {
    "id": "symver attribute argument must have format %<name@nodename%>",
    "pattern": "symver attribute argument must have format 'name@nodename'",
    "replacement": "'symver' 特性的实参必须具有格式 'name@nodename'"
  },
  {
    "id": "%<symver%> attribute argument %qs must contain one or two %<@%>",
    "pattern": "'symver' attribute argument '(.+?)' must contain one or two '@'",
    "replacement": "'symver' 特性的实参 '$1' 必须包含一或两个 '@'"
  },
  {
    "id": "%q+D defined both normally and as %qE attribute",
    "pattern": "'(.+?)' defined both normally and as '(.+?)' attribute",
    "replacement": "'$1' 以通常形式定义，且被 '$2' 特性定义"
  },
  {
    "id": "weak %q+D cannot be defined %qE",
    "pattern": "weak '(.+?)' cannot be defined '(.+?)'",
    "replacement": "弱 '$1' 无法被定义为 '$2'"
  },
  {
    "id": "attribute %qE argument not a string",
    "pattern": "attribute '(.+?)' argument not a string",
    "replacement": "'$1' 特性的实参不是一个字符串"
  },
  {
    "id": "%+qD declared %qs after being used",
    "pattern": "'(.+?)' declared '(.+?)' after being used",
    "replacement": "'$1' 在其使用后被声明为 '$2'"
  },
  {
    "id": "%qE attribute argument cannot be a string",
    "pattern": "'(.+?)' attribute argument cannot be a string",
    "replacement": "'$1' 特性的实参不能是字符串"
  },
  {
    "id": "%qE attribute argument cannot be a constant arithmetic expression",
    "pattern": "'(.+?)' attribute argument cannot be a constant arithmetic expression",
    "replacement": "'$1' 特性的实参不能是常量算术表达式"
  },
  {
    "id": "%qE attribute ignored on a redeclaration of the referenced symbol",
    "pattern": "'(.+?)' attribute ignored on a redeclaration of the referenced symbol",
    "replacement": "'$1' 特性忽略其所使用的符号的重声明"
  },
  {
    "id": "%qE attribute ignored on a declaration of a different kind than referenced symbol",
    "pattern": "'(.+?)' attribute ignored on a declaration of a different kind than referenced symbol",
    "replacement": "'$1' 特性忽略其所使用的符号的不同类别的声明"
  },
  {
    "id": "symbol %qD referenced by %qD declared here",
    "pattern": "symbol '(.+?)' referenced by '(.+?)' declared here",
    "replacement": "由 '$2' 使用的符号 '$1' 于此声明"
  },
  {
    "id": "%qE attribute must apply to a declaration",
    "pattern": "'(.+?)' attribute must apply to a declaration",
    "replacement": "'$1' 特性必须应用于声明"
  },
  {
    "id": "indirect function %q+D cannot be declared %qE",
    "pattern": "indirect function '(.+?)' cannot be declared '(.+?)'",
    "replacement": "非直接函数 '$1' 不能声明为 '$2'"
  },
  {
    "id": "%qE attribute must appear before %qs attribute",
    "pattern": "'(.+?)' attribute must appear before '(.+?)' attribute",
    "replacement": "'$1' 特性必须出现在 '$2' 特性前"
  },
  {
    "id": "%qE attribute ignored on non-class types",
    "pattern": "'(.+?)' attribute ignored on non-class types",
    "replacement": "'$1' 特性在非类类型上被忽略"
  },
  {
    "id": "%qE attribute ignored because %qT is already defined",
    "pattern": "'(.+?)' attribute ignored because '(.+?)' is already defined",
    "replacement": "'$1' 特性被忽略，因为 '$2' 已被定义"
  },
  {
    "id": "visibility argument not a string",
    "pattern": "visibility argument not a string",
    "replacement": "visibility 的实参不是一个字符串"
  },
  {
    "id": "%qE attribute ignored on types",
    "pattern": "'(.+?)' attribute ignored on types",
    "replacement": "'$1' 特性在类型上被忽略"
  },
  {
    "id": "attribute %qE argument must be one of %qs, %qs, %qs, or %qs",
    "pattern": "attribute '(.+?)' argument must be one of '(.+?)', '(.+?)', '(.+?)', or '(.+?)'",
    "replacement": "'$1' 特性的实参必须为 '$2'、'$3'、'$4' 或 '$5' 中的一个"
  },
  {
    "id": "%qD redeclared with different visibility",
    "pattern": "'(.+?)' redeclared with different visibility",
    "replacement": "'$1' 以不同的可见性重声明"
  },
  {
    "id": "%qD was declared %qs which implies default visibility",
    "pattern": "'(.+?)' was declared '(.+?)' which implies default visibility",
    "replacement": "'$1' 声明为默认可见性 '$2'"
  },
  {
    "id": "%qE attribute ignored because %qD is not a variable",
    "pattern": "'(.+?)' attribute ignored because '(.+?)' is not a variable",
    "replacement": "'$1' 特性被忽略，因为 '$2' 不是变量"
  },
  {
    "id": "%qE attribute ignored because %qD does not have thread storage duration",
    "pattern": "'(.+?)' attribute ignored because '(.+?)' does not have thread storage duration",
    "replacement": "'$1' 特性被忽略，因为 '$2' 不具有线程存储期"
  },
  {
    "id": "%qE argument must be one of %qs, %qs, %qs, or %qs",
    "pattern": "'(.+?)' argument must be one of '(.+?)', '(.+?)', '(.+?)', or '(.+?)'",
    "replacement": "'$1' 的实参必须为 '$2'、'$3'、'$4' 或 '$5' 中的一个"
  },
  {
    "id": "%qE attribute applies only to functions",
    "pattern": "'(.+?)' attribute applies only to functions",
    "replacement": "'$1' 特性只能应用于函数"
  },
  {
    "id": "%<%E (%E)%> attribute ignored on functions declared %qs",
    "pattern": "'(.+?) \\((.+?)\\)' attribute ignored on functions declared '(.+?)'",
    "replacement": "'$1 ($2)' 特性在声明为 '$3' 的函数上被忽略"
  },
  {
    "id": "%<%E (%E)%> attribute ignored with deallocation functions declared %qs",
    "pattern": "'(.+?) \\((.+?)\\)' attribute ignored with deallocation functions declared '(.+?)'",
    "replacement": "'$1 ($2)' 特性在声明为 '$3' 的释放函数上被忽略"
  },
  {
    "id": "deallocation function declared here",
    "pattern": "deallocation function declared here",
    "replacement": "释放函数于此声明"
  },
  {
    "id": "%qE attribute ignored; valid only for functions",
    "pattern": "'(.+?)' attribute ignored; valid only for functions",
    "replacement": "'$1' 特性被忽略，因其只在函数上有效"
  },
  {
    "id": "%qE attribute ignored on functions returning %qT; valid only for pointer return types",
    "pattern": "'(.+?)' attribute ignored on functions returning '(.+?)'; valid only for pointer return types",
    "replacement": "'$1' 特性在返回 '$2' 的函数上忽略；仅返回类型为指针时有效"
  },
  {
    "id": "%qE attribute argument 1 is ambiguous",
    "pattern": "'(.+?)' attribute argument 1 is ambiguous",
    "replacement": "'$1' 特性的第 1 个实参是有歧义的"
  },
  {
    "id": "use a cast to the expected type to disambiguate",
    "pattern": "use a cast to the expected type to disambiguate",
    "replacement": "使用类型转换到期望类型来消除歧义"
  },
  {
    "id": "%qE attribute argument 1 does not name a function",
    "pattern": "'(.+?)' attribute argument 1 does not name a function",
    "replacement": "'$1' 特性的第 1 个实参不一个函数名"
  },
  {
    "id": "argument references a symbol declared here",
    "pattern": "argument references a symbol declared here",
    "replacement": "实参使用了此处声明的符号"
  },
  {
    "id": "%qE attribute argument 1 must take a pointer type as its first argument",
    "pattern": "'(.+?)' attribute argument 1 must take a pointer type as its first argument",
    "replacement": "'$1' 特性的第 1 个实参必须采取指向其首个实参的指针类型"
  },
  {
    "id": "referenced symbol declared here",
    "pattern": "referenced symbol declared here",
    "replacement": "使用的符号在此声明"
  },
  {
    "id": "%qE attribute argument 1 must take a pointer type as its first argument; have %qT",
    "pattern": "'(.+?)' attribute argument 1 must take a pointer type as its first argument; have '(.+?)'",
    "replacement": "'$1' 特性的第 1 个实参必须采取指向其首个实参的指针类型；现为 '$2'"
  },
  {
    "id": "%qE attribute ignored on a function returning %qT",
    "pattern": "'(.+?)' attribute ignored on a function returning '(.+?)'",
    "replacement": "'$1' 特性被返回 '$2' 的函数忽略"
  },
  {
    "id": "%qE attribute argument %E is not an integer constant",
    "pattern": "'(.+?)' attribute argument (.+?) is not an integer constant",
    "replacement": "'$1' 特性的第 $2 个实参不是整数常量"
  },
  {
    "id": "%qE attribute argument %E is not positive",
    "pattern": "'(.+?)' attribute argument (.+?) is not positive",
    "replacement": "'$1' 特性的第 $2 个实参不是正数"
  },
  {
    "id": "%qE attribute argument %E is not a power of 2",
    "pattern": "'(.+?)' attribute argument (.+?) is not a power of 2",
    "replacement": "'$1' 特性的第 $2 个实参不是 2 的幂"
  },
  {
    "id": "%qE attribute argument %E is not in the range [0, %wu]",
    "pattern": "'(.+?)' attribute argument (.+?) is not in the range \\[0, (.*?)\\]",
    "replacement": "'$1' 特性的第 $2 个实参不在范围 [0, $3] 内"
  },
  {
    "id": "only %<inbranch%> and %<notinbranch%> flags are allowed for %<__simd__%> attribute",
    "pattern": "only 'inbranch' and 'notinbranch' flags are allowed for '__simd__' attribute",
    "replacement": "'__simd__' 特性只允许 'inbranch' 和 'notinbranch' 标记"
  },
  {
    "id": "cannot set %qE attribute after definition",
    "pattern": "cannot set '(.+?)' attribute after definition",
    "replacement": "定义之后不能设定 '$1' 特性"
  },
  {
    "id": "%qE attribute duplicated",
    "pattern": "'(.+?)' attribute duplicated",
    "replacement": "'$1' 特性重复"
  },
  {
    "id": "%qE attribute follows %qE",
    "pattern": "'(.+?)' attribute follows '(.+?)'",
    "replacement": "'$1' 特性跟在 '$2' 后面"
  },
  {
    "id": "type was previously declared %qE",
    "pattern": "type was previously declared '(.+?)'",
    "replacement": "类型之前声明为 '$1'"
  },
  {
    "id": "%<transaction_safe_dynamic%> may only be specified for a virtual function",
    "pattern": "'transaction_safe_dynamic' may only be specified for a virtual function",
    "replacement": "'transaction_safe_dynamic' 只能在虚函数上指明"
  },
  {
    "id": "%qE argument not an identifier",
    "pattern": "'(.+?)' argument not an identifier",
    "replacement": "'$1' 实参不是标识符"
  },
  {
    "id": "%qD is not compatible with %qD",
    "pattern": "'(.+?)' is not compatible with '(.+?)'",
    "replacement": "'$1' 与 '$2' 不兼容"
  },
  {
    "id": "%qE argument is not a function",
    "pattern": "'(.+?)' argument is not a function",
    "replacement": "'$1' 的实参不是函数"
  },
  {
    "id": "deprecated message is not a string",
    "pattern": "deprecated message is not a string",
    "replacement": "过时消息不是一个字符串"
  },
  {
    "id": "%qE attribute ignored for %qE",
    "pattern": "'(.+?)' attribute ignored for '(.+?)'",
    "replacement": "'$1' 特性被 '$2' 所忽略"
  },
  {
    "id": "invalid vector type for attribute %qE",
    "pattern": "invalid vector type for attribute '(.+?)'",
    "replacement": "'$1' 特性的向量类型无效"
  },
  {
    "id": "%qE attribute argument value %qE is negative",
    "pattern": "'(.+?)' attribute argument value '(.+?)' is negative",
    "replacement": "'$1' 特性的实参值 '$2' 是负数"
  },
  {
    "id": "%qE attribute argument value %qE exceeds %wu",
    "pattern": "'(.+?)' attribute argument value '(.+?)' exceeds (.*?)",
    "replacement": "'$1' 特性的实参值 '$2' 超过 $3"
  },
  {
    "id": "vector size not an integral multiple of component size",
    "pattern": "vector size not an integral multiple of component size",
    "replacement": "向量大小不是组件大小的整数倍"
  },
  {
    "id": "zero vector size",
    "pattern": "zero vector size",
    "replacement": "向量大小为零"
  },
  {
    "id": "number of components of the vector not a power of two",
    "pattern": "number of components of the vector not a power of two",
    "replacement": "向量中分量数不是 2 的某次方"
  },
  {
    "id": "%qE attribute without arguments on a non-prototype",
    "pattern": "'(.+?)' attribute without arguments on a non-prototype",
    "replacement": "'$1' 特性在非原型中没有实参"
  },
  {
    "id": "%qE attribute ignored on objects of type %qT",
    "pattern": "'(.+?)' attribute ignored on objects of type '(.+?)'",
    "replacement": "'$1' 特性被类型为 '$2 '的对象所忽略"
  },
  {
    "id": "%qE attribute does not apply to functions",
    "pattern": "'(.+?)' attribute does not apply to functions",
    "replacement": "'$1' 特性不能应用于函数"
  },
  {
    "id": "attribute %qs mismatch with mode %qs",
    "pattern": "attribute '(.+?)' mismatch with mode '(.+?)'",
    "replacement": "'$1' 特性与模式 '$2' 不匹配"
  },
  {
    "id": "attribute %qs missing positional argument 2 provided in previous designation by argument %u",
    "pattern": "attribute '(.+?)' missing positional argument 2 provided in previous designation by argument (\\d+)",
    "replacement": "'$1' 特性在之前的第 $2 个实参的委托中丢失第 2 个位置实参"
  },
  {
    "id": "attribute %qs positional argument 2 missing in previous designation",
    "pattern": "attribute '(.+?)' positional argument 2 missing in previous designation",
    "replacement": "'$1' 特性在之前的委托中丢失第 2 个位置实参"
  },
  {
    "id": "attribute %qs positional argument 2 conflicts with previous designation by argument %u",
    "pattern": "attribute '(.+?)' positional argument 2 conflicts with previous designation by argument (\\d+)",
    "replacement": "'$1' 特性的第 2 个位置实参与之前第 $2 个实参的委托冲突"
  },
  {
    "id": "attribute %qs mismatched positional argument values %i and %i",
    "pattern": "attribute '(.+?)' mismatched positional argument values (\\d+) and (\\d+)",
    "replacement": "'$1' 特性的位置实参值 $2 和 $3 不匹配"
  },
  {
    "id": "designating the bound of variable length array argument %u",
    "pattern": "designating the bound of variable length array argument (\\d+)",
    "replacement": "委托变长数组实参 $1 的边界"
  },
  {
    "id": "attribute %qE without arguments on a non-prototype",
    "pattern": "attribute '(.+?)' without arguments on a non-prototype",
    "replacement": "'$1' 特性在非原型中没有实参"
  },
  {
    "id": "attribute %qE invalid mode",
    "pattern": "attribute '(.+?)' invalid mode",
    "replacement": "'$1' 特性的模式无效"
  },
  {
    "id": "attribute %qE mode %qE is not an identifier; expected one of %qs, %qs, %qs, or %qs",
    "pattern": "attribute '(.+?)' mode '(.+?)' is not an identifier; expected one of (.*?), (.*?), (.*?), or (.*?)",
    "replacement": "'$1' 特性的模式 '$2' 不是标识符，期望 $3、$4、$5 或 $6 中的一个"
  },
  {
    "id": "attribute %qE invalid mode %qs; expected one of %qs, %qs, %qs, or %qs",
    "pattern": "attribute '(.+?)' invalid mode (.*?); expected one of (.*?), (.*?), (.*?), or (.*?)",
    "replacement": "'$1' 特性的模式 '$2' 无效，期望 $3、$4、$5 或 $6 中的一个"
  },
  {
    "id": "attribute %qE unexpected %<(%> after mode %qs; expected a positional argument or %<)%>",
    "pattern": "attribute '(.+?)' unexpected '\\(' after mode (.*?); expected a positional argument or '\\)'",
    "replacement": "'$1' 特性的模式 '$2' 出现意外的 '('，期望一个位置实参或 ')'"
  },
  {
    "id": "attribute %<%E(%s)%> missing an argument",
    "pattern": "attribute '(.+?)\\((.*?)\\)' missing an argument",
    "replacement": "'$1 ($2)' 特性丢失实参"
  },
  {
    "id": "attribute %<%E(%s, %E, %E)%> invalid positional argument %i",
    "pattern": "attribute '(.+?)\\((.*?), (.+?), (.+?)\\)' invalid positional argument (\\d+)",
    "replacement": "'$1 ($2, $3, $4)' 特性的第 $5 个位置实参无效"
  },
  {
    "id": "attribute %<%E(%s, %E)%> invalid positional argument %i",
    "pattern": "attribute '(.+?)\\((.*?), (.+?)\\)' invalid positional argument (\\d+)",
    "replacement": "'$1 ($2, $3)' 特性的第 $4 个位置实参无效"
  },
  {
    "id": "attribute %qs positional argument %i invalid value %wi",
    "pattern": "attribute '(.+?)' positional argument (\\d+) invalid value (.*?)",
    "replacement": "'$1' 特性的第 $2 个位置实参值 $3 无效"
  },
  {
    "id": "attribute %qs positional argument %i value %wi exceeds number of function arguments %u",
    "pattern": "attribute '(.+?)' positional argument (\\d+) value (.*?) exceeds number of function arguments (\\d+)",
    "replacement": "'$1' 特性的第 $2 个位置实参值 $3 超过了函数的实参个数 $4"
  },
  {
    "id": "attribute %qs invalid positional argument",
    "pattern": "attribute '(.+?)' invalid positional argument",
    "replacement": "'$1' 特性的位置实参无效"
  },
  {
    "id": "attribute %qs positional argument 1 references non-pointer argument type %qT",
    "pattern": "attribute '(.+?)' positional argument 1 references non-pointer argument type '(.+?)'",
    "replacement": "'$1' 特性的第 1 个位置实参使用了非指针实参类型 '$2'"
  },
  {
    "id": "attribute %qs positional argument 1 references argument of function type %qT",
    "pattern": "attribute '(.+?)' positional argument 1 references argument of function type '(.+?)'",
    "replacement": "'$1' 特性的第 1 个位置实参使用了函数类型 '$2' 的实参"
  },
  {
    "id": "attribute %qs positional argument 1 references %qs-qualified argument type %qT",
    "pattern": "attribute '(.+?)' positional argument 1 references '(.+?)'-qualified argument type '(.+?)'",
    "replacement": "'$1' 特性的第 1 个位置实参使用了 '$2'-限定的实参类型 '$3'"
  },
  {
    "id": "attribute %qs positional argument 2 references non-integer argument type %qT",
    "pattern": "attribute '(.+?)' positional argument 2 references non-integer argument type '(.+?)'",
    "replacement": "'$1' 特性的第 2 个位置实参使用了非整数实参类型 '$2'"
  },
  {
    "id": "cleanup argument not an identifier",
    "pattern": "cleanup argument not an identifier",
    "replacement": "cleanup 实参不是一个标识符"
  },
  {
    "id": "cleanup argument not a function",
    "pattern": "cleanup argument not a function",
    "replacement": "cleanup 实参不是一个函数"
  },
  {
    "id": "%qE attribute requires prototypes with named arguments",
    "pattern": "'(.+?)' attribute requires prototypes with named arguments",
    "replacement": "'$1' 特性需要带具名实参的原型"
  },
  {
    "id": "%qE attribute only applies to variadic functions",
    "pattern": "'(.+?)' attribute only applies to variadic functions",
    "replacement": "'$1' 特性只能应用于带变长实参函数"
  },
  {
    "id": "requested position is not an integer constant",
    "pattern": "requested position is not an integer constant",
    "replacement": "要求的位置不是一个整数常量"
  },
  {
    "id": "requested position is less than zero",
    "pattern": "requested position is less than zero",
    "replacement": "要求的位置小于 0"
  },
  {
    "id": "empty string in attribute %<target%>",
    "pattern": "empty string in attribute 'target'",
    "replacement": "'target' 特性中为空字符串"
  },
  {
    "id": "unrecognized %qE attribute argument %qs",
    "pattern": "unrecognized '(.+?)' attribute argument '(.+?)'",
    "replacement": "'$1' 特性中无法识别的实参 '$2'"
  },
  {
    "id": "%qE attribute on a function not returning a pointer",
    "pattern": "'(.+?)' attribute on a function not returning a pointer",
    "replacement": "'$1' 特性作用于不返回指针的函数上"
  },
  {
    "id": "%qE attribute is only valid on %<struct%> type",
    "pattern": "'(.+?)' attribute is only valid on 'struct' type",
    "replacement": "'$1' 特性只在 'struct' 类型上可用"
  },
  {
    "id": "%qE attribute argument %qE is not an integer constant",
    "pattern": "'(.+?)' attribute argument '(.+?)' is not an integer constant",
    "replacement": "'$1' 特性的实参 '$2' 不是一个整数常量"
  },
  {
    "id": "%qE attribute argument %qE exceeds %u",
    "pattern": "'(.+?)' attribute argument '(.+?)' exceeds (\\d+)",
    "replacement": "'$1' 特性的实参 '$2' 超过 $3"
  },
  {
    "id": "%qE attribute may be put on a typedef only; attribute is ignored",
    "pattern": "'(.+?)' attribute may be put on a typedef only; attribute is ignored",
    "replacement": "'$1' 特性只能在 typedef 上使用；该特性被忽略"
  },
  {
    "id": "%qE attribute is for pointer types only",
    "pattern": "'(.+?)' attribute is for pointer types only",
    "replacement": "'$1' 特性只能在指针类型上使用"
  },
  {
    "id": "%qE is only applicable to Objective-C class interfaces, attribute ignored",
    "pattern": "'(.+?)' is only applicable to Objective-C class interfaces, attribute ignored",
    "replacement": "'$1' 只能应用在 Objective-C 类接口上，特性被忽略"
  },
  {
    "id": "%qE cannot be applied to non-pointer type %qT",
    "pattern": "'(.+?)' cannot be applied to non-pointer type '(.+?)'",
    "replacement": "'$1' 不能应用在非指针类型 '$2' 上"
  },
  {
    "id": "%qE attribute argument %qE is not an integer constant between 0 and 3",
    "pattern": "'(.+?)' attribute argument '(.+?)' is not an integer constant between 0 and 3",
    "replacement": "'$1' 特性实参 '$2' 不是一个介于 0 到 3 之间的整数常量"
  },
  {
    "id": "%qE attribute argument %qE is not recognised",
    "pattern": "'(.+?)' attribute argument '(.+?)' is not recognised",
    "replacement": "'$1' 特性实参 '$2' 不被识别"
  },
  {
    "id": "unknown attribute %qE",
    "pattern": "unknown attribute '(.+?)'",
    "replacement": "未知特性 '$1'"
  },
  {
    "id": "invalid operand type %qT for %qs",
    "pattern": "invalid operand type '(.+?)' for '(.*)'",
    "replacement": "'$2' 的无效操作数类型 '$1'"
  },
  {
    "id": "%qs attribute not supported for %qT in %<__builtin_has_attribute%>",
    "pattern": "'(.*)' attribute not supported for '(.+?)' in '__builtin_has_attribute'",
    "replacement": "'$1' 特性在 '__builtin_has_attribute' 中的 '$2' 不支持"
  },
  {
    "id": "%qs attribute not supported in %<__builtin_has_attribute%>",
    "pattern": "'(.*)' attribute not supported in '__builtin_has_attribute'",
    "replacement": "'$1' 特性在 '__builtin_has_attribute' 中不支持"
  },
  {
    "id": "%qD is not defined outside of function scope",
    "pattern": "'(.+)' is not defined outside of function scope",
    "replacement": "'$1' 在函数作用域外未定义"
  },
  {
    "id": "size of string literal is too large",
    "pattern": "size of string literal is too large",
    "replacement": "字符串字面量的大小太大"
  },
  {
    "id": "string length %qd is greater than the length %qd ISO C%d compilers are required to support",
    "pattern": "string length '(\\d+)' is greater than the length '(\\d+)' ISO C(\\d+) compilers are required to support",
    "replacement": "字符串长度 '$1' 比 '$2' (ISO C$3 被要求支持的最大长度) 还要长"
  },
  {
    "id": "use %<-flax-vector-conversions%> to permit conversions between vectors with differing element types or numbers of subparts",
    "pattern": "use '-flax-vector-conversions' to permit conversions between vectors with differing element types or numbers of subparts",
    "replacement": "使用 -flax-vector-conversions 以允许元素类型或数量不同的向量间的转换"
  },
  {
    "id": "%<__builtin_shuffle%> last argument must be an integer vector",
    "pattern": "'__builtin_shuffle' last argument must be an integer vector",
    "replacement": "'__builtin_shuffle' 的最后一个实参必须是一个整数向量"
  },
  {
    "id": "%<__builtin_shuffle%> arguments must be vectors",
    "pattern": "'__builtin_shuffle' arguments must be vectors",
    "replacement": "'__builtin_shuffle' 的实参必须是向量"
  },
  {
    "id": "%<__builtin_shuffle%> argument vectors must be of the same type",
    "pattern": "'__builtin_shuffle' argument vectors must be of the same type",
    "replacement": "'__builtin_shuffle' 的实参向量必须具有相同类型"
  },
  {
    "id": "%<__builtin_shuffle%> number of elements of the argument vector(s) and the mask vector should be the same",
    "pattern": "'__builtin_shuffle' number of elements of the argument vector(s) and the mask vector should be the same",
    "replacement": "'__builtin_shuffle' 中实参向量元素的个数和掩码向量元素的个数必须一致"
  },
  {
    "id": "%<__builtin_shuffle%> argument vector(s) inner type must have the same size as inner type of the mask",
    "pattern": "'__builtin_shuffle' argument vector(s) inner type must have the same size as inner type of the mask",
    "replacement": "'__builtin_shuffle' 中实参向量的内部类型必须和掩码向量的内部类型大小一致"
  },
  {
    "id": "%<__builtin_convertvector%> first argument must be an integer or floating vector",
    "pattern": "'__builtin_convertvector' first argument must be an integer or floating vector",
    "replacement": "'__builtin_convertvector' 的第一实参必须是整数或浮点数的向量"
  },
  {
    "id": "%<__builtin_convertvector%> second argument must be an integer or floating vector type",
    "pattern": "'__builtin_convertvector' second argument must be an integer or floating vector type",
    "replacement": "'__builtin_convertvector' 的第二实参必须是整数或浮点数向量的类型"
  },
  {
    "id": "%<__builtin_convertvector%> number of elements of the first argument vector and the second argument vector type should be the same",
    "pattern": "'__builtin_convertvector' number of elements of the first argument vector and the second argument vector type should be the same",
    "replacement": "'__builtin_convertvector' 中第一实参向量的元素个数类型和第二实参向量的必须一致"
  },
  {
    "id": "operation on %qE may be undefined",
    "pattern": "operation on '(.+?)' may be undefined",
    "replacement": "'$1' 上的运算结果可能是未定义的"
  },
  {
    "id": "case label does not reduce to an integer constant",
    "pattern": "case label does not reduce to an integer constant",
    "replacement": "case 标号不能还原为一个整常量"
  },
  {
    "id": "GCC cannot support operators with integer types and fixed-point types that have too many integral and fractional bits together",
    "pattern": "GCC cannot support operators with integer types and fixed-point types that have too many integral and fractional bits together",
    "replacement": "GCC 不支持整数类型和整数及分数位太多的定点类型间的运算符"
  },
  {
    "id": "invalid operands to binary %s (have %qT and %qT)",
    "pattern": "invalid operands to binary (.*?) \\(have '(.+?)' and '(.+?)'\\)",
    "replacement": "双目运算符 $1 操作数 ('$2'和'$3') 无效"
  },
  {
    "id": "comparison is always false due to limited range of data type",
    "pattern": "comparison is always false due to limited range of data type",
    "replacement": "由于数据类型范围限制，比较结果永远为假"
  },
  {
    "id": "comparison is always true due to limited range of data type",
    "pattern": "comparison is always true due to limited range of data type",
    "replacement": "由于数据类型范围限制，比较结果永远为真"
  },
  {
    "id": "comparison of unsigned expression in %<>= 0%> is always true",
    "pattern": "comparison of unsigned expression in '>= 0' is always true",
    "replacement": "无符号数 '>= 0' 的比较表达式永远为真"
  },
  {
    "id": "comparison of unsigned expression in %<< 0%> is always false",
    "pattern": "comparison of unsigned expression in '< 0' is always false",
    "replacement": "无符号数 '< 0' 的比较表达式永远为假"
  },
  {
    "id": "pointer of type %<void *%> used in arithmetic",
    "pattern": "pointer of type 'void *' used in arithmetic",
    "replacement": "'void *' 类型的指针用在了算术表达式中"
  },
  {
    "id": "pointer to a function used in arithmetic",
    "pattern": "pointer to a function used in arithmetic",
    "replacement": "在算术表达式中使用了函数指针"
  },
  {
    "id": "enum constant in boolean context",
    "pattern": "enum constant in boolean context",
    "replacement": "在布尔语境中使用枚举常量"
  },
  {
    "id": "the address of %qD will always evaluate as %<true%>",
    "pattern": "the address of '(.+?)' will always evaluate as 'true'",
    "replacement": "对 '$1' 的地址的求值总是为 'true'"
  },
  {
    "id": "%<*%> in boolean context, suggest %<&&%> instead",
    "pattern": "'*' in boolean context, suggest '&&' instead",
    "replacement": "在布尔语境中使用 '*'，建议用 '&&' 代替"
  },
  {
    "id": "%<<<%> in boolean context, did you mean %<<%>?",
    "pattern": "'<<' in boolean context, did you mean '<'\\?",
    "replacement": "在布尔语境中使用 '<<'，你的意思是 '<' 吗？"
  },
  {
    "id": "%<?:%> using integer constants in boolean context, the expression will always evaluate to %<true%>",
    "pattern": "'\\?:' using integer constants in boolean context, the expression will always evaluate to 'true'",
    "replacement": "在布尔语境中 '?:' 使用整数常量，此表达式总是求值为 'true'"
  },
  {
    "id": "%<?:%> using integer constants in boolean context",
    "pattern": "'\\?:' using integer constants in boolean context",
    "replacement": "在布尔语境中 '?:' 使用整数常量"
  },
  {
    "id": "the compiler can assume that the address of %qD will always evaluate to %<true%>",
    "pattern": "the compiler can assume that the address of '(.+?)' will always evaluate to 'true'",
    "replacement": "编译器可以假设对 '$1' 的求值总是为 'true'"
  },
  {
    "id": "suggest parentheses around assignment used as truth value",
    "pattern": "suggest parentheses around assignment used as truth value",
    "replacement": "建议在用作真值的赋值表达式前后加上括号"
  },
  {
    "id": "invalid use of %<restrict%>",
    "pattern": "invalid use of 'restrict'",
    "replacement": "非法地使用了'restrict'"
  },
  {
    "id": "invalid application of %<sizeof%> to a function type",
    "pattern": "invalid application of 'sizeof' to a function type",
    "replacement": "非法地将 'sizeof' 应用于函数类型"
  },
  {
    "id": "ISO C++ does not permit %<alignof%> applied to a function type",
    "pattern": "ISO C\\+\\+ does not permit 'alignof' applied to a function type",
    "replacement": "ISO C++ 不允许将 'alignof' 应用于函数类型"
  },
  {
    "id": "ISO C does not permit %<_Alignof%> applied to a function type",
    "pattern": "ISO C does not permit '_Alignof' applied to a function type",
    "replacement": "ISO C 不允许将 '_Alignof' 应用于函数类型"
  },
  {
    "id": "invalid application of %qs to a void type",
    "pattern": "invalid application of '(.+?)' to a void type",
    "replacement": "非法地将 '$1' 应用于 void 类型"
  },
  {
    "id": "invalid application of %qs to incomplete type %qT",
    "pattern": "invalid application of '(.+?)' to incomplete type '(.+?)'",
    "replacement": "非法地将 '$1' 应用于不完整类型 '$2'"
  },
  {
    "id": "invalid application of %qs to array type %qT of incomplete element type",
    "pattern": "invalid application of '(.+?)' to array type '(.+?)' of incomplete element type",
    "replacement": "非法地将 '$1' 应用于数组类型 '$2'，其元素为不完整类型"
  },
  {
    "id": "%<__alignof%> applied to a bit-field",
    "pattern": "'__alignof' applied to a bit-field",
    "replacement": "将 '__alignof' 用于位段"
  },
  {
    "id": "first argument to %<va_arg%> not of type %<va_list%>",
    "pattern": "first argument to 'va_arg' not of type 'va_list'",
    "replacement": "给 'va_arg' 的第一个实参的类型不是 'va_list'"
  },
  {
    "id": "cannot disable built-in function %qs",
    "pattern": "cannot disable built-in function '(.+?)'",
    "replacement": "无法禁用内建函数 '$1'"
  },
  {
    "id": "pointers are not permitted as case values",
    "pattern": "pointers are not permitted as case values",
    "replacement": "指针不能用作 case 值"
  },
  {
    "id": "range expressions in switch statements are non-standard",
    "pattern": "range expressions in switch statements are non-standard",
    "replacement": "在 switch 语句中使用范围表达式不符合标准"
  },
  {
    "id": "empty range specified",
    "pattern": "empty range specified",
    "replacement": "指定范围为空"
  },
  {
    "id": "duplicate (or overlapping) case value",
    "pattern": "duplicate (or overlapping) case value",
    "replacement": "重复 (或重叠) 的 case 值"
  },
  {
    "id": "this is the first entry overlapping that value",
    "pattern": "this is the first entry overlapping that value",
    "replacement": "这是重叠此值的第一个条目"
  },
  {
    "id": "duplicate case value",
    "pattern": "duplicate case value",
    "replacement": "重复的 case 值"
  },
  {
    "id": "previously used here",
    "pattern": "previously used here",
    "replacement": "已在这里使用过"
  },
  {
    "id": "multiple default labels in one switch",
    "pattern": "multiple default labels in one switch",
    "replacement": "单个 switch 语句中出现了多个 default 标号"
  },
  {
    "id": "this is the first default label",
    "pattern": "this is the first default label",
    "replacement": "这是第一个 default 标号"
  },
  {
    "id": "taking the address of a label is non-standard",
    "pattern": "taking the address of a label is non-standard",
    "replacement": "取标号地址的操作不符合标准"
  },
  {
    "id": "requested alignment is not an integer constant",
    "pattern": "requested alignment is not an integer constant",
    "replacement": "要求的对齐不是一个整数常量"
  },
  {
    "id": "requested alignment %qE is not a positive power of 2",
    "pattern": "requested alignment '(.+?)' is not a positive power of 2",
    "replacement": "要求的对齐 '$1' 不是 2 的正数次幂"
  },
  {
    "id": "requested alignment %qE exceeds object file maximum %u",
    "pattern": "requested alignment '(.+?)' exceeds object file maximum (\\d+)",
    "replacement": "要求的对齐 '$1' 超过了对象文件的最大值 $2"
  },
  {
    "id": "requested alignment %qE exceeds maximum %u",
    "pattern": "requested alignment '(.+?)' exceeds maximum (\\d+)",
    "replacement": "要求的对齐 '$1' 超过了最大值 $2"
  },
  {
    "id": "not enough variable arguments to fit a sentinel",
    "pattern": "not enough variable arguments to fit a sentinel",
    "replacement": "变量实参太少，不足以填满一个哨兵"
  },
  {
    "id": "missing sentinel in function call",
    "pattern": "missing sentinel in function call",
    "replacement": "函数调用中缺少哨兵"
  },
  {
    "id": "bad option %qs to attribute %<optimize%>",
    "pattern": "bad option '(.+?)' to attribute 'optimize'",
    "replacement": "'optimize' 特性的选项 '$1' 无效"
  },
  {
    "id": "bad option %qs to pragma %<optimize%>",
    "pattern": "bad option '(.+?)' to pragma 'optimize'",
    "replacement": "pragma 'optimize' 的选项 '$1' 无效"
  },
  {
    "id": "attribute %<fallthrough%> specified multiple times",
    "pattern": "attribute 'fallthrough' specified multiple times",
    "replacement": "'fallthrough' 特性被多次指定"
  },
  {
    "id": "%<fallthrough%> attribute specified with a parameter",
    "pattern": "'fallthrough' attribute specified with a parameter",
    "replacement": "'fallthrough' 特性需指定一个形参"
  },
  {
    "id": "too few arguments to function %qE",
    "pattern": "too few arguments to function '(.+?)'",
    "replacement": "提供给函数 '$1' 的实参太少"
  },
  {
    "id": "third argument to function %qE must be a constant integer",
    "pattern": "third argument to function '(.+?)' must be a constant integer",
    "replacement": "函数 '$1' 的第三个实参必须为整数常量"
  },
  {
    "id": "second argument to function %qE must be a constant integer power of 2 between %qi and %qu bits",
    "pattern": "second argument to function '(.+?)' must be a constant integer power of 2 between (\\d+) and (\\d+) bits",
    "replacement": "函数 '$1' 的第二个实参必须为介于 $2 和 $3 比特之间的 2 的整数常量次幂"
  },
  {
    "id": "non-floating-point argument in call to function %qE",
    "pattern": "non-floating-point argument in call to function '(.+?)'",
    "replacement": "调用函数 '$1' 的实参不是浮点数"
  },
  {
    "id": "non-const integer argument %u in call to function %qE",
    "pattern": "non-const integer argument (\\d+) in call to function '(.+?)'",
    "replacement": "调用函数 '$2' 的第 $1 个实参是非只读的整数"
  },
  {
    "id": "non-integer argument 3 in call to function %qE",
    "pattern": "non-integer argument 3 in call to function '(.+?)'",
    "replacement": "调用函数 '$1' 的第 3 个实参不是整数"
  },
  {
    "id": "argument %u in call to function %qE does not have integral type",
    "pattern": "argument (\\d+) in call to function '(.+?)' does not have integral type",
    "replacement": "调用函数 '$2' 的第 $1 个实参不具有整数类型"
  },
  {
    "id": "argument 3 in call to function %qE does not have pointer to integral type",
    "pattern": "argument 3 in call to function '(.+?)' does not have pointer to integral type",
    "replacement": "调用函数 '$1' 的第 3 个实参不具有指向整数类型的指针"
  },
  {
    "id": "argument 3 in call to function %qE has pointer to enumerated type",
    "pattern": "argument 3 in call to function '(.+?)' has pointer to enumerated type",
    "replacement": "调用函数 '$1' 的第 3 个实参具有指向枚举类型的指针"
  },
  {
    "id": "argument 3 in call to function %qE has pointer to boolean type",
    "pattern": "argument 3 in call to function '(.+?)' has pointer to boolean type",
    "replacement": "调用函数 '$1' 的第 3 个实参具有指向布尔类型的指针"
  },
  {
    "id": "argument %u in call to function %qE has pointer to %qs type (%qT)",
    "pattern": "argument (\\d+) in call to function '(.+?)' has pointer to '(.+?)' type \\('(.+?)'\\)",
    "replacement": "调用函数 '$2' 的第 $1 个实参具有指向 '$3' 类型的指针（'$4'）"
  },
  {
    "id": "argument 3 in call to function %qE has enumerated type",
    "pattern": "argument 3 in call to function '(.+?)' has enumerated type",
    "replacement": "调用函数 '$1' 的第 3 个实参具有枚举类型"
  },
  {
    "id": "argument 3 in call to function %qE has boolean type",
    "pattern": "argument 3 in call to function '(.+?)' has boolean type",
    "replacement": "调用函数 '$1' 的第 3 个实参具有布尔类型"
  },
  {
    "id": "argument %u in call to function %qE does not have pointer type",
    "pattern": "argument (\\d+) in call to function '(.+?)' does not have pointer type",
    "replacement": "调用函数 '$2' 的第 $1 个实参不具有指针类型"
  },
  {
    "id": "argument %u in call to function %qE points to incomplete type",
    "pattern": "argument (\\d+) in call to function '(.+?)' points to incomplete type",
    "replacement": "调用函数 '$2' 的第 $1 个实参指向不完整类型"
  },
  {
    "id": "cannot apply %<offsetof%> to static data member %qD",
    "pattern": "cannot apply 'offsetof' to static data member '(.+?)'",
    "replacement": "不能对静态数据成员 $1 应用 'offsetof'"
  },
  {
    "id": "cannot apply %<offsetof%> when %<operator[]%> is overloaded",
    "pattern": "cannot apply 'offsetof' when 'operator\\[\\]' is overloaded",
    "replacement": "'operator[]' 被重载时不能应用 'offsetof'"
  },
  {
    "id": "cannot apply %<offsetof%> to a non constant address",
    "pattern": "cannot apply 'offsetof' to a non constant address",
    "replacement": "不能为非常量地址应用 'offsetof'"
  },
  {
    "id": "attempt to take address of bit-field structure member %qD",
    "pattern": "attempt to take address of bit-field structure member '(.+?)'",
    "replacement": "试图取位域结构成员 '$1' 的地址"
  },
  {
    "id": "index %E denotes an offset greater than size of %qT",
    "pattern": "index (.+?) denotes an offset greater than size of '(.+?)'",
    "replacement": "索引 $1 指定了一个大于 '$2' 大小的偏移量"
  },
  {
    "id": "size of array is too large",
    "pattern": "size of array is too large",
    "replacement": "数组的大小太大"
  },
  {
    "id": "operand type %qT is incompatible with argument %d of %qE",
    "pattern": "operand type '(.+?)' is incompatible with argument (\\d+) of '(.+?)'",
    "replacement": "操作数类型 '$1' 与 '$3' 的第 $2 个实参不兼容"
  },
  {
    "id": "expecting argument of type pointer or of type integer for argument 1",
    "pattern": "expecting argument of type pointer or of type integer for argument 1",
    "replacement": "第一个实参期待整数类型或指针类型"
  },
  {
    "id": "both arguments must be compatible",
    "pattern": "both arguments must be compatible",
    "replacement": "所有的实参必须兼容"
  },
  {
    "id": "incorrect number of arguments to function %qE",
    "pattern": "incorrect number of arguments to function '(.+?)'",
    "replacement": "提供给函数 '$1' 的实参个数不正确"
  },
  {
    "id": "argument 1 of %qE must be a non-void pointer type",
    "pattern": "argument 1 of '(.+?)' must be a non-void pointer type",
    "replacement": "'$1' 的第 1 个实参必须是指向非 void 类型的指针"
  },
  {
    "id": "argument 1 of %qE must be a pointer to a complete type",
    "pattern": "argument 1 of '(.+?)' must be a pointer to a complete type",
    "replacement": "'$1' 的第 1 个实参必须是指向完整类型的指针"
  },
  {
    "id": "argument 1 of %qE must be a pointer to a constant size type",
    "pattern": "argument 1 of '(.+?)' must be a pointer to a constant size type",
    "replacement": "'$1' 的第 1 个实参必须是指向常量大小类型的指针"
  },
  {
    "id": "argument 1 of %qE must be a pointer to a nonzero size object",
    "pattern": "argument 1 of '(.+?)' must be a pointer to a nonzero size object",
    "replacement": "'$1' 的第 1 个实参必须是指向非零大小对象的指针"
  },
  {
    "id": "argument %d of %qE must be a pointer type",
    "pattern": "argument (\\d+) of '(.+?)' must be a pointer type",
    "replacement": "'$2' 的第 $1 个实参必须是指针类型"
  },
  {
    "id": "argument %d of %qE must be a pointer to a constant size type",
    "pattern": "argument (\\d+) of '(.+?)' must be a pointer to a constant size type",
    "replacement": "'$2' 的第 $1 个实参必须是指向常量大小类型的指针"
  },
  {
    "id": "argument %d of %qE must not be a pointer to a function",
    "pattern": "argument (\\d+) of '(.+?)' must not be a pointer to a function",
    "replacement": "'$2' 的第 $1 个实参必须是指向函数的指针"
  },
  {
    "id": "size mismatch in argument %d of %qE",
    "pattern": "size mismatch in argument (\\d+) of '(.+?)'",
    "replacement": "'$2' 的第 $1 个实参大小不匹配"
  },
  {
    "id": "argument %d of %qE must not be a pointer to a %<const%> type",
    "pattern": "argument (\\d+) of '(.+?)' must not be a pointer to a 'const' type",
    "replacement": "'$2' 的第 $1 个实参不能是指向 'const' 类型的指针"
  },
  {
    "id": "argument %d of %qE discards %<const%> qualifier",
    "pattern": "argument (\\d+) of '(.+?)' discards 'const' qualifier",
    "replacement": "'$2' 第 $1 个实参丢弃了 'const' 限定符"
  },
  {
    "id": "argument %d of %qE must not be a pointer to a %<volatile%> type",
    "pattern": "argument (\\d+) of '(.+?)' must not be a pointer to a 'volatile' type",
    "replacement": "'$2' 的第 $1 个实参不能是指向 'volatile' 类型的指针"
  },
  {
    "id": "argument %d of %qE discards %<volatile%> qualifier",
    "pattern": "argument (\\d+) of '(.+?)' discards 'volatile' qualifier",
    "replacement": "'$2' 第 $1 个实参丢弃了 'volatile' 限定符"
  },
  {
    "id": "non-integer memory model argument %d of %qE",
    "pattern": "non-integer memory model argument (\\d+) of '(.+?)'",
    "replacement": "'$2' 的第 $1 个实参是非整数内存模型"
  },
  {
    "id": "invalid memory model argument %d of %qE",
    "pattern": "invalid memory model argument (\\d+) of '(.+?)'",
    "replacement": "'$2' 的第 $1 个实参是无效内存模型"
  },
  {
    "id": "this target does not define a speculation barrier; your program will still execute correctly, but incorrect speculation may not be restricted",
    "pattern": "this target does not define a speculation barrier; your program will still execute correctly, but incorrect speculation may not be restricted",
    "replacement": "该目标没有定义一个推测屏障；你的程序仍然会正确执行，但不正确的推测可能不会受到限制。"
  },
  {
    "id": "index value is out of bound",
    "pattern": "index value is out of bound",
    "replacement": "索引值越界"
  },
  {
    "id": "conversion of scalar %qT to vector %qT involves truncation",
    "pattern": "conversion of scalar '(.+?)' to vector '(.+?)' involves truncation",
    "replacement": "从标量 '(.+?)' 到向量 '(.+?)' 的转换引入截断"
  },
  {
    "id": "built-in function %qE must be directly called",
    "pattern": "built-in function '(.+?)' must be directly called",
    "replacement": "内建函数 '$1' 必须被直接调用"
  },
  {
    "id": "size of array %qE is not a constant expression",
    "pattern": "size of array '(.+?)' is not a constant expression",
    "replacement": "数组 '$1' 的大小不是常量表达式"
  },
  {
    "id": "size of array is not a constant expression",
    "pattern": "size of array is not a constant expression",
    "replacement": "数组的大小不是常量表达式"
  },
  {
    "id": "size %qE of array %qE is negative",
    "pattern": "size '(.+?)' of array '(.+?)' is negative",
    "replacement": "数组 '$2' 的大小 '$1' 为负数"
  },
  {
    "id": "size %qE of array is negative",
    "pattern": "size '(.+?)' of array is negative",
    "replacement": "数组的大小 '$1' 为负数"
  },
  {
    "id": "size %qE of array %qE exceeds maximum object size %qE",
    "pattern": "size '(.+?)' of array '(.+?)' exceeds maximum object size '(.+?)'",
    "replacement": "数组 '$2' 的大小 '$1' 超过对象大小的最大值 '$3'"
  },
  {
    "id": "size %qE of array exceeds maximum object size %qE",
    "pattern": "size '(.+?)' of array exceeds maximum object size '(.+?)'",
    "replacement": "数组的大小 '$1' 超过对象大小的最大值 '$2'"
  },
  {
    "id": "size of array %qE exceeds maximum object size %qE",
    "pattern": "size of array '(.+?)' exceeds maximum object size '(.+?)'",
    "replacement": "数组 '$1' 的大小超过对象大小的最大值 '$2'"
  },
  {
    "id": "size of array exceeds maximum object size %qE",
    "pattern": "size of array exceeds maximum object size '(.+?)'",
    "replacement": "数组的大小超过对象大小的最大值 '$1'"
  },
  {
    "id": "environment variable %qs must expand to a non-negative integer less than or equal to %wd",
    "pattern": "environment variable '(.+?)' must expand to a non-negative integer less than or equal to (.+?)",
    "replacement": "环境变量 '$1' 必须展开为小于等于 $2 的非负整数"
  },
  {
    "id": "function does not return string type",
    "pattern": "function does not return string type",
    "replacement": "函数不返回字符串类型"
  },
  {
    "id": "format string argument is not a string type",
    "pattern": "format string argument is not a string type",
    "replacement": "格式字符串实参不是字符串类型"
  },
  {
    "id": "found a %qs reference but the format argument should be a string",
    "pattern": "found a '(.+?)' reference but the format argument should be a string",
    "replacement": "发现 '$1' 引用但是格式实参应为字符串"
  },
  {
    "id": "found a %qT but the format argument should be a string",
    "pattern": "found a '(.+?)' but the format argument should be a string",
    "replacement": "发现 '$1' 但是格式实参应为字符串"
  },
  {
    "id": "format argument should be a %qs reference but a string was found",
    "pattern": "format argument should be a '(.+?)' reference but a string was found",
    "replacement": "格式实参应为 '$1' 引用但是发现一个字符串"
  },
  {
    "id": "format argument should be a %qs reference",
    "pattern": "format argument should be a '(.+?)' reference",
    "replacement": "格式实参应为 '$1' 引用"
  },
  {
    "id": "unrecognized format specifier",
    "pattern": "unrecognized format specifier",
    "replacement": "无法识别的格式限定符"
  },
  {
    "id": "%qE is only allowed in Objective-C dialects",
    "pattern": "'(.+?)' is only allowed in Objective-C dialects",
    "replacement": "'$1'不是一个 Objective-C 类名或别名"
  },
  {
    "id": "%qE is an unrecognized format function type",
    "pattern": "'(.+?)' is an unrecognized format function type",
    "replacement": "'$1' 是一个无法识别的格式函数类型"
  },
  {
    "id": "format string argument follows the arguments to be formatted",
    "pattern": "format string argument follows the arguments to be formatted",
    "replacement": "格式字符串实参跟随在待格式化的实参之后"
  },
  {
    "id": "function %qD might be a candidate for %qs format attribute",
    "pattern": "function '(.+?)' might be a candidate for '(.+?)' format attribute",
    "replacement": "函数 '$1' 可能是 '$2' 格式化特性的备选"
  },
  {
    "id": "missing $ operand number in format",
    "pattern": "missing \\$ operand number in format",
    "replacement": "格式字符串缺少 $ 操作数号"
  },
  {
    "id": "%s does not support %%n$ operand number formats",
    "pattern": "(.*?) does not support %n\\$ operand number formats",
    "replacement": "$1 不支持 %n$ 操作数号格式字符串"
  },
  {
    "id": "operand number out of range in format",
    "pattern": "operand number out of range in format",
    "replacement": "格式字符串中操作数号越界"
  },
  {
    "id": "format argument %d used more than once in %s format",
    "pattern": "format argument (\\d+) used more than once in (.*?) format",
    "replacement": "第 $1 个格式实参在 $2 格式字符串中使用不止一次"
  },
  {
    "id": "%<$%>operand number used after format without operand number",
    "pattern": "'\\$' operand number used after format without operand number",
    "replacement": "'$' 操作数号在不使用操作数号的格式后被使用"
  },
  {
    "id": "format argument %d unused before used argument %d in %<$%>-style format",
    "pattern": "format argument (\\d+) unused before used argument (\\d+) in '\\$'-style format",
    "replacement": "第 $1 个格式实参在使用 $ 风格的第 $2 个格式实参前未被使用"
  },
  {
    "id": "format not a string literal, format string not checked",
    "pattern": "format not a string literal, format string not checked",
    "replacement": "格式字符串不是一个字符串字面量，格式字符串未被检查"
  },
  {
    "id": "format not a string literal and no format arguments",
    "pattern": "format not a string literal and no format arguments",
    "replacement": "格式字符串不是一个字面字符串而且没有待格式化的实参"
  },
  {
    "id": "format not a string literal, argument types not checked",
    "pattern": "format not a string literal, argument types not checked",
    "replacement": "格式字符串不是一个字面字符串，没有进行实参类型检查"
  },
  {
    "id": "too many arguments for format",
    "pattern": "too many arguments for format",
    "replacement": "提供给格式字符串的实参太多"
  },
  {
    "id": "unused arguments in %<$%>-style format",
    "pattern": "unused arguments in '\\$'-style format",
    "replacement": "$ 风格的格式字符串中有未使用的实参"
  },
  {
    "id": "zero-length %s format string",
    "pattern": "zero-length (.*?) format string",
    "replacement": "格式字符串 $1 长度为零"
  },
  {
    "id": "format is a wide character string",
    "pattern": "format is a wide character string",
    "replacement": "格式字符串是一个宽字符串"
  },
  {
    "id": "format string is not an array of type %qs",
    "pattern": "format string is not an array of type '(.+?)'",
    "replacement": "格式字符串不是 '$1' 类型构成的数组"
  },
  {
    "id": "unterminated format string",
    "pattern": "unterminated format string",
    "replacement": "未终止的格式字符串"
  },
  {
    "id": "%s used with %<%%%c%> %s format",
    "pattern": "(.*?) used with '%(.)' (.*?) format",
    "replacement": "$1 与 '%$2' $3 格式并用"
  },
  {
    "id": "%s does not support %s",
    "pattern": "(.*?) does not support (.*?)",
    "replacement": "$1 不支持 $2"
  },
  {
    "id": "%s does not support %s with the %<%%%c%> %s format",
    "pattern": "(.*?) does not support (.*?) with the '%%(.)' (.*?) format",
    "replacement": "$1 不支持 $2 出现在 '%$3' $4 格式字符串中"
  },
  {
    "id": "%s used within a quoted sequence",
    "pattern": "(.*?) used within a quoted sequence",
    "replacement": "$1 在引号围起的序列中使用"
  },
  {
    "id": "%qc conversion used unquoted",
    "pattern": "'(.)' conversion used unquoted",
    "replacement": "'$1' 转换的使用未被引号围起"
  },
  {
    "id": "repeated %s in format",
    "pattern": "repeated (.*?) in format",
    "replacement": "格式字符串中有重复的 $1"
  },
  {
    "id": "missing fill character at end of strfmon format",
    "pattern": "missing fill character at end of strfmon format",
    "replacement": "strfmon 格式字符串末尾缺少填充字符"
  },
  {
    "id": "zero width in %s format",
    "pattern": "zero width in (.*?) format",
    "replacement": "$1 格式字符串中域宽为 0"
  },
  {
    "id": "empty left precision in %s format",
    "pattern": "empty left precision in (.*?) format",
    "replacement": "$1 格式字符串中左精度为空"
  },
  {
    "id": "empty precision in %s format",
    "pattern": "empty precision in (.*?) format",
    "replacement": "$1 格式字符串中精度为空"
  },
  {
    "id": "%s does not support the %qs %s length modifier",
    "pattern": "(.*?) does not support the '(.+?)' (.*?) length modifier",
    "replacement": "$1 不支持 '$2' $3 长度修饰符"
  },
  {
    "id": "unknown conversion type character %qc in format",
    "pattern": "unknown conversion type character '(.)' in format",
    "replacement": "格式字符串中出现无效的类型转换字符 '$1'"
  },
  {
    "id": "%s does not support the %<%%%c%> %s format",
    "pattern": "(.*?) does not support the '%(.)' (.*?) format",
    "replacement": "$1 不支持 '%$2' $3 格式"
  },
  {
    "id": "%s ignored with %s and %<%%%c%> %s format",
    "pattern": "(.*?) ignored with (.*?) and '%(.)' (.*?) format",
    "replacement": "$1 与 $2 和 '%$3' $4 格式字符串合用时被忽略"
  },
  {
    "id": "%s ignored with %s in %s format",
    "pattern": "(.*?) ignored with (.*?) in (.*?) format",
    "replacement": "$1 和 $2 出现在 $3 格式字符串中时被忽略"
  },
  {
    "id": "use of %s and %s together with %<%%%c%> %s format",
    "pattern": "use of (.*?) and (.*?) together with '%(.)' (.*?) format",
    "replacement": "同时使用 $1 和 $2，在 '%$3' $4 格式字符串中"
  },
  {
    "id": "use of %s and %s together in %s format",
    "pattern": "use of (.*?) and (.*?) together in (.*?) format",
    "replacement": "同时使用 $1 和 $2，在 $3 格式字符串中"
  },
  {
    "id": "%<%%%c%> yields only last 2 digits of year in some locales",
    "pattern": "'%(.)' yields only last 2 digits of year in some locales",
    "replacement": "'%$1' 在某些区域设定下只给出 2 位表示的年份"
  },
  {
    "id": "%<%%%c%> yields only last 2 digits of year",
    "pattern": "'%(.)' yields only last 2 digits of year",
    "replacement": "'%$1' 只给出 2 位表示的年份"
  },
  {
    "id": "no closing %<]%> for %<%%[%> format",
    "pattern": "no closing '\\]' for '%\\[' format",
    "replacement": "'%['格式没有相应的']'"
  },
  {
    "id": "use of %qs length modifier with %qc type character has either no effect or undefined behavior",
    "pattern": "use of '(.+?)' length modifier with '(.)' type character has either no effect or undefined behavior",
    "replacement": "将 '$1' 长度修饰符和 '$2' 类型字符一起使用时，要么没有作用，要么导致未定义行为"
  },
  {
    "id": "%s does not support the %<%%%s%c%> %s format",
    "pattern": "(.*?) does not support the '%(.*?)(.)' (.*?) format",
    "replacement": "$1 不支持 '%$2$3' $4 格式"
  },
  {
    "id": "operand number specified with suppressed assignment",
    "pattern": "operand number specified with suppressed assignment",
    "replacement": "为格式字符串指定的操作数号抑制了赋值"
  },
  {
    "id": "operand number specified for format taking no argument",
    "pattern": "operand number specified for format taking no argument",
    "replacement": "为格式字符串指定的操作数号不带实参"
  },
  {
    "id": "unquoted type name %<%.*s%> in format",
    "pattern": "unquoted type name '(.+?)' in format",
    "replacement": "格式中类型名 '$1' 未被引号围起"
  },
  {
    "id": "unquoted operator %<%.*s%> in format",
    "pattern": "unquoted operator '(.+?)' in format",
    "replacement": "格式中运算符 '$1' 未被引号围起"
  },
  {
    "id": "unquoted keyword %<%.*s%> in format",
    "pattern": "unquoted keyword '(.+?)' in format",
    "replacement": "格式中关键字 '$1' 未被引号围起"
  },
  {
    "id": "use %qs instead",
    "pattern": "use '(.+?)' instead",
    "replacement": "使用 '$1' 代替"
  },
  {
    "id": "unquoted attribute in format",
    "pattern": "unquoted attribute in format",
    "replacement": "格式中特性未被引号围起"
  },
  {
    "id": "unquoted name of built-in function %<%.*s%> in format",
    "pattern": "unquoted name of built-in function '(.+?)' in format",
    "replacement": "格式中内建函数名 '$1' 未被引号围起"
  },
  {
    "id": "unquoted identifier or keyword %<%.*s%> in format",
    "pattern": "unquoted identifier or keyword '(.+?)' in format",
    "replacement": "格式中关键字或标识符 '$1' 未被引号围起"
  },
  {
    "id": "misspelled term %<%.*s%> in format; use %<%s%s%> instead",
    "pattern": "misspelled term '(.+?)' in format; use '(.+?)' instead",
    "replacement": "格式中术语 '$1' 拼写错误；使用 '$2' 代替"
  },
  {
    "id": "quoted %qs directive in format; use %qs instead",
    "pattern": "quoted '(.+?)' directive in format; use '(.+?)' instead",
    "replacement": "格式中指令 '$1' 被引号围起；使用 '$2' 代替"
  },
  {
    "id": "contraction %<%.*s%> in format; use %qs instead",
    "pattern": "contraction '(.+?)' in format; use '(.+?)' instead",
    "replacement": "格式中收缩 '$1'；使用 '$2' 代替"
  },
  {
    "id": "unquoted whitespace character %qc in format",
    "pattern": "unquoted whitespace character '(.)' in format",
    "replacement": "格式中出现未被引号围起的空白字符 '$1'"
  },
  {
    "id": "spurious trailing space in format",
    "pattern": "spurious trailing space in format",
    "replacement": "格式结尾有可疑的尾随空格"
  },
  {
    "id": "inconsistent capitalization in format",
    "pattern": "inconsistent capitalization in format",
    "replacement": "格式中不合适的大小写"
  },
  {
    "id": "unquoted sequence of %i consecutive space characters in format",
    "pattern": "unquoted sequence of (\\d+) consecutive space characters in format",
    "replacement": "格式中 $1 个连续空格字符序列未被引号围起"
  },
  {
    "id": "unquoted control characters in format",
    "pattern": "unquoted control characters in format",
    "replacement": "格式中控制字符未被引号引起"
  },
  {
    "id": "unquoted control character %qc in format",
    "pattern": "unquoted control character '(.)' in format",
    "replacement": "格式中控制字符 '$1' 未被引号引起"
  },
  {
    "id": "unquoted option name %<%.*s%> in format",
    "pattern": "unquoted option name '(.+?)' in format",
    "replacement": "格式中选项 '$1' 未被引号引起"
  },
  {
    "id": "unbalanced punctuation character %qc in format",
    "pattern": "unbalanced punctuation character '(.)' in format",
    "replacement": "格式中标点字符 '$1' 不平衡"
  },
  {
    "id": "unquoted preprocessing directive %<%.*s%> in format",
    "pattern": "unquoted preprocessing directive '(.+?)' in format",
    "replacement": "格式中预处理指令 '$1' 未被引号引起"
  },
  {
    "id": "bare apostrophe %<'%> in format",
    "pattern": "bare apostrophe ''' in format",
    "replacement": "格式中出现裸的单引号 '''"
  },
  {
    "id": "if avoiding the apostrophe is not feasible, enclose it in a pair of %qs and %qs directives instead",
    "pattern": "if avoiding the apostrophe is not feasible, enclose it in a pair of '(.+?)' and '(.+?)' directives instead",
    "replacement": "如果不可避免使用单引号，则使用 '$1' 和 '$2' 这一对指令围起来代替"
  },
  {
    "id": "grave accent %<`%> in format",
    "pattern": "grave accent '`' in format",
    "replacement": "格式中出现抑音符号 '`'"
  },
  {
    "id": "use the apostrophe directive %qs instead",
    "pattern": "use the apostrophe directive '(.+?)' instead",
    "replacement": "使用带引号指令 '$1' 来代替"
  },
  {
    "id": "space followed by punctuation character %<%c%>",
    "pattern": "space followed by punctuation character '(.)'",
    "replacement": "标点字符 '$1' 后出现空格"
  },
  {
    "id": "quoted %qs directive in format",
    "pattern": "quoted '(.+?)' directive in format",
    "replacement": "格式中指令 '$1' 被引号围起"
  },
  {
    "id": "if using %qs is not feasible, use %qs instead",
    "pattern": "if using '(.+?)' is not feasible, use '(.+?)' instead",
    "replacement": "如果不能使用 '$1'，则使用 '$2' 来代替"
  },
  {
    "id": "spurious leading punctuation sequence %<%.*s%> in format",
    "pattern": "spurious leading punctuation sequence '(.+?)' in format",
    "replacement": "格式中有可疑的前导标点序列 '$1'"
  },
  {
    "id": "spurious trailing punctuation sequence %<%.*s%> in format",
    "pattern": "spurious trailing punctuation sequence '(.+?)' in format",
    "replacement": "格式中有可疑的尾随标点序列 '$1'"
  },
  {
    "id": "unquoted sequence of %i consecutive punctuation characters %q.*s in format",
    "pattern": "unquoted sequence of (\\d+) consecutive punctuation characters '(.+?)' in format",
    "replacement": "格式中连续 $1 个标点字符 '$2' 未被引号引起"
  },
  {
    "id": "unquoted non-graph characters in format",
    "pattern": "unquoted non-graph characters in format",
    "replacement": "格式中非可见字符未被引号引起"
  },
  {
    "id": "unquoted non-graph character %qc in format",
    "pattern": "unquoted non-graph character '(.)' in format",
    "replacement": "格式中非可见字符 '(.)' 未被引号引起"
  },
  {
    "id": "unbalanced punctuation character %<%c%> in format",
    "pattern": "unbalanced punctuation character '(.)' in format",
    "replacement": "格式中标点字符 '$1' 不平衡"
  },
  {
    "id": "unterminated quoting directive",
    "pattern": "unterminated quoting directive",
    "replacement": "未终止的引号围起的指令"
  },
  {
    "id": "unterminated quote character %<%c%> in format",
    "pattern": "unterminated quote character '(.)' in format",
    "replacement": "格式中未终止的引号围起的字符 '$1'"
  },
  {
    "id": "spurious trailing %<%%%> in format",
    "pattern": "spurious trailing '%' in format",
    "replacement": "格式中有可疑的尾随 '%'"
  },
  {
    "id": "conversion lacks type at end of format",
    "pattern": "conversion lacks type at end of format",
    "replacement": "格式末尾的转换缺少类型"
  },
  {
    "id": "nested quoting directive",
    "pattern": "nested quoting directive",
    "replacement": "嵌套的引号围起的指令"
  },
  {
    "id": "unmatched quoting directive",
    "pattern": "unmatched quoting directive",
    "replacement": "不匹配的引号围起的指令"
  },
  {
    "id": "%qc directive redundant after prior occurence of the same",
    "pattern": "'(.)' directive redundant after prior occurence of the same",
    "replacement": "$1 指令之前已经出现，是多余的"
  },
  {
    "id": "unmatched color reset directive",
    "pattern": "unmatched color reset directive",
    "replacement": "不匹配的颜色重置指令"
  },
  {
    "id": "%qc conversion used within a quoted sequence",
    "pattern": "'(.)' conversion used within a quoted sequence",
    "replacement": "$1 转换被用在引号围起的指令"
  },
  {
    "id": "embedded %<\\\\0%> in format",
    "pattern": "embedded '(.)' in format",
    "replacement": "格式字符串嵌有 '$1'"
  },
  {
    "id": "unterminated color directive",
    "pattern": "unterminated color directive",
    "replacement": "未结束的颜色指令"
  },
  {
    "id": "writing through null pointer (argument %d)",
    "pattern": "writing through null pointer \\(argument (\\d+)\\)",
    "replacement": "对空指针指向内容的写操作（第 $1 个实参）"
  },
  {
    "id": "reading through null pointer (argument %d)",
    "pattern": "reading through null pointer \\(argument (\\d+)\\)",
    "replacement": "对空指针指向内容的读操作（第 $1 个实参）"
  },
  {
    "id": "writing into constant object (argument %d)",
    "pattern": "writing into constant object \\(argument (\\d+)\\)",
    "replacement": "对常量对象的写操作（第 $1 个实参）"
  },
  {
    "id": "extra type qualifiers in format argument (argument %d)",
    "pattern": "extra type qualifiers in format argument \\(argument (\\d+)\\)",
    "replacement": "格式字符串第 $1 个实参有多余的类型限定"
  },
  {
    "id": "%s %<%s%.*s%> expects argument of type %<%s%s%>, but argument %d has type %qT",
    "pattern": "(.+?)' expects argument of type '(.+?)', but argument (\\d+) has type '(.+?)'",
    "replacement": "$1' 期望实参类型 '$2'，但第 $3 个实参的类型为 '$4'"
  },
  {
    "id": "%s %<%s%.*s%> expects a matching %<%s%s%> argument",
    "pattern": "(.+?)' expects a matching '(.+?)' argument",
    "replacement": "$1' 期望一个吻合的 '$2' 实参"
  },
  {
    "id": "%<__gcc_host_wide_int__%> is not defined as a type",
    "pattern": "'__gcc_host_wide_int__' is not defined as a type",
    "replacement": "'__gcc_host_wide_int__' 未被定义为一个类型"
  },
  {
    "id": "%<__gcc_host_wide_int__%> is not defined as %<long%> or %<long long%>",
    "pattern": "'__gcc_host_wide_int__' is not defined as 'long' or 'long long'",
    "replacement": "'__gcc_host_wide_int__' 未被定义为 'long' 或 'long long'"
  },
  {
    "id": "%<locus%> is not defined as a type",
    "pattern": "'locus' is not defined as a type",
    "replacement": "'locus' 未被定义为一个类型"
  },
  {
    "id": "%qs is not defined as a type",
    "pattern": "'(.+?)' is not defined as a type",
    "replacement": "'$1' 未被定义为一个类型"
  },
  {
    "id": "%<location_t%> is not defined as a type",
    "pattern": "'location_t' is not defined as a type",
    "replacement": "'location_t' 未被定义为一个类型"
  },
  {
    "id": "%<tree%> is not defined as a type",
    "pattern": "'tree' is not defined as a type",
    "replacement": "'tree' 未被定义为一个类型"
  },
  {
    "id": "%<tree%> is not defined as a pointer type",
    "pattern": "'tree' is not defined as a pointer type",
    "replacement": "'tree' 未被定义为一个指针类型"
  },
  {
    "id": "argument to be formatted is not %<...%>",
    "pattern": "argument to be formatted is not '\\.\\.\\.'",
    "replacement": "待格式化的实参不是 '...'"
  },
  {
    "id": "strftime formats cannot format arguments",
    "pattern": "strftime formats cannot format arguments",
    "replacement": "strftime 格式字符串无法格式化实参"
  },
  {
    "id": "%<-Wmisleading-indentation%> is disabled from this point onwards, since column-tracking was disabled due to the size of the code/headers",
    "pattern": "'-Wmisleading-indentation' is disabled from this point onwards, since column-tracking was disabled due to the size of the code/headers",
    "replacement": "'-Wmisleading-indentation' 从此点处开始禁用，因为列追踪由于 code/headers 大小的原因而被禁用"
  },
  {
    "id": "adding %<-flarge-source-files%> will allow for more column-tracking support, at the expense of compilation time and memory",
    "pattern": "adding '-flarge-source-files' will allow for more column-tracking support, at the expense of compilation time and memory",
    "replacement": "添加 '-flarge-source-files' 将允许更多的列追踪支持，但这将付出编译时间和内存的代价"
  },
  {
    "id": "this %qs clause does not guard...",
    "pattern": "this '(.+?)' clause does not guard...",
    "replacement": "此 '$1' 子句不管控..."
  },
  {
    "id": "...this statement, but the latter is misleadingly indented as if it were guarded by the %qs",
    "pattern": "...this statement, but the latter is misleadingly indented as if it were guarded by the '(.+?)'",
    "replacement": "...此语句，但后者错误地缩进为仿佛它被 '$1' 管控"
  },
  {
    "id": "badly nested C headers from preprocessor",
    "pattern": "badly nested C headers from preprocessor",
    "replacement": "预处理器生成了错误的嵌套 C 头"
  },
  {
    "id": "ignoring %<#pragma %s %s%>",
    "pattern": "ignoring '#pragma (.*?) (.*?)'",
    "replacement": "忽略 '#pragma $1 $2'"
  },
  {
    "id": "stray %<@%> in program",
    "pattern": "stray '@' in program",
    "replacement": "程序中有游离的 '@'"
  },
  {
    "id": "stray %qs in program",
    "pattern": "stray '(.+?)' in program",
    "replacement": "程序中有游离的 '$1'"
  },
  {
    "id": "missing terminating %c character",
    "pattern": "missing terminating (.) character",
    "replacement": "缺少结束的 $1 字符"
  },
  {
    "id": "stray %qc in program",
    "pattern": "stray '(.)' in program",
    "replacement": "程序中有游离的 '$1'"
  },
  {
    "id": "this decimal constant is unsigned only in ISO C90",
    "pattern": "this decimal constant is unsigned only in ISO C90",
    "replacement": "这个十进制数常量仅在 ISO C90 中是无符号的"
  },
  {
    "id": "this decimal constant would be unsigned in ISO C90",
    "pattern": "this decimal constant would be unsigned in ISO C90",
    "replacement": "这个十进制数常量在 ISO C90 中将是无符号的"
  },
  {
    "id": "integer constant is too large for %<unsigned long%> type",
    "pattern": "integer constant is too large for 'unsigned long' type",
    "replacement": "对 'unsigned long' 类型而言整数常量太大"
  },
  {
    "id": "unsuffixed floating constant",
    "pattern": "unsuffixed floating constant",
    "replacement": "无后缀的浮点常量"
  },
  {
    "id": "decimal floating-point not supported for this target",
    "pattern": "decimal floating-point not supported for this target",
    "replacement": "十进制浮点类型在此目标机上不受支持"
  },
  {
    "id": "unsupported non-standard suffix on floating constant",
    "pattern": "unsupported non-standard suffix on floating constant",
    "replacement": "不被支持的非标准浮点常量后缀"
  },
  {
    "id": "non-standard suffix on floating constant",
    "pattern": "non-standard suffix on floating constant",
    "replacement": "非标准的浮点常量后缀"
  },
  {
    "id": "floating constant exceeds range of %qT",
    "pattern": "floating constant exceeds range of '(.+?)'",
    "replacement": "浮点常量超出 '$1' 的范围"
  },
  {
    "id": "floating constant truncated to zero",
    "pattern": "floating constant truncated to zero",
    "replacement": "浮点常量向零截断"
  },
  {
    "id": "repeated %<@%> before Objective-C string",
    "pattern": "repeated '@' before Objective-C string",
    "replacement": "Objective-C 字符串之前出现重复的 '@'"
  },
  {
    "id": "unsupported non-standard concatenation of string literals",
    "pattern": "unsupported non-standard concatenation of string literals",
    "replacement": "不受支持的非标准字面字符串毗连"
  },
  {
    "id": "traditional C rejects string constant concatenation",
    "pattern": "traditional C rejects string constant concatenation",
    "replacement": "传统 C 不接受字符串常量毗连"
  },
  {
    "id": "%<#pragma omp critical%> with %<hint%> clause requires a name, except when %<omp_sync_hint_none%> is used",
    "pattern": "'#pragma omp critical' with 'hint' clause requires a name, except when 'omp_sync_hint_none' is used",
    "replacement": "'#pragma omp critical' 带 'hint' 子句需要一个名字，仅当 'omp_sync_hint_none' 被使用时除外"
  },
  {
    "id": "invalid expression type for %<#pragma omp atomic%>",
    "pattern": "invalid expression type for '#pragma omp atomic'",
    "replacement": "'#pragma omp atomic' 表达式类型无效"
  },
  {
    "id": "%<_Atomic%> expression in %<#pragma omp atomic%>",
    "pattern": "'_Atomic' expression in '#pragma omp atomic'",
    "replacement": "'#pragma omp atomic' 中出现 '_Atomic' 表达式"
  },
  {
    "id": "%<#pragma omp atomic update%> uses two different variables for memory",
    "pattern": "'#pragma omp atomic update' uses two different variables for memory",
    "replacement": "'#pragma omp atomic update' 使用两个不同的变量用于内存"
  },
  {
    "id": "%<#pragma omp atomic capture%> uses two different variables for memory",
    "pattern": "'#pragma omp atomic capture' uses two different variables for memory",
    "replacement": "'# pragma omp atomic capture' 使用两个不同的变量用于内存"
  },
  {
    "id": "type of %<depobj%> expression is not %<omp_depend_t%>",
    "pattern": "type of 'depobj' expression is not 'omp_depend_t'",
    "replacement": "'depobj' 表达式的类型不是 'omp_depend_t'"
  },
  {
    "id": "%<const%> qualified %<depobj%> expression",
    "pattern": "'const' qualified 'depobj' expression",
    "replacement": "'const' 限定的 'depobj' 表达式"
  },
  {
    "id": "more than one locator in %<depend%> clause on %<depobj%> construct",
    "pattern": "more than one locator in 'depend' clause on 'depobj' construct",
    "replacement": "'depobj' 结构中 'depend' 子句有多于一个定位符"
  },
  {
    "id": "%<depobj%> dependence type specified in %<depend%> clause on %<depobj%> construct",
    "pattern": "'depobj' dependence type specified in 'depend' clause on 'depobj' construct",
    "replacement": "'depobj' 依赖类型在 'depobj' 结构中指定了 'depend' 子句"
  },
  {
    "id": "%<iterator%> modifier may not be specified on %<depobj%> construct",
    "pattern": "'iterator' modifier may not be specified on 'depobj' construct",
    "replacement": "'depobj' 结构中不能指定 'iterator' 修饰符"
  },
  {
    "id": "invalid type for iteration variable %qE",
    "pattern": "invalid type for iteration variable '(.+?)'",
    "replacement": "迭代变量 '$1' 类型无效"
  },
  {
    "id": "%<_Atomic%> iteration variable %qE",
    "pattern": "'_Atomic' iteration variable '(.+?)'",
    "replacement": "迭代变量 '$1' 是 '_Atomic' 的"
  },
  {
    "id": "%qE is not initialized",
    "pattern": "'(.+?)' is not initialized",
    "replacement": "'$1' 未经初始化"
  },
  {
    "id": "missing controlling predicate",
    "pattern": "missing controlling predicate",
    "replacement": "缺少控制谓词"
  },
  {
    "id": "invalid controlling predicate",
    "pattern": "invalid controlling predicate",
    "replacement": "无效的控制谓词"
  },
  {
    "id": "missing increment expression",
    "pattern": "missing increment expression",
    "replacement": "缺少自增表达式"
  },
  {
    "id": "increment is not constant 1 or -1 for %<!=%> condition",
    "pattern": "increment is not constant 1 or -1 for '!=' condition",
    "replacement": "在 '!=' 条件中自增不是常量 1 或 -1"
  },
  {
    "id": "invalid increment expression",
    "pattern": "invalid increment expression",
    "replacement": "无效的自增表达式"
  },
  {
    "id": "initializer expression refers to iteration variable %qD",
    "pattern": "initializer expression refers to iteration variable '(.+?)'",
    "replacement": "初始化器表达式指示了迭代变量 '$1'"
  },
  {
    "id": "condition expression refers to iteration variable %qD",
    "pattern": "condition expression refers to iteration variable '(.+?)'",
    "replacement": "条件表达式指示了迭代变量 '$1'"
  },
  {
    "id": "increment expression refers to iteration variable %qD",
    "pattern": "increment expression refers to iteration variable '(.+?)'",
    "replacement": "自增表达式指示了迭代变量 '$1'"
  },
  {
    "id": "outer iteration variable %qD used in initializer expression has type other than %qT",
    "pattern": "outer iteration variable '(.+?)' used in initializer expression has type other than '(.+?)'",
    "replacement": "在初始化器表达式中使用的外层迭代变量 '$1' 具有不同于 '$2' 的类型"
  },
  {
    "id": "outer iteration variable %qD used in condition expression has type other than %qT",
    "pattern": "outer iteration variable '(.+?)' used in condition expression has type other than '(.+?)'",
    "replacement": "在条件表达式中使用的外层迭代变量 '$1' 具有不同于 '$2' 的类型"
  },
  {
    "id": "outer iteration variable %qD multiplier expression %qE is not integral",
    "pattern": "outer iteration variable '(.+?)' multiplier expression '(.+?)' is not integral",
    "replacement": "在乘性表达式 '$2' 中使用的外层迭代变量 '$1' 不是整数类型"
  },
  {
    "id": "outer iteration variable %qD addend expression %qE is not integral",
    "pattern": "outer iteration variable '(.+?)' addend expression '(.+?)' is not integral",
    "replacement": "在加性表达式 '$2' 中使用的外层迭代变量 '$1' 不是整数类型"
  },
  {
    "id": "the same loop iteration variables %qD used in multiple associated loops",
    "pattern": "the same loop iteration variables '(.+?)' used in multiple associated loops",
    "replacement": "相同循环迭代变量 '$1' 在多个相关循环中使用"
  },
  {
    "id": "two different outer iteration variables %qD and %qD used in a single loop",
    "pattern": "two different outer iteration variables '(.+?)' and '(.+?)' used in a single loop",
    "replacement": "两个不同的迭代变量 '$1' 和 '$2' 在同一循环中使用"
  },
  {
    "id": "invalid %<task%> reduction modifier on construct combined with %<simd%> or %<loop%>",
    "pattern": "invalid 'task' reduction modifier on construct combined with 'simd' or 'loop'",
    "replacement": "与 'simd' 或 'loop' 构造时无效的 'task' 规约修饰符"
  },
  {
    "id": "invalid %<task%> reduction modifier on construct not combined with %<parallel%>, %<for%> or %<sections%>",
    "pattern": "invalid 'task' reduction modifier on construct not combined with 'parallel', 'for' or 'sections'",
    "replacement": "不与 'parallel'、'for' 或 'sections' 构造时无效的 'task' 规约修饰符"
  },
  {
    "id": "%<inscan%> %<reduction%> clause on construct other than %<for%>, %<simd%>, %<for simd%>, %<parallel for%>, %<parallel for simd%>",
    "pattern": "'inscan' 'reduction' clause on construct other than 'for', 'simd', 'for simd', 'parallel for', 'parallel for simd'",
    "replacement": "构造时 'inscan' 'reduction' 子句而非 'for'、'simd'、'for simd'、'parallel for'、'parallel for simd'"
  },
  {
    "id": "%qD specified in %<allocate%> clause but not in an explicit privatization clause",
    "pattern": "'(.+?)' specified in 'allocate' clause but not in an explicit privatization clause",
    "replacement": "'allocate' 子句中指定了 '$1' 但不在显式私有化子句中"
  },
  {
    "id": "%qD is not a function argument",
    "pattern": "'(.+?)' is not a function argument",
    "replacement": "'$1' 不是函数实参"
  },
  {
    "id": "selector set %qs specified more than once",
    "pattern": "selector set '(.+?)' specified more than once",
    "replacement": "指定多于一次的选择器集 '$1'"
  },
  {
    "id": "selector %qs specified more than once in set %qs",
    "pattern": "selector '(.+?)' specified more than once in set '(.+?)'",
    "replacement": "集 '$2' 中指定多于一次的选择器 '$1'"
  },
  {
    "id": "incorrect property %qs of %qs selector",
    "pattern": "incorrect property '(.+?)' of '(.+?)' selector",
    "replacement": "'$2' 选择器中不正确的属性 '$1'"
  },
  {
    "id": "unknown property %qs of %qs selector",
    "pattern": "unknown property '(.+?)' of '(.+?)' selector",
    "replacement": "'$2' 选择器中未知的属性 '$1'"
  },
  {
    "id": "%qD used as a variant with incompatible %<construct%> selector sets",
    "pattern": "'(.+?)' used as a variant with incompatible 'construct' selector sets",
    "replacement": "'$1' 作为一个变体与 'construct' 选择器集不兼容"
  },
  {
    "id": "%<-I-%> specified twice",
    "pattern": "'-I-' specified twice",
    "replacement": "'-I-' 指定了两次"
  },
  {
    "id": "obsolete option %<-I-%> used, please use %<-iquote%> instead",
    "pattern": "obsolete option '-I-' used, please use '-iquote' instead",
    "replacement": "使用了过时的选项 '-I-'，请改用 '-iquote'"
  },
  {
    "id": "%<-Wabi=1%> is not supported, using =2",
    "pattern": "'-Wabi=1' is not supported, using =2",
    "replacement": "'-Wabi=1' 不受支持，将使用 =2"
  },
  {
    "id": "output filename specified twice",
    "pattern": "output filename specified twice",
    "replacement": "输出文件名指定了两次"
  },
  {
    "id": "%<-fexcess-precision=standard%> for C++",
    "pattern": "'-fexcess-precision=standard' for C\\+\\+",
    "replacement": "对 C++ 而言 '-fexcess-precision=standard'"
  },
  {
    "id": "%<-fno-gnu89-inline%> is only supported in GNU99 or C99 mode",
    "pattern": "'-fno-gnu89-inline' is only supported in GNU99 or C99 mode",
    "replacement": "'-fno-gnu89-inline' 仅在 GNU99 或 C99 模式下支持"
  },
  {
    "id": "%<-Wformat-y2k%> ignored without %<-Wformat%>",
    "pattern": "'-Wformat-y2k' ignored without '-Wformat'",
    "replacement": "'-Wformat-y2k' 未与 '-Wformat' 一起使用，已忽略"
  },
  {
    "id": "%<-Wformat-extra-args%> ignored without %<-Wformat%>",
    "pattern": "'-Wformat-extra-args' ignored without '-Wformat'",
    "replacement": "'-Wformat-extra-args' 未与 '-Wformat' 一起使用，已忽略"
  },
  {
    "id": "%<-Wformat-zero-length%> ignored without %<-Wformat%>",
    "pattern": "'-Wformat-zero-length' ignored without '-Wformat'",
    "replacement": "'-Wformat-zero-length' 未与 '-Wformat' 一起使用，已忽略"
  },
  {
    "id": "%<-Wformat-nonliteral%> ignored without %<-Wformat%>",
    "pattern": "'-Wformat-nonliteral' ignored without '-Wformat'",
    "replacement": "'-Wformat-nonliteral' 未与 '-Wformat' 一起使用，已忽略"
  },
  {
    "id": "%<-Wformat-contains-nul%> ignored without %<-Wformat%>",
    "pattern": "'-Wformat-contains-nul' ignored without '-Wformat'",
    "replacement": "'-Wformat-contains-nul' 未与 '-Wformat' 一起使用，已忽略"
  },
  {
    "id": "%<-Wformat-security%> ignored without %<-Wformat%>",
    "pattern": "'-Wformat-security' ignored without '-Wformat'",
    "replacement": "'-Wformat-security' 未与 '-Wformat' 一起使用，已忽略"
  },
  {
    "id": "%<-fabi-compat-version=1%> is not supported, using =2",
    "pattern": "'-fabi-compat-version=1' is not supported, using =2",
    "replacement": "'-fabi-compat-version=1' 不受支持，将使用 =2"
  },
  {
    "id": "%<-Wabi%> won%'t warn about anything",
    "pattern": "'-Wabi' won't warn about anything",
    "replacement": "'-Wabi' 将不会警告任何事"
  },
  {
    "id": "%<-Wabi%> warns about differences from the most up-to-date ABI, which is also used by default",
    "pattern": "'-Wabi' warns about differences from the most up-to-date ABI, which is also used by default",
    "replacement": "'-Wabi' 将警告最新的 ABI 差异，这通常是默认使用的"
  },
  {
    "id": "use e.g. %<-Wabi=11%> to warn about changes from GCC 7",
    "pattern": "use e.g. '-Wabi=11' to warn about changes from GCC 7",
    "replacement": "例如 '-Wabi=11' 警告自 GCC 7 以来的差异"
  },
  {
    "id": "external TLS initialization functions not supported on this target",
    "pattern": "external TLS initialization functions not supported on this target",
    "replacement": "外部 TLS 初始化函数在此目标上不受支持"
  },
  {
    "id": "too many filenames given; type %<%s %s%> for usage",
    "pattern": "too many filenames given; type '(.+?)' for usage",
    "replacement": "给定了太多文件名。键入 '$1' 以了解用法"
  },
  {
    "id": "opening output file %s: %m",
    "pattern": "opening output file",
    "replacement": "打开输出文件"
  },
  {
    "id": "the %qs debug format cannot be used with pre-compiled headers",
    "pattern": "the '(.+?)' debug format cannot be used with pre-compiled headers",
    "replacement": "'$1' 调试格式不能在预编译头上使用"
  },
  {
    "id": "opening dependency file %s: %m",
    "pattern": "opening dependency file",
    "replacement": "打开依赖文件"
  },
  {
    "id": "closing dependency file %s: %m",
    "pattern": "closing dependency file",
    "replacement": "关闭依赖文件"
  },
  {
    "id": "when writing output to %s: %m",
    "pattern": "when writing output to (.*?): (.*?)",
    "replacement": "当写入输出到 $1 时：$2"
  },
  {
    "id": "to generate dependencies you must specify either %<-M%> or %<-MM%>",
    "pattern": "to generate dependencies you must specify either '-M' or '-MM'",
    "replacement": "要生成依赖项，你必须指定 '-M' 或 '-MM'"
  },
  {
    "id": "%<-MG%> may only be used with %<-M%> or %<-MM%>",
    "pattern": "'-MG' may only be used with '-M' or '-MM'",
    "replacement": "'-MG' 只能与 '-M' 或 '-MM' 一起使用"
  },
  {
    "id": "%<-fdirectives-only%> is incompatible with %<-Wunused-macros%>",
    "pattern": "'-fdirectives-only' is incompatible with '-Wunused-macros'",
    "replacement": "'-fdirectives-only' 与 '-Wunused_macros' 不兼容"
  },
  {
    "id": "%<-fdirectives-only%> is incompatible with %<-traditional%>",
    "pattern": "'-fdirectives-only' is incompatible with '-traditional'",
    "replacement": "'-fdirectives-only' 与 '-traditional' 不兼容"
  },
  {
    "id": "too late for # directive to set debug directory",
    "pattern": "too late for # directive to set debug directory",
    "replacement": "使用 # 指示设定调试目录太迟"
  },
  {
    "id": "cannot create precompiled header %s: %m",
    "pattern": "cannot create precompiled header",
    "replacement": "无法创建预编译头"
  },
  {
    "id": "cannot write to %s: %m",
    "pattern": "cannot write to",
    "replacement": "无法写入"
  },
  {
    "id": "%<pch_preprocess%> pragma should only be used with %<-fpreprocessed%>",
    "pattern": "'pch_preprocess' pragma should only be used with '-fpreprocessed'",
    "replacement": "'pch_preprocess' pragma 只应与 '-fpreprocessed' 并用"
  },
  {
    "id": "use %<#include%> instead",
    "pattern": "use '#include' instead",
    "replacement": "使用 '#include' 代替"
  },
  {
    "id": "%s: couldn%'t open PCH file: %m",
    "pattern": "couldn't open PCH file: ",
    "replacement": "无法打开 PCH 文件："
  },
  {
    "id": "use %<-Winvalid-pch%> for more information",
    "pattern": "use '-Winvalid-pch' for more information",
    "replacement": "使用 '-Winvalid-pch' 以获得更多信息"
  },
  {
    "id": "%s: PCH file was invalid",
    "pattern": "PCH file was invalid",
    "replacement": "PCH 文件无效"
  },
  {
    "id": "%<#pragma pack (pop)%> encountered without matching %<#pragma pack (push)%>",
    "pattern": "'#pragma pack \\(pop\\)' encountered without matching '#pragma pack \\(push\\)'",
    "replacement": "'#pragma pack (pop)' 没有相匹配的 '#pragma pack (push)'"
  },
  {
    "id": "%<#pragma pack(pop, %E)%> encountered without matching %<#pragma pack(push, %E)%>",
    "pattern": "'#pragma pack\\(pop, (.+?)\\)' encountered without matching '#pragma pack\\(push, (.+?)\\)'",
    "replacement": "'#pragma pack (pop, $1)' 没有相匹配的 '#pragma pack(push, $2)'"
  },
  {
    "id": "missing %<(%> after %<#pragma pack%> - ignored",
    "pattern": "missing '\\(' after '#pragma pack' - ignored",
    "replacement": "'#pragma pack' 后缺少 '(' - 已忽略"
  },
  {
    "id": "invalid constant in %<#pragma pack%> - ignored",
    "pattern": "invalid constant in '#pragma pack' - ignored",
    "replacement": "'#pragma pack' 中有无效常量 - 已忽略"
  },
  {
    "id": "malformed %<#pragma pack%> - ignored",
    "pattern": "malformed '#pragma pack' - ignored",
    "replacement": "'#pragma pack' 格式错误 - 已忽略"
  },
  {
    "id": "malformed %<#pragma pack(push[, id][, <n>])%> - ignored",
    "pattern": "malformed '#pragma pack\\(push\\[, id\\]\\[, <n>\\]\\)' - ignored",
    "replacement": "'#pragma pack(push[, id][, <n>])' 格式错误 - 已忽略"
  },
  {
    "id": "malformed %<#pragma pack(pop[, id])%> - ignored",
    "pattern": "malformed '#pragma pack\\(pop\\[, id\\]\\)' - ignored",
    "replacement": "'#pragma pack(pop[, id])' 格式错误 - 已忽略"
  },
  {
    "id": "unknown action %qE for %<#pragma pack%> - ignored",
    "pattern": "unknown action '(.+?)' for '#pragma pack' - ignored",
    "replacement": "'#pragma pack' 动作 '(.+?)' 无效 - 已忽略"
  },
  {
    "id": "junk at end of %<#pragma pack%>",
    "pattern": "junk at end of '#pragma pack'",
    "replacement": "'#pragma pack' 末尾有垃圾字符"
  },
  {
    "id": "%<#pragma pack%> has no effect with %<-fpack-struct%> - ignored",
    "pattern": "'#pragma pack' has no effect with '-fpack-struct' - ignored",
    "replacement": "指定了 '-fpack-struct' 时 '#pragma pack' 没有作用  - 已忽略"
  },
  {
    "id": "alignment must be a small power of two, not %d",
    "pattern": "alignment must be a small power of two, not (\\d+)",
    "replacement": "对齐边界必须是 2 的较小次幂，而不是 $1"
  },
  {
    "id": "applying %<#pragma weak %+D%> after first use results in unspecified behavior",
    "pattern": "applying '#pragma weak (.+?)' after first use results in unspecified behavior",
    "replacement": "在第一次使用后应用 '#pragma weak $1' 导致未指明行为"
  },
  {
    "id": "malformed %<#pragma weak%>, ignored",
    "pattern": "malformed '#pragma weak', ignored",
    "replacement": "'#pragma weak' 格式错误，已忽略"
  },
  {
    "id": "junk at end of %<#pragma weak%>",
    "pattern": "junk at end of '#pragma weak'",
    "replacement": "'#pragma weak'末尾有垃圾字符"
  },
  {
    "id": "%<#pragma weak%> declaration of %q+D not allowed, ignored",
    "pattern": "'#pragma weak' declaration of '(.+?)' not allowed, ignored",
    "replacement": "不支持 '$1' 的弱声明"
  },
  {
    "id": "%<scalar_storage_order%> is not supported because endianness is not uniform",
    "pattern": "'scalar_storage_order' is not supported because endianness is not uniform",
    "replacement": "'scalar_storage_order' 不支持，因端序不是统一的"
  },
  {
    "id": "%<#pragma scalar_storage_order%> is not supported for C++",
    "pattern": "'#pragma scalar_storage_order' is not supported for C\\+\\+",
    "replacement": "'#pragma scalar_storage_order' 不为 C++ 所支持"
  },
  {
    "id": "missing [big-endian|little-endian|default] after %<#pragma scalar_storage_order%>",
    "pattern": "missing \\[big-endian\\|little-endian\\|default\\] after '#pragma scalar_storage_order'",
    "replacement": "'#pragma scalar_storage_order' 后丢失 [big-endian|little-endian|default]"
  },
  {
    "id": "expected [big-endian|little-endian|default] after %<#pragma scalar_storage_order%>",
    "pattern": "expected \\[big-endian\\|little-endian\\|default\\] after '#pragma scalar_storage_order'",
    "replacement": "'#pragma scalar_storage_order' 后期望 [big-endian|little-endian|default]"
  },
  {
    "id": "malformed %<#pragma redefine_extname%>, ignored",
    "pattern": "malformed '#pragma redefine_extname', ignored",
    "replacement": "#pragma redefine_extname 格式错误，已忽略"
  },
  {
    "id": "junk at end of %<#pragma redefine_extname%>",
    "pattern": "junk at end of '#pragma redefine_extname'",
    "replacement": "'#pragma redefine_extname' 末尾有垃圾字符"
  },
  {
    "id": "%<#pragma redefine_extname%> ignored due to conflict with previous rename",
    "pattern": "'#pragma redefine_extname' ignored due to conflict with previous rename",
    "replacement": "'#pragma redefine_extname' 因与之前的重命名冲突而被忽略"
  },
  {
    "id": "%<#pragma redefine_extname%> ignored due to conflict with previous %<#pragma redefine_extname%>",
    "pattern": "'#pragma redefine_extname' ignored due to conflict with previous '#pragma redefine_extname'",
    "replacement": "'#pragma redefine_extname' 因与之前的 '#pragma redefine_extname' 冲突而被忽略"
  },
  {
    "id": "%<asm%> declaration ignored due to conflict with previous rename",
    "pattern": "'asm' declaration ignored due to conflict with previous rename",
    "replacement": "'asm' 声明因与之前的重命名冲突而被忽略"
  },
  {
    "id": "%<#pragma redefine_extname%> ignored due to conflict with %<asm%> declaration",
    "pattern": "'#pragma redefine_extname' ignored due to conflict with 'asm' declaration",
    "replacement": "'#pragma redefine_extname' 因与 'asm' 声明冲突而被忽略"
  },
  {
    "id": "%<#pragma GCC visibility push()%> must specify %<default%>, %<internal%>, %<hidden%> or %<protected%>",
    "pattern": "'#pragma GCC visibility push\\(\\)' must specify 'default', 'internal', 'hidden' or 'protected'",
    "replacement": "'#pragma GCC visibility push()' 必须指定 'default'、'internal'、'hidden' 或 'protected'"
  },
  {
    "id": "%<#pragma GCC visibility%> must be followed by %<push%> or %<pop%>",
    "pattern": "'#pragma GCC visibility' must be followed by 'push' or 'pop'",
    "replacement": "'#pragma GCC visibility' 后面必须跟 'push' 或 'pop'"
  },
  {
    "id": "no matching push for %<#pragma GCC visibility pop%>",
    "pattern": "no matching push for '#pragma GCC visibility pop'",
    "replacement": "没有与 '#pragma GCC visibility pop' 对应的 push"
  },
  {
    "id": "missing %<(%> after %<#pragma GCC visibility push%> - ignored",
    "pattern": "missing '\\(' after '#pragma GCC visibility push' - ignored",
    "replacement": "'#pragma GCC visibility push' 缺少 '(' - 已忽略"
  },
  {
    "id": "malformed %<#pragma GCC visibility push%>",
    "pattern": "malformed '#pragma GCC visibility push'",
    "replacement": "#pragma GCC visibility push 格式错误"
  },
  {
    "id": "junk at end of %<#pragma GCC visibility%>",
    "pattern": "junk at end of '#pragma GCC visibility'",
    "replacement": "'#pragma GCC visibility' 末尾有垃圾字符"
  },
  {
    "id": "missing [error|warning|ignored|push|pop] after %<#pragma GCC diagnostic%>",
    "pattern": "missing \\[error\\|warning\\|ignored\\|push\\|pop\\] after '#pragma GCC diagnostic'",
    "replacement": "'#pragma GCC diagnostic' 后缺少 'error'、'warning' 或 'ignored'"
  },
  {
    "id": "expected [error|warning|ignored|push|pop] after %<#pragma GCC diagnostic%>",
    "pattern": "expected \\[error\\|warning\\|ignored\\|push\\|pop\\] after '#pragma GCC diagnostic'",
    "replacement": "'#pragma GCC diagnostic' 后需要 'error'、'warning' 或 'ignored'"
  },
  {
    "id": "missing option after %<#pragma GCC diagnostic%> kind",
    "pattern": "missing option after '#pragma GCC diagnostic' kind",
    "replacement": "'#pragma GCC diagnostic' 后缺失选项"
  },
  {
    "id": "unknown option after %<#pragma GCC diagnostic%> kind",
    "pattern": "unknown option after '#pragma GCC diagnostic' kind",
    "replacement": "'#pragma GCC diagnostic' 后有未知选项"
  },
  {
    "id": "did you mean %<-%s%>?",
    "pattern": "did you mean '-(.*?)'\\?",
    "replacement": "你的意思是 '-$1' 吗？"
  },
  {
    "id": "%qs is not an option that controls warnings",
    "pattern": "'(.+?)' is not an option that controls warnings",
    "replacement": "'(.+?)' 对 '(.+?)' 而言无效"
  },
  {
    "id": "option %qs is valid for %s but not for %s",
    "pattern": "option '(.+?)' is valid for (.*?) but not for (.*?)",
    "replacement": "命令行选项 '$1' 对 $2 是有效的，但对 $3 无效"
  },
  {
    "id": "%<#pragma GCC option%> is not allowed inside functions",
    "pattern": "'#pragma GCC option' is not allowed inside functions",
    "replacement": "'#pragma GCC option' 不允许用在函数中"
  },
  {
    "id": "%<#pragma GCC option%> is not a string",
    "pattern": "'#pragma GCC option' is not a string",
    "replacement": "'#pragma GCC option' 不是一个字符串"
  },
  {
    "id": "%<#pragma GCC target (string [,string]...)%> does not have a final %<)%>",
    "pattern": "'#pragma GCC target \\(string \\[,string\\]...\\)' does not have a final '\\)'",
    "replacement": "'#pragma GCC target (string [,string]...)' 缺少最后的 ')'"
  },
  {
    "id": "%<#pragma GCC target%> string is badly formed",
    "pattern": "'#pragma GCC target' string is badly formed",
    "replacement": "'#pragma GCC target' 字符串格式不正确"
  },
  {
    "id": "%<#pragma GCC optimize%> is not allowed inside functions",
    "pattern": "'#pragma GCC optimize' is not allowed inside functions",
    "replacement": "'#pragma GCC optimize' 不允许用在函数中"
  },
  {
    "id": "%<#pragma GCC optimize%> is not a string or number",
    "pattern": "'#pragma GCC optimize' is not a string or number",
    "replacement": "'#pragma GCC optimize' 不是字符串或数字"
  },
  {
    "id": "%<#pragma GCC optimize (string [,string]...)%> does not have a final %<)%>",
    "pattern": "'#pragma GCC optimize \\(string \\[,string\\]...\\)' does not have a final '\\)'",
    "replacement": "'#pragma GCC optimize (string [,string]...)' 缺少最后的 ')'。"
  },
  {
    "id": "%<#pragma GCC optimize%> string is badly formed",
    "pattern": "'#pragma GCC optimize' string is badly formed",
    "replacement": "#pragma GCC optimize 字符串格式不正确"
  },
  {
    "id": "junk at end of %<#pragma push_options%>",
    "pattern": "junk at end of '#pragma push_options'",
    "replacement": "'#pragma push_options' 末尾有垃圾字符"
  },
  {
    "id": "junk at end of %<#pragma pop_options%>",
    "pattern": "junk at end of '#pragma pop_options'",
    "replacement": "'#pragma pop_options' 末尾有垃圾字符"
  },
  {
    "id": "%<#pragma GCC pop_options%> without a corresponding %<#pragma GCC push_options%>",
    "pattern": "'#pragma GCC pop_options' without a corresponding '#pragma GCC push_options'",
    "replacement": "'#pragma GCC pop_options' 缺少相应的'#pragma GCC push_options'"
  },
  {
    "id": "junk at end of %<#pragma reset_options%>",
    "pattern": "junk at end of '#pragma reset_options'",
    "replacement": "'#pragma reset_options'末尾有垃圾字符"
  },
  {
    "id": "expected a string after %<#pragma message%>",
    "pattern": "expected a string after '#pragma message'",
    "replacement": "'#pragma message' 后需要一个字符串"
  },
  {
    "id": "malformed %<#pragma message%>, ignored",
    "pattern": "malformed '#pragma message', ignored",
    "replacement": "'#pragma message' 格式错误，已忽略"
  },
  {
    "id": "junk at end of %<#pragma message%>",
    "pattern": "junk at end of '#pragma message'",
    "replacement": "'#pragma message' 末尾有垃圾字符"
  },
  {
    "id": "invalid location for %<pragma %s%>, ignored",
    "pattern": "invalid location for 'pragma (.*?)', ignored",
    "replacement": "'pragma (.*?)' 位置错误，已忽略"
  },
  {
    "id": "malformed %<#pragma %s%>, ignored",
    "pattern": "malformed '#pragma (.*?)', ignored",
    "replacement": "'#pragma (.*?)' 格式错误，已忽略"
  },
  {
    "id": "junk at end of %<#pragma %s%>",
    "pattern": "junk at end of '#pragma (.*?)'",
    "replacement": "'#pragma (.*?)' 末尾有垃圾"
  },
  {
    "id": "%<#pragma STDC FLOAT_CONST_DECIMAL64%> is not supported for C++",
    "pattern": "'#pragma STDC FLOAT_CONST_DECIMAL64' is not supported for C\\+\\+",
    "replacement": "'#pragma STDC FLOAT_CONST_DECIMAL64' 不为 C++ 所支持"
  },
  {
    "id": "%<#pragma STDC FLOAT_CONST_DECIMAL64%> is not supported on this target",
    "pattern": "'#pragma STDC FLOAT_CONST_DECIMAL64' is not supported on this target",
    "replacement": "'#pragma STDC FLOAT_CONST_DECIMAL64'在此目标上不受支持"
  },
  {
    "id": "ISO C does not support %<#pragma STDC FLOAT_CONST_DECIMAL64%>",
    "pattern": "ISO C does not support '#pragma STDC FLOAT_CONST_DECIMAL64'",
    "replacement": "ISO C 不支持 '#pragma STDC FLOAT_CONST_DECIMAL64'"
  },
  {
    "id": "<type-error>",
    "pattern": "<type-error>",
    "replacement": "<类型错误>"
  },
  {
    "id": "<unnamed-unsigned:",
    "pattern": "<unnamed-unsigned:",
    "replacement": "<无名无符号数："
  },
  {
    "id": "<unnamed-float:",
    "pattern": "<unnamed-float:",
    "replacement": "<无名浮点数："
  },
  {
    "id": "<unnamed-fixed:",
    "pattern": "<unnamed-fixed:",
    "replacement": "<无名定点数："
  },
  {
    "id": "<typedef-error>",
    "pattern": "<typedef-error>",
    "replacement": "<typedef 错误>"
  },
  {
    "id": "<tag-error>",
    "pattern": "<tag-error>",
    "replacement": "<tag 错误>"
  },
  {
    "id": "<erroneous-expression>",
    "pattern": "<erroneous-expression>",
    "replacement": "<错误表达式>"
  },
  {
    "id": "<return-value>",
    "pattern": "<return-value>",
    "replacement": "<返回值>"
  },
  {
    "id": "wrong type argument to %s",
    "pattern": "wrong type argument to (.*?)",
    "replacement": "$1 的错误类型实参"
  },
  {
    "id": "overflow in constant expression",
    "pattern": "overflow in constant expression",
    "replacement": "常量表达式溢出"
  },
  {
    "id": "integer overflow in expression %qE of type %qT results in %qE",
    "pattern": "integer overflow in expression '(.+?)' of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$2' 的表达式 '$1' 中整数溢出，得到结果 '$3'"
  },
  {
    "id": "integer overflow in expression of type %qT results in %qE",
    "pattern": "integer overflow in expression of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$1' 的表达式中整数溢出，得到结果 '$2'"
  },
  {
    "id": "floating point overflow in expression %qE of type %qT results in %qE",
    "pattern": "floating point overflow in expression '(.+?)' of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$2' 的表达式 '$1' 中浮点溢出，得到结果 '$3'"
  },
  {
    "id": "floating point overflow in expression of type %qT results in %qE",
    "pattern": "floating point overflow in expression of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$1' 的表达式中浮点溢出，得到结果 '$2'"
  },
  {
    "id": "fixed-point overflow in expression %qE of type %qT results in %qE",
    "pattern": "fixed-point overflow in expression '(.+?)' of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$2' 的表达式 '$1' 中定点溢出，得到结果 '$3'"
  },
  {
    "id": "fixed-point overflow in expression of type %qT results in %qE",
    "pattern": "fixed-point overflow in expression of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$1' 的表达式中定点溢出，得到结果 '$2'"
  },
  {
    "id": "vector overflow in expression %qE of type %qT results in %qE",
    "pattern": "vector overflow in expression '(.+?)' of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$2' 的表达式 '$1' 中向量溢出，得到结果 '$3'"
  },
  {
    "id": "vector overflow in expression of type %qT results in %qE",
    "pattern": "vector overflow in expression of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$1' 的表达式中向量溢出，得到结果 '$2'"
  },
  {
    "id": "complex integer overflow in expression %qE of type %qT results in %qE",
    "pattern": "complex integer overflow in expression '(.+?)' of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$2' 的表达式 '$1' 中整复数溢出，得到结果 '$3'"
  },
  {
    "id": "complex integer overflow in expression of type %qT results in %qE",
    "pattern": "complex integer overflow in expression of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$1' 的表达式中整复数溢出，得到结果 '$2'"
  },
  {
    "id": "complex floating point overflow in expression %qE of type %qT results in %qE",
    "pattern": "complex floating point overflow in expression '(.+?)' of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$2' 的表达式 '$1' 中浮点复数溢出，得到结果 '$3'"
  },
  {
    "id": "complex floating point overflow in expression of type %qT results in %qE",
    "pattern": "complex floating point overflow in expression of type '(.+?)' results in '(.+?)'",
    "replacement": "在类型为 '$1' 的表达式中浮点复数溢出，得到结果 '$2'"
  },
  {
    "id": "logical %<or%> applied to non-boolean constant",
    "pattern": "logical 'or' applied to non-boolean constant",
    "replacement": "逻辑 'or' 被用在非布尔型常量上"
  },
  {
    "id": "logical %<and%> applied to non-boolean constant",
    "pattern": "logical 'and' applied to non-boolean constant",
    "replacement": "逻辑 'and' 被用在非布尔型常量上"
  },
  {
    "id": "logical %<or%> of collectively exhaustive tests is always true",
    "pattern": "logical 'or' of collectively exhaustive tests is always true",
    "replacement": "对两个互补的测试取逻辑 'or' 的结果永远为真"
  },
  {
    "id": "logical %<and%> of mutually exclusive tests is always false",
    "pattern": "logical 'and' of mutually exclusive tests is always false",
    "replacement": "对两个互斥的测试取逻辑 'and' 的结果永远为假"
  },
  {
    "id": "logical %<or%> of equal expressions",
    "pattern": "logical 'or' of equal expressions",
    "replacement": "等于表达式的逻辑 'or'"
  },
  {
    "id": "logical %<and%> of equal expressions",
    "pattern": "logical 'and' of equal expressions",
    "replacement": "等于表达式的逻辑 'and'"
  },
  {
    "id": "bitwise comparison always evaluates to false",
    "pattern": "bitwise comparison always evaluates to false",
    "replacement": "位比较总是求值为假"
  },
  {
    "id": "bitwise comparison always evaluates to true",
    "pattern": "bitwise comparison always evaluates to true",
    "replacement": "位比较总是求值为真"
  },
  {
    "id": "self-comparison always evaluates to true",
    "pattern": "self-comparison always evaluates to true",
    "replacement": "用户定义的比较总是求值为真"
  },
  {
    "id": "self-comparison always evaluates to false",
    "pattern": "self-comparison always evaluates to false",
    "replacement": "用户定义的比较总是求值为假"
  },
  {
    "id": "logical not is only applied to the left hand side of comparison",
    "pattern": "logical not is only applied to the left hand side of comparison",
    "replacement": "比较的左侧操作数不会应用逻辑非运算"
  },
  {
    "id": "add parentheses around left hand side expression to silence this warning",
    "pattern": "add parentheses around left hand side expression to silence this warning",
    "replacement": "在左侧操作数两侧加上括号来避免显示此警告"
  },
  {
    "id": "type-punning to incomplete type might break strict-aliasing rules",
    "pattern": "type-punning to incomplete type might break strict-aliasing rules",
    "replacement": "类型双关作用在不完整类型上可能破坏强重叠规则"
  },
  {
    "id": "dereferencing type-punned pointer will break strict-aliasing rules",
    "pattern": "dereferencing type-punned pointer will break strict-aliasing rules",
    "replacement": "对类型双关的指针解地址将破坏强重叠规则"
  },
  {
    "id": "dereferencing type-punned pointer might break strict-aliasing rules",
    "pattern": "dereferencing type-punned pointer might break strict-aliasing rules",
    "replacement": "对类型双关的指针解地址可能破坏强重叠规则"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the source; did you mean to use the size of the destination?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the source; did you mean to use the size of the destination\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 源 是相同的表达式；你的意思是使用 目标 的大小吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the destination; did you mean to remove the addressof?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the destination; did you mean to remove the addressof\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 目标 是相同的表达式；你的意思是移除 addressof 吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the destination; did you mean to provide an explicit length?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the destination; did you mean to provide an explicit length\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 目标 是相同的表达式；你的意思是提供明确的长度吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the destination; did you mean to dereference it?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the destination; did you mean to dereference it\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 目标 是相同的表达式；你的意思是对它解地址吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same pointer type %qT as the destination; expected %qT or an explicit length",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same pointer type '(.+?)' as the destination; expected '(.+?)' or an explicit length",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 目标 具有相同的指针类型 '$2'；期望 '$3' 或明确的长度"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the source; did you mean to remove the addressof?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the source; did you mean to remove the addressof\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 源 是相同的表达式；你的意思是移除 addressof 吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the source; did you mean to provide an explicit length?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the source; did you mean to provide an explicit length\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 源 是相同的表达式；你的意思是提供明确的长度吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the source; did you mean to dereference it?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the source; did you mean to dereference it\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 源 是相同的表达式；你的意思是对它解地址吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same pointer type %qT as the source; expected %qT or an explicit length",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same pointer type '(.+?)' as the source; expected '(.+?)' or an explicit length",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和 源 具有相同的指针类型 '$2'；期望 '$3' 或明确的长度"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the first source; did you mean to remove the addressof?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the first source; did you mean to remove the addressof\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第一个 源 是相同的表达式；你的意思是移除 addressof 吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the first source; did you mean to provide an explicit length?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the first source; did you mean to provide an explicit length\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第一个 源 是相同的表达式；你的意思是提供明确的长度吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the first source; did you mean to dereference it?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the first source; did you mean to dereference it\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第一个 源 是相同的表达式；你的意思是对它解地址吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same pointer type %qT as the first source; expected %qT or an explicit length",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same pointer type '(.+?)' as the first source; expected '(.+?)' or an explicit length",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第一个 源 相同的指针类型 '$2'；期望 '$3' 或明确的长度"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the second source; did you mean to remove the addressof?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the second source; did you mean to remove the addressof\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第二个 源 是相同的表达式；你的意思是移除 addressof 吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the second source; did you mean to provide an explicit length?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the second source; did you mean to provide an explicit length\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第二个 源 是相同的表达式；你的意思是提供明确的长度吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same expression as the second source; did you mean to dereference it?",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same expression as the second source; did you mean to dereference it\\?",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第二个 源 是相同的表达式；你的意思是对它解地址吗？"
  },
  {
    "id": "argument to %<sizeof%> in %qD call is the same pointer type %qT as the second source; expected %qT or an explicit length",
    "pattern": "argument to 'sizeof' in '(.+?)' call is the same pointer type '(.+?)' as the second source; expected '(.+?)' or an explicit length",
    "replacement": "在 '$1' 的调用中，'sizeof' 的实参和第二个 源 相同的指针类型 '$2'；期望 '$3' 或明确的长度"
  },
  {
    "id": "%<_Atomic%>-qualified parameter type %qT of %q+D",
    "pattern": "'_Atomic'-qualified parameter type '(.+?)' of '(.+?)'",
    "replacement": "'$2' 中 '_Atomic' 限定的形参类型 '$1'"
  },
  {
    "id": "first argument of %q+D should be %<int%>",
    "pattern": "first argument of '(.+?)' should be 'int'",
    "replacement": "'$1' 的第一个实参的类型应该是 'int'"
  },
  {
    "id": "second argument of %q+D should be %<char **%>",
    "pattern": "second argument of '(.+?)' should be 'char \\*\\*'",
    "replacement": "'$1' 的第二个实参类型应该是 'char **'"
  },
  {
    "id": "third argument of %q+D should probably be %<char **%>",
    "pattern": "third argument of '(.+?)' should probably be 'char \\*\\*'",
    "replacement": "'$1' 的第三个实参类型应该可能是'char **'"
  },
  {
    "id": "%q+D takes only zero or two arguments",
    "pattern": "'(.+?)' takes only zero or two arguments",
    "replacement": "'$1' 只接受零或两个实参"
  },
  {
    "id": "%q+D declared as variadic function",
    "pattern": "'(.+?)' declared as variadic function",
    "replacement": "'$1' 声明为接受变长实参的函数"
  },
  {
    "id": "conversion to %qT from boolean expression",
    "pattern": "conversion to '(.+?)' from boolean expression",
    "replacement": "从布尔表达式到 '$1' 的转换"
  },
  {
    "id": "unsigned conversion from %qT to %qT changes value from %qE to %qE",
    "pattern": "unsigned conversion from '(.+?)' to '(.+?)' changes value from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的无符号转换将值从 '$3' 改变为 '$4'"
  },
  {
    "id": "unsigned conversion from %qT to %qT changes the value of %qE",
    "pattern": "unsigned conversion from '(.+?)' to '(.+?)' changes the value of '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的无符号转换改变了 '$3' 的值"
  },
  {
    "id": "signed conversion from %qT to %qT changes value from %qE to %qE",
    "pattern": "signed conversion from '(.+?)' to '(.+?)' changes value from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的有符号转换将值从 '$3' 改变为 '$4'"
  },
  {
    "id": "signed conversion from %qT to %qT changes the value of %qE",
    "pattern": "signed conversion from '(.+?)' to '(.+?)' changes the value of '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的有符号转换改变了 '$3' 的值"
  },
  {
    "id": "conversion from %qT to %qT changes value from %qE to %qE",
    "pattern": "conversion from '(.+?)' to '(.+?)' changes value from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的转换将值从 '$3' 改变为 '$4'"
  },
  {
    "id": "conversion from %qT to %qT changes the value of %qE",
    "pattern": "conversion from '(.+?)' to '(.+?)' changes the value of '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的转换改变了 '$3' 的值"
  },
  {
    "id": "conversion to %qT from %qT may change the sign of the result",
    "pattern": "conversion to '(.+?)' from '(.+?)' may change the sign of the result",
    "replacement": "从 '$1' 到 '$2' 的转换可能会改变结果的符号"
  },
  {
    "id": "conversion from %qT to %qT discards imaginary component",
    "pattern": "conversion from '(.+?)' to '(.+?)' discards imaginary component",
    "replacement": "从 '$1' 到 '$2' 的转换可能会丢失虚部"
  },
  {
    "id": "conversion from %qT to %qT may change value",
    "pattern": "conversion from '(.+?)' to '(.+?)' may change value",
    "replacement": "从 '$1' 到 '$2' 的转换可能会改变值"
  },
  {
    "id": "overflow in conversion from %qT to %qT changes value from %qE to %qE",
    "pattern": "overflow in conversion from '(.+?)' to '(.+?)' changes value from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的转换发生溢出，值从 '$3' 改变为 '$4'"
  },
  {
    "id": "overflow in conversion from %qT to %qT changes the value of %qE",
    "pattern": "overflow in conversion from '(.+?)' to '(.+?)' changes the value of '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的转换发生溢出，改变了 '$3' 的值"
  },
  {
    "id": "case value %qs not in enumerated type",
    "pattern": "case value '(.+?)' not in enumerated type",
    "replacement": "case 值 '$1' 不在枚举类型内"
  },
  {
    "id": "case value %qs not in enumerated type %qT",
    "pattern": "case value '(.+?)' not in enumerated type '(.+?)'",
    "replacement": "case 值 '$1' 不在枚举类型 '$2' 内"
  },
  {
    "id": "lower value in case label range less than minimum value for type",
    "pattern": "lower value in case label range less than minimum value for type",
    "replacement": "case 标号范围的下限值比该类型的最小值还要小"
  },
  {
    "id": "case label value is less than minimum value for type",
    "pattern": "case label value is less than minimum value for type",
    "replacement": "case 标号值比该类型的最小值还要小"
  },
  {
    "id": "upper value in case label range exceeds maximum value for type",
    "pattern": "upper value in case label range exceeds maximum value for type",
    "replacement": "case 标号范围的上限值比该类型的最大值还要大"
  },
  {
    "id": "case label value exceeds maximum value for type",
    "pattern": "case label value exceeds maximum value for type",
    "replacement": "case 标号值比该类型的最大值还要大"
  },
  {
    "id": "switch missing default case",
    "pattern": "switch missing default case",
    "replacement": "switch 缺少 default case"
  },
  {
    "id": "switch condition has boolean value",
    "pattern": "switch condition has boolean value",
    "replacement": "switch 条件为布尔值"
  },
  {
    "id": "enumeration value %qE not handled in switch",
    "pattern": "enumeration value '(.+?)' not handled in switch",
    "replacement": "switch 没有处理枚举值 '$1'"
  },
  {
    "id": "the omitted middle operand in %<?:%> will always be %<true%>, suggest explicit middle operand",
    "pattern": "the omitted middle operand in '\\?:' will always be 'true', suggest explicit middle operand",
    "replacement": "在 '?:' 中省略的中间操作数将一律是 'true'，建议显式给出中间操作数"
  },
  {
    "id": "assignment of member %qD in read-only object",
    "pattern": "assignment of member '(.+?)' in read-only object",
    "replacement": "向只读对象的成员 '$1' 赋值"
  },
  {
    "id": "increment of member %qD in read-only object",
    "pattern": "increment of member '(.+?)' in read-only object",
    "replacement": "令只读对象的成员 '$1' 自增"
  },
  {
    "id": "decrement of member %qD in read-only object",
    "pattern": "decrement of member '(.+?)' in read-only object",
    "replacement": "令只读对象的成员 '$1' 自减"
  },
  {
    "id": "member %qD in read-only object used as %<asm%> output",
    "pattern": "member '(.+?)' in read-only object used as 'asm' output",
    "replacement": "只读对象的成员 '$1' 用作 'asm' 的输出"
  },
  {
    "id": "assignment of read-only member %qD",
    "pattern": "assignment of read-only member '(.+?)'",
    "replacement": "向只读成员 '$1' 赋值"
  },
  {
    "id": "increment of read-only member %qD",
    "pattern": "increment of read-only member '(.+?)'",
    "replacement": "令只读成员 '$1' 自增"
  },
  {
    "id": "decrement of read-only member %qD",
    "pattern": "decrement of read-only member '(.+?)'",
    "replacement": "令只读成员 '$1' 自减"
  },
  {
    "id": "read-only member %qD used as %<asm%> output",
    "pattern": "read-only member '(.+?)' used as 'asm' output",
    "replacement": "只读成员 '$1' 用作 'asm' 的输出"
  },
  {
    "id": "assignment of read-only variable %qD",
    "pattern": "assignment of read-only variable '(.+?)'",
    "replacement": "向只读变量 '$1' 赋值"
  },
  {
    "id": "increment of read-only variable %qD",
    "pattern": "increment of read-only variable '(.+?)'",
    "replacement": "令只读变量 '$1' 自增"
  },
  {
    "id": "decrement of read-only variable %qD",
    "pattern": "decrement of read-only variable '(.+?)'",
    "replacement": "令只读成员 '$1' 自增"
  },
  {
    "id": "read-only variable %qD used as %<asm%> output",
    "pattern": "read-only variable '(.+?)' used as 'asm' output",
    "replacement": "只读变量 '$1' 被用作 'asm' 的输出"
  },
  {
    "id": "assignment of read-only parameter %qD",
    "pattern": "assignment of read-only parameter '(.+?)'",
    "replacement": "向只读形参 '$1' 赋值"
  },
  {
    "id": "increment of read-only parameter %qD",
    "pattern": "increment of read-only parameter '(.+?)'",
    "replacement": "令只读形参 '$1' 自增"
  },
  {
    "id": "decrement of read-only parameter %qD",
    "pattern": "decrement of read-only parameter '(.+?)'",
    "replacement": "令只读形参 '$1' 自减"
  },
  {
    "id": "read-only parameter %qD use as %<asm%> output",
    "pattern": "read-only parameter '(.+?)' use as 'asm' output",
    "replacement": "只读变量 '$1' 被用作 'asm' 的输出"
  },
  {
    "id": "assignment of read-only named return value %qD",
    "pattern": "assignment of read-only named return value '(.+?)'",
    "replacement": "向只读具名返回值 '$1' 赋值"
  },
  {
    "id": "increment of read-only named return value %qD",
    "pattern": "increment of read-only named return value '(.+?)'",
    "replacement": "令只读具名返回值 '$1' 自增"
  },
  {
    "id": "decrement of read-only named return value %qD",
    "pattern": "decrement of read-only named return value '(.+?)'",
    "replacement": "令只读具名返回值 '$1' 自减"
  },
  {
    "id": "read-only named return value %qD used as %<asm%>output",
    "pattern": "read-only named return value '(.+?)' used as 'asm'output",
    "replacement": "只读具名返回值 '$1' 被用作 'asm' 的输出"
  },
  {
    "id": "assignment of function %qD",
    "pattern": "assignment of function '(.+?)'",
    "replacement": "向函数 '$1' 赋值"
  },
  {
    "id": "increment of function %qD",
    "pattern": "increment of function '(.+?)'",
    "replacement": "令函数 '$1' 自增"
  },
  {
    "id": "decrement of function %qD",
    "pattern": "decrement of function '(.+?)'",
    "replacement": "令函数 '$1' 自减"
  },
  {
    "id": "function %qD used as %<asm%> output",
    "pattern": "function '(.+?)' used as 'asm' output",
    "replacement": "函数 '$1' 用作 'asm' 的输出"
  },
  {
    "id": "assignment of read-only location %qE",
    "pattern": "assignment of read-only location '(.+?)'",
    "replacement": "向只读位置 '$1' 赋值"
  },
  {
    "id": "increment of read-only location %qE",
    "pattern": "increment of read-only location '(.+?)'",
    "replacement": "令只读位置 '$1' 自增"
  },
  {
    "id": "decrement of read-only location %qE",
    "pattern": "decrement of read-only location '(.+?)'",
    "replacement": "令只读位置 '$1' 自减"
  },
  {
    "id": "read-only location %qE used as %<asm%> output",
    "pattern": "read-only location '(.+?)' used as 'asm' output",
    "replacement": "只读位置 '$1' 用作'asm'的输出"
  },
  {
    "id": "lvalue required as left operand of assignment",
    "pattern": "lvalue required as left operand of assignment",
    "replacement": "赋值运算的左操作数必须是左值"
  },
  {
    "id": "lvalue required as increment operand",
    "pattern": "lvalue required as increment operand",
    "replacement": "自增操作数必须是左值"
  },
  {
    "id": "lvalue required as decrement operand",
    "pattern": "lvalue required as decrement operand",
    "replacement": "自减操作数必须是左值"
  },
  {
    "id": "lvalue required as unary %<&%> operand",
    "pattern": "lvalue required as unary '&' operand",
    "replacement": "一元 '&' 的操作数必须是左值"
  },
  {
    "id": "lvalue required in %<asm%> statement",
    "pattern": "lvalue required in 'asm' statement",
    "replacement": "'asm' 语句中需要左值"
  },
  {
    "id": "invalid type argument (have %qT)",
    "pattern": "invalid type argument \\(have '(.+?)'\\)",
    "replacement": "实参类型 '$1' 无效"
  },
  {
    "id": "invalid type argument of array indexing (have %qT)",
    "pattern": "invalid type argument of array indexing \\(have '(.+?)'\\)",
    "replacement": "数组索引实参类型 '$1' 无效"
  },
  {
    "id": "invalid type argument of unary %<*%> (have %qT)",
    "pattern": "invalid type argument of unary '\\*' \\(have '(.+?)'\\)",
    "replacement": "一元 '*' 实参类型 '$1' 无效"
  },
  {
    "id": "invalid type argument of %<->%> (have %qT)",
    "pattern": "invalid type argument of '->' \\(have '(.+?)'\\)",
    "replacement": "'->' 实参类型 '$1' 无效"
  },
  {
    "id": "invalid type argument of %<->*%> (have %qT)",
    "pattern": "invalid type argument of '->\\*' \\(have '(.+?)'\\)",
    "replacement": "'->*' 实参类型 '$1' 无效"
  },
  {
    "id": "invalid type argument of implicit conversion (have %qT)",
    "pattern": "invalid type argument of implicit conversion \\(have '(.+?)'\\)",
    "replacement": "隐式转换实参类型 '$1' 无效"
  },
  {
    "id": "array subscript has type %<char%>",
    "pattern": "array subscript has type 'char'",
    "replacement": "数组下标类型为 'char'"
  },
  {
    "id": "suggest parentheses around %<+%> inside %<<<%>",
    "pattern": "suggest parentheses around '\\+' inside '<<'",
    "replacement": "建议在 '<<' 的操作数中出现的 '+' 前后加上括号"
  },
  {
    "id": "suggest parentheses around %<-%> inside %<<<%>",
    "pattern": "suggest parentheses around '-' inside '<<'",
    "replacement": "建议在 '<<' 的操作数中出现的 '-' 前后加上括号"
  },
  {
    "id": "suggest parentheses around %<+%> inside %<>>%>",
    "pattern": "suggest parentheses around '\\+' inside '>>'",
    "replacement": "建议在 '>>' 的操作数中出现的 '+' 前后加上括号"
  },
  {
    "id": "suggest parentheses around %<-%> inside %<>>%>",
    "pattern": "suggest parentheses around '-' inside '>>'",
    "replacement": "建议在 '>>' 的操作数中出现的 '-' 前后加上括号"
  },
  {
    "id": "suggest parentheses around %<&&%> within %<||%>",
    "pattern": "suggest parentheses around '&&' within '\\|\\|'",
    "replacement": "建议在 '||' 的操作数中出现的 '&&' 前后加上括号"
  },
  {
    "id": "suggest parentheses around arithmetic in operand of %<|%>",
    "pattern": "suggest parentheses around arithmetic in operand of '\\|'",
    "replacement": "建议在 '|' 的操作数中的算术表达式前后加上括号"
  },
  {
    "id": "suggest parentheses around comparison in operand of %<|%>",
    "pattern": "suggest parentheses around comparison in operand of '\\|'",
    "replacement": "建议在 '|' 的操作数中的比较表达式前后加上括号"
  },
  {
    "id": "suggest parentheses around operand of %<!%> or change %<|%> to %<||%> or %<!%> to %<~%>",
    "pattern": "suggest parentheses around operand of '!' or change '\\|' to '\\|\\|' or '!' to '~'",
    "replacement": "建议在 '!' 的操作数周围加上括号，或将 '|' 改为 '||'，或将 '!' 改为 '~'"
  },
  {
    "id": "suggest parentheses around arithmetic in operand of %<^%>",
    "pattern": "suggest parentheses around arithmetic in operand of '\\^'",
    "replacement": "建议在 '^' 的操作数中的算术表达式前后加上括号"
  },
  {
    "id": "suggest parentheses around comparison in operand of %<^%>",
    "pattern": "suggest parentheses around comparison in operand of '\\^'",
    "replacement": "建议在 '^' 的操作数中的比较表达式前后加上括号"
  },
  {
    "id": "suggest parentheses around %<+%> in operand of %<&%>",
    "pattern": "suggest parentheses around '\\+' in operand of '&'",
    "replacement": "建议在 '&' 的操作数中出现的 '+' 前后加上括号"
  },
  {
    "id": "suggest parentheses around %<-%> in operand of %<&%>",
    "pattern": "suggest parentheses around '-' in operand of '&'",
    "replacement": "建议在 '&' 的操作数中出现的 '-' 前后加上括号"
  },
  {
    "id": "suggest parentheses around comparison in operand of %<&%>",
    "pattern": "suggest parentheses around comparison in operand of '&'",
    "replacement": "建议在 '&' 的操作数中的比较表达式前后加上括号"
  },
  {
    "id": "suggest parentheses around operand of %<!%> or change %<&%> to %<&&%> or %<!%> to %<~%>",
    "pattern": "suggest parentheses around operand of '!' or change '&' to '&&' or '!' to '~'",
    "replacement": "建议在 '!' 的操作数周围加上括号，或将 '&' 改为 '&&' ，或将 '!' 改为 '~'"
  },
  {
    "id": "suggest parentheses around comparison in operand of %<==%>",
    "pattern": "suggest parentheses around comparison in operand of '=='",
    "replacement": "建议在 '==' 的操作数的比较表达式前后加上括号"
  },
  {
    "id": "suggest parentheses around comparison in operand of %<!=%>",
    "pattern": "suggest parentheses around comparison in operand of '!='",
    "replacement": "建议在 '!=' 的操作数的比较前后加上括号"
  },
  {
    "id": "comparisons like %<X<=Y<=Z%> do not have their mathematical meaning",
    "pattern": "comparisons like 'X<=Y<=Z' do not have their mathematical meaning",
    "replacement": "形如 'X<=Y<=Z' 的比较并不具备其在数学上的意义"
  },
  {
    "id": "label %q+D defined but not used",
    "pattern": "label '(.+?)' defined but not used",
    "replacement": "标号 '$1' 定义后未使用"
  },
  {
    "id": "label %q+D declared but not defined",
    "pattern": "label '(.+?)' declared but not defined",
    "replacement": "标号 '$1' 声明后未定义"
  },
  {
    "id": "division by zero",
    "pattern": "division by zero",
    "replacement": "除以零"
  },
  {
    "id": "%<memset%> used with constant zero length parameter; this could be due to transposed parameters",
    "pattern": "'memset' used with constant zero length parameter; this could be due to transposed parameters",
    "replacement": "使用 'memset' 时，长度形参恒为零；这可能是形参错位造成的"
  },
  {
    "id": "%<memset%> used with length equal to number of elements without multiplication by element size",
    "pattern": "'memset' used with length equal to number of elements without multiplication by element size",
    "replacement": "使用 'memset' 时，长度形参等于元素个数，却没有乘每个元素的大小"
  },
  {
    "id": "comparison between types %qT and %qT",
    "pattern": "comparison between types '(.+?)' and '(.+?)'",
    "replacement": "类型 '$1' 和 '$2' 间的比较"
  },
  {
    "id": "comparison of integer expressions of different signedness: %qT and %qT",
    "pattern": "comparison of integer expressions of different signedness: '(.+?)' and '(.+?)'",
    "replacement": "整数比较表达式两侧符号性不同：'$1' 和 '$2'"
  },
  {
    "id": "promoted bitwise complement of an unsigned value is always nonzero",
    "pattern": "promoted bitwise complement of an unsigned value is always nonzero",
    "replacement": "取反后又经提升的无符号数总是非零值"
  },
  {
    "id": "comparison of promoted bitwise complement of an unsigned value with constant",
    "pattern": "comparison of promoted bitwise complement of an unsigned value with constant",
    "replacement": "比较常量和取反后又经提升的无符号数"
  },
  {
    "id": "comparison of promoted bitwise complement of an unsigned value with unsigned",
    "pattern": "comparison of promoted bitwise complement of an unsigned value with unsigned",
    "replacement": "比较无符号数和取反后又经提升的无符号数"
  },
  {
    "id": "unused parameter %qD",
    "pattern": "unused parameter '(.+?)'",
    "replacement": "未使用的形参 '$1'"
  },
  {
    "id": "typedef %qD locally defined but not used",
    "pattern": "typedef '(.+?)' locally defined but not used",
    "replacement": "typedef 名 '$1' 在局部被定义却未使用"
  },
  {
    "id": "duplicated %<if%> condition",
    "pattern": "duplicated 'if' condition",
    "replacement": "重复的 'if' 条件"
  },
  {
    "id": "optimization attribute on %qD follows definition but the attribute doesn%'t match",
    "pattern": "optimization attribute on '(.+?)' follows definition but the attribute doesn't match",
    "replacement": "紧随 '$1' 的优化特性的定义，但该特性不匹配定义"
  },
  {
    "id": "inline declaration of %qD follows declaration with attribute %<noinline%>",
    "pattern": "inline declaration of '(.+?)' follows declaration with attribute 'noinline'",
    "replacement": "'$1' 的内联声明后紧随带有特性 'noinline' 的声明"
  },
  {
    "id": "declaration of %q+D with attribute %<noinline%> follows inline declaration",
    "pattern": "declaration of '(.+?)' with attribute 'noinline' follows inline declaration",
    "replacement": "'$1' 的带 'noinline' 特性的声明后紧随内联声明"
  },
  {
    "id": "result of %qE requires %u bits to represent, but %qT only has %u bits",
    "pattern": "result of '(.+?)' requires (\\d+) bits to represent, but '(.+?)' only has (\\d+) bits",
    "replacement": "'$1' 的结果需要 $2 比特来表示，但 '$3' 只有 $4 比特"
  },
  {
    "id": "comparison of constant %qE with boolean expression is always false",
    "pattern": "comparison of constant '(.+?)' with boolean expression is always false",
    "replacement": "常量 '$1' 与布尔表达式的比较总是得到假"
  },
  {
    "id": "comparison of constant %qE with boolean expression is always true",
    "pattern": "comparison of constant '(.+?)' with boolean expression is always true",
    "replacement": "常量 '$1' 与布尔表达式的比较总是得到真"
  },
  {
    "id": "passing argument %i to %qs-qualified parameter aliases with argument %Z",
    "pattern": "passing argument (\\d+) to '(.+?)'-qualified parameter aliases with arguments? (.*?)",
    "replacement": "传递第 $1 个实参到 '$2' 限定的形参，同时它也是第 $3 个实参的别名"
  },
  {
    "id": "this condition has identical branches",
    "pattern": "this condition has identical branches",
    "replacement": "此条件有等价的分支"
  },
  {
    "id": "macro expands to multiple statements",
    "pattern": "macro expands to multiple statements",
    "replacement": "宏展开为多条语句"
  },
  {
    "id": "some parts of macro expansion are not guarded by this %qs clause",
    "pattern": "some parts of macro expansion are not guarded by this '(.+?)' clause",
    "replacement": "宏展开的某一部分没有被 '$1' 子句管控"
  },
  {
    "id": "converting a packed %qT pointer (alignment %d) to a %qT pointer (alignment %d) may result in an unaligned pointer value",
    "pattern": "converting a packed '(.+?)' pointer \\(alignment (\\d+)\\) to a '(.+?)' pointer \\(alignment (\\d+)\\) may result in an unaligned pointer value",
    "replacement": "转换一个紧实的 '$1' 指针（对齐 $2）到一个 '$3' 指针（对齐 $4）可能形成未对齐的指针值"
  },
  {
    "id": "defined here",
    "pattern": "defined here",
    "replacement": "在此定义"
  },
  {
    "id": "taking address of packed member of %qT may result in an unaligned pointer value",
    "pattern": "taking address of packed member of '(.+?)' may result in an unaligned pointer value",
    "replacement": "对 '$1' 紧实的成员取地址可能形成未对齐的指针值"
  },
  {
    "id": "mismatch in bound %Z of argument %u declared as %s",
    "pattern": "mismatch in bounds? (.*?) of argument (\\d+) declared as (.*?)",
    "replacement": "声明为 $3 的第 $2 个实参的界 $1 不匹配"
  },
  {
    "id": "previously declared as %s",
    "pattern": "previously declared as (.*?)",
    "replacement": "之前声明为 $1"
  },
  {
    "id": "argument %u of type %s declared as a variable length array",
    "pattern": "argument (\\d+) of type (.*?) declared as a variable length array",
    "replacement": "$2 类型的第 $1 个实参被声明为变长数组"
  },
  {
    "id": "previously declared as a pointer %s",
    "pattern": "previously declared as a pointer (.*?)",
    "replacement": "之前声明为指针 $1"
  },
  {
    "id": "previously declared as an ordinary array %s",
    "pattern": "previously declared as an ordinary array (.*?)",
    "replacement": "之前声明为普通数组 $1"
  },
  {
    "id": "argument %u of type %s declared as a pointer",
    "pattern": "argument (\\d+) of type (.*?) declared as a pointer",
    "replacement": "$2 类型的第 $1 个实参被声明为指针"
  },
  {
    "id": "previously declared as a variable length array %s",
    "pattern": "previously declared as a variable length array (.*?)",
    "replacement": "之前声明为变长数组 $1"
  },
  {
    "id": "previously declared as an array %s",
    "pattern": "previously declared as an array (.*?)",
    "replacement": "之前声明为数组 $1"
  },
  {
    "id": "argument %u of type %s declared as an ordinary array",
    "pattern": "argument (\\d+) of type (.*?) declared as an ordinary array",
    "replacement": "$2 类型的第 $1 个实参被声明为普通数组"
  },
  {
    "id": "argument %u of type %s declared with %u variable bound",
    "pattern": "argument (\\d+) of type (.*?) declared with (\\d+) variable bounds?",
    "replacement": "$2 类型的第 $1 个实参被声明为有 $3 个变量的边界"
  },
  {
    "id": "previously declared as %s with %u variable bound",
    "pattern": "previously declared as (.*?) with (\\d+) variable bounds?",
    "replacement": "之前声明为 $1，有 $2 个变量的边界"
  },
  {
    "id": "argument %u of type %s declared with %u unspecified variable bound",
    "pattern": "argument (\\d+) of type (.*?) declared with (\\d+) unspecified variable bounds?",
    "replacement": "$2 类型的第 $1 个实参被声明为有 $3 个未指明的变量的边界"
  },
  {
    "id": "previously declared as %s with %u unspecified variable bound",
    "pattern": "previously declared as (.*?) with (\\d+) unspecified variable bounds?",
    "replacement": "之前声明为 $1，有 $2 个未指明的变量的边界"
  },
  {
    "id": "subsequently declared as %s with %u unspecified variable bound",
    "pattern": "subsequently declared as (.*?) with (\\d+) unspecified variable bounds?",
    "replacement": "后来声明为 $1，有 $2 个未指明的变量的边界"
  },
  {
    "id": "argument %u of type %s declared with mismatched bound argument %E",
    "pattern": "argument (\\d+) of type (.*?) declared with mismatched bound argument (.*?)",
    "replacement": "$2 类型的第 $1 个实参被声明为不匹配的边界实参 $3"
  },
  {
    "id": "argument %u of type %s declared with mismatched bound %<%s%>",
    "pattern": "argument (\\d+) of type (.*?) declared with mismatched bound '(.+?)'",
    "replacement": "$2 类型的第 $i 个实参被声明为不匹配的边界 '$3'"
  },
  {
    "id": "previously declared as %s with bound argument %E",
    "pattern": "previously declared as (.*?) with bound argument (.*?)",
    "replacement": "之前声明为 $1，有边界实参 $2"
  },
  {
    "id": "previously declared as %s with bound %<%s%>",
    "pattern": "previously declared as (.*?) with bound '(.+?)'",
    "replacement": "之前声明为 $1，有边界 '$2'"
  },
  {
    "id": "argument %u of type %s with mismatched bound",
    "pattern": "argument (\\d+) of type (.*?) with mismatched bound",
    "replacement": "$2 类型的第 $1 个实参被声明为不匹配的边界"
  },
  {
    "id": "expression does not compute the number of elements in this array; element type is %qT, not %qT",
    "pattern": "expression does not compute the number of elements in this array; element type is '(.+?)', not '(.+?)'",
    "replacement": "表达式并不计算数组中元素的个数；元素类型是 '$1'，不是 '$2'"
  },
  {
    "id": "add parentheses around %qE to silence this warning",
    "pattern": "add parentheses around '(.+?)' to silence this warning",
    "replacement": "在 '$1' 两侧加上括号来避免显示此警告"
  },
  {
    "id": "add parentheses around the second %<sizeof%> to silence this warning",
    "pattern": "add parentheses around the second 'sizeof' to silence this warning",
    "replacement": "在第二个 'sizeof' 两侧加上括号来避免显示此警告"
  },
  {
    "id": "%qs is not a valid option to the preprocessor",
    "pattern": "'(.+?)' is not a valid option to the preprocessor",
    "replacement": "'$1' 对于预处理器是无效选项"
  },
  {
    "id": "too many input files",
    "pattern": "too many input files",
    "replacement": "输入文件太多"
  },
  {
    "id": "void value not ignored as it ought to be",
    "pattern": "void value not ignored as it ought to be",
    "replacement": "void 值未如预期地被忽略"
  },
  {
    "id": "label %q+D used but not defined",
    "pattern": "label '(.+?)' used but not defined",
    "replacement": "标号 '$1' 使用前未定义"
  },
  {
    "id": "variable %qD set but not used",
    "pattern": "variable '(.+?)' set but not used",
    "replacement": "变量 '$1' 被设定但未使用"
  },
  {
    "id": "declaration of %qD shadows a global declaration",
    "pattern": "declaration of '(.+?)' shadows a global declaration",
    "replacement": "'$1' 的声明隐藏了一个全局声明"
  },
  {
    "id": "shadowed declaration is here",
    "pattern": "shadowed declaration is here",
    "replacement": "被隐藏的声明在此处"
  },
  {
    "id": "label %qE referenced outside of any function",
    "pattern": "label '(.+?)' referenced outside of any function",
    "replacement": "标号 '$1' 在所有函数外被引用"
  },
  {
    "id": "duplicate label %qD",
    "pattern": "duplicate label '(.+?)'",
    "replacement": "重复的标号 '$1'"
  },
  {
    "id": "%qE attribute applied to %qD with void return type",
    "pattern": "'(.+?)' attribute applied to '(.+?)' with void return type",
    "replacement": "'$1' 特性应用于 void 返回类型的 '$2' 上"
  },
  {
    "id": "%q+D in declare target directive does not have mappable type",
    "pattern": "'(.+?)' in declare target directive does not have mappable type",
    "replacement": "声明目标指令中的 '$1' 不具有可映射类型"
  },
  {
    "id": "storage class specified for typename",
    "pattern": "storage class specified for typename",
    "replacement": "为类型名指定了存储类"
  },
  {
    "id": "type qualifiers ignored on function return type",
    "pattern": "type qualifiers ignored on function return type",
    "replacement": "忽略函数返回类型的类型限定符"
  },
  {
    "id": "variable or field %qE declared void",
    "pattern": "variable or field '(.+?)' declared void",
    "replacement": "变量或字段 '$1' 声明为 void"
  },
  {
    "id": "declaration does not declare anything",
    "pattern": "declaration does not declare anything",
    "replacement": "声明没有声明任何东西"
  },
  {
    "id": "flexible array member in union",
    "pattern": "flexible array member in union",
    "replacement": "联合体中的柔性数组成员"
  },
  {
    "id": "specified mode too small for enumerated values",
    "pattern": "specified mode too small for enumerated values",
    "replacement": "指定的模式对枚举值来说太小"
  },
  {
    "id": "inline function %qD given attribute %qs",
    "pattern": "inline function '(.+?)' given attribute '(.+?)'",
    "replacement": "内联函数 '$1' 给定了特性 '$1'"
  },
  {
    "id": "no previous declaration for %qD",
    "pattern": "no previous declaration for '(.+?)'",
    "replacement": "'$1' 没有之前的声明"
  },
  {
    "id": "no return statement in function returning non-void",
    "pattern": "no return statement in function returning non-void",
    "replacement": "返回类型非 void 的函数中没有 return 语句"
  },
  {
    "id": "parameter %qD set but not used",
    "pattern": "parameter '(.+?)' set but not used",
    "replacement": "形参 '$1' 被设定但未使用"
  },
  {
    "id": "%<long long long%> is too long for GCC",
    "pattern": "'long long long' is too long for GCC",
    "replacement": "'long long long' 对 GCC 来说太长了"
  },
  {
    "id": "%<#pragma omp declare reduction%> combiner refers to variable %qD which is not %<omp_out%> nor %<omp_in%>",
    "pattern": "'#pragma omp declare reduction' combiner refers to variable '(.+?)' which is not 'omp_out' nor 'omp_in'",
    "replacement": "'#pragma omp declare reduction' 比较器指示了既不是 'omp_out' 也不是 'omp_in' 的变量 '$1'"
  },
  {
    "id": "%<#pragma omp declare reduction%> initializer refers to variable %qD which is not %<omp_priv%> nor %<omp_orig%>",
    "pattern": "'#pragma omp declare reduction' initializer refers to variable '(.+?)' which is not 'omp_priv' nor 'omp_orig'",
    "replacement": "'#pragma omp declare reduction' 初始化器指示了既不是 'omp_priv' 也不是 'omp_orig' 的变量 '$1'"
  },
  {
    "id": "left shift of negative value",
    "pattern": "left shift of negative value",
    "replacement": "左移次数为负"
  },
  {
    "id": "left shift count is negative",
    "pattern": "left shift count is negative",
    "replacement": "左移次数为负"
  },
  {
    "id": "right shift count is negative",
    "pattern": "right shift count is negative",
    "replacement": "右移次数为负"
  },
  {
    "id": "left shift count >= width of type",
    "pattern": "left shift count >= width of type",
    "replacement": "左移次数大于或等于类型宽度"
  },
  {
    "id": "right shift count >= width of type",
    "pattern": "right shift count >= width of type",
    "replacement": "右移次数大于或等于类型宽度"
  },
  {
    "id": "version control conflict marker in file",
    "pattern": "version control conflict marker in file",
    "replacement": "文件中出现版本控制冲突标记"
  },
  {
    "id": "to match this %qs",
    "pattern": "to match this '(.+?)'",
    "replacement": "为了匹配这个 '$1'"
  },
  {
    "id": "expected end of line",
    "pattern": "expected end of line",
    "replacement": "期望行尾"
  },
  {
    "id": "%<#pragma omp declare target%> without corresponding %<#pragma omp end declare target%>",
    "pattern": "'#pragma omp declare target' without corresponding '#pragma omp end declare target'",
    "replacement": "'#pragma omp declare target' 缺少相应的 '#pragma omp end declare target'"
  },
  {
    "id": "expected declaration specifiers",
    "pattern": "expected declaration specifiers",
    "replacement": "期望声明说明符"
  },
  {
    "id": "prefix attributes are ignored for methods",
    "pattern": "prefix attributes are ignored for methods",
    "replacement": "方法的前缀特性被忽略"
  },
  {
    "id": "%<fallthrough%> attribute not followed by %<;%>",
    "pattern": "'fallthrough' attribute not followed by ';'",
    "replacement": "'fallthrough' 特性不跟在 ';' 后面"
  },
  {
    "id": "expected %<,%> or %<;%>",
    "pattern": "expected ',' or ';'",
    "replacement": "期望 ',' 或 ';'"
  },
  {
    "id": "static assertion failed",
    "pattern": "static assertion failed",
    "replacement": "静态断言失败"
  },
  {
    "id": "expected identifier",
    "pattern": "expected identifier",
    "replacement": "期望标识符"
  },
  {
    "id": "comma at end of enumerator list",
    "pattern": "comma at end of enumerator list",
    "replacement": "枚举项列表以逗号结尾"
  },
  {
    "id": "%qE attribute does not take any arguments",
    "pattern": "'(.+?)' attribute does not take any arguments",
    "replacement": "'$1' 特性未得到任何实参"
  },
  {
    "id": "%<else%> without a previous %<if%>",
    "pattern": "'else' without a previous 'if'",
    "replacement": "'else' 之前没有 'if'"
  },
  {
    "id": "expected statement",
    "pattern": "expected statement",
    "replacement": "期望语句"
  },
  {
    "id": "suggest braces around empty body in an %<if%> statement",
    "pattern": "suggest braces around empty body in an 'if' statement",
    "replacement": "建议在 'if' 的空语句体周围加上花括号"
  },
  {
    "id": "suggest braces around empty body in an %<else%> statement",
    "pattern": "suggest braces around empty body in an 'else' statement",
    "replacement": "建议在 'else' 的空语句体周围加上花括号"
  },
  {
    "id": "suggest explicit braces to avoid ambiguous %<else%>",
    "pattern": "suggest explicit braces to avoid ambiguous 'else'",
    "replacement": "建议显式地使用花括号以避免出现有歧义的 'else'"
  },
  {
    "id": "missing loop condition in loop with %<GCC ivdep%> pragma",
    "pattern": "missing loop condition in loop with 'GCC ivdep' pragma",
    "replacement": "带 'GCC ivdep' pragma 的循环缺失循环条件"
  },
  {
    "id": "missing loop condition in loop with %<GCC unroll%> pragma",
    "pattern": "missing loop condition in loop with 'GCC unroll' pragma",
    "replacement": "带 'GCC unroll' pragma 的循环缺失循环条件"
  },
  {
    "id": "first seen here",
    "pattern": "first seen here",
    "replacement": "第一次在这里被看见"
  },
  {
    "id": "a wide string is invalid in this context",
    "pattern": "a wide string is invalid in this context",
    "replacement": "此语境中宽字符串无效"
  },
  {
    "id": "division %<sizeof (%T) / sizeof (%T)%> does not compute the number of array elements",
    "pattern": "division 'sizeof \\((.*?)\\) / sizeof \\((.*?)\\)' does not compute the number of array elements",
    "replacement": "除法 'sizeof ($1) / sizeof ($2)' 并不计算数组中元素的个数"
  },
  {
    "id": "first %<sizeof%> operand was declared here",
    "pattern": "first 'sizeof' operand was declared here",
    "replacement": "第一个 'sizeof' 操作数在此声明"
  },
  {
    "id": "wrong number of arguments to %<__builtin_shuffle%>",
    "pattern": "wrong number of arguments to '__builtin_shuffle'",
    "replacement": "穿肚给函数 '__builtin_shuffle' 的实参个数错误"
  },
  {
    "id": "empty property attribute list",
    "pattern": "empty property attribute list",
    "replacement": "空属性的特性列表"
  },
  {
    "id": "missing property attribute",
    "pattern": "missing property attribute",
    "replacement": "缺少属性的特性"
  },
  {
    "id": "unknown property attribute",
    "pattern": "unknown property attribute",
    "replacement": "未知属性的特性"
  },
  {
    "id": "expected %<=%> after Objective-C %qE",
    "pattern": "expected '=' after Objective-C '(.+?)'",
    "replacement": "在 Objective-C++ '$1' 后期望 '='"
  },
  {
    "id": "expected %qE selector name",
    "pattern": "expected '(.+?)' selector name",
    "replacement": "期望 '$1' 选择器名字"
  },
  {
    "id": "setter method names must terminate with %<:%>",
    "pattern": "setter method names must terminate with ':'",
    "replacement": "setter 的名字必须以 ':' 结束"
  },
  {
    "id": "%<#pragma GCC unroll%> requires an assignment-expression that evaluates to a non-negative integral constant less than %u",
    "pattern": "'#pragma GCC unroll' requires an assignment-expression that evaluates to a non-negative integral constant less than (\\d+)",
    "replacement": "'#pragma GCC unroll' 需要一个赋值表达式，它求值为小于 $1 的非负整数常量"
  },
  {
    "id": "%<#pragma %s%> may only be used in compound statements",
    "pattern": "'#pragma (.*?)' may only be used in compound statements",
    "replacement": "'#pragma $1' 只能用在复合语句中"
  },
  {
    "id": "%<#pragma acc routine%> must be at file scope",
    "pattern": "'#pragma acc routine' must be at file scope",
    "replacement": "'#pragma acc routine' 只能出现在文件作用域中"
  },
  {
    "id": "%<#pragma omp scan%> may only be used in a loop construct with %<inscan%> %<reduction%> clause",
    "pattern": "'#pragma omp scan' may only be used in a loop construct with 'inscan' 'reduction' clause",
    "replacement": "'#pragma omp scan' 只能出现在带有 'inscan' 'reduction' 子句的循环结构中"
  },
  {
    "id": "%<#pragma omp section%> may only be used in %<#pragma omp sections%> construct",
    "pattern": "'#pragma omp section' may only be used in '#pragma omp sections' construct",
    "replacement": "'#pragma omp section'只能用在 '#pragma omp sections' 结构中"
  },
  {
    "id": "for, while or do statement expected",
    "pattern": "for, while or do statement expected",
    "replacement": "期望 for、while 或 do 的语句"
  },
  {
    "id": "%<#pragma GCC pch_preprocess%> must be first",
    "pattern": "'#pragma GCC pch_preprocess' must be first",
    "replacement": "'#pragma GCC pch_preprocess' 必须是第一个"
  },
  {
    "id": "too many %qs clauses",
    "pattern": "too many '(.+?)' clauses",
    "replacement": "太多的 '$1' 子句"
  },
  {
    "id": "%qD is not a pointer variable",
    "pattern": "'(.+?)' is not a pointer variable",
    "replacement": "'$1' 不是一个指针变量"
  },
  {
    "id": "collapse argument needs positive constant integer expression",
    "pattern": "collapse argument needs positive constant integer expression",
    "replacement": "折叠实参需要正整常量表达式"
  },
  {
    "id": "expected %<none%> or %<present%>",
    "pattern": "expected 'none' or 'present'",
    "replacement": "期望 'none' 或 'present'"
  },
  {
    "id": "expected %<none%> or %<shared%>",
    "pattern": "expected 'none' or 'shared'",
    "replacement": "期望 'none' 或 'shared'"
  },
  {
    "id": "expected %<data%>, %<update%>, %<enter%> or %<exit%>",
    "pattern": "expected 'data', 'update', 'enter' or 'exit'",
    "replacement": "期望 'data'、'update'、'enter' 或 'exit'"
  },
  {
    "id": "expected %<data%>",
    "pattern": "expected 'data'",
    "replacement": "期望 'data'"
  },
  {
    "id": "too many %<if%> clauses with %qs modifier",
    "pattern": "too many 'if' clauses with '(.+?)' modifier",
    "replacement": "'$1' 修饰符中有太多 'if' 子句"
  },
  {
    "id": "too many %<if%> clauses",
    "pattern": "too many 'if' clauses",
    "replacement": "太多 'if' 子句"
  },
  {
    "id": "too many %<if%> clauses without modifier",
    "pattern": "too many 'if' clauses without modifier",
    "replacement": "太多不带修饰符的 'if' 子句"
  },
  {
    "id": "if any %<if%> clause has modifier, then all %<if%> clauses have to use modifier",
    "pattern": "if any 'if' clause has modifier, then all 'if' clauses have to use modifier",
    "replacement": "若某个 'if' 子句有修饰符，则所有的 'if' 子句都应有修饰符"
  },
  {
    "id": "%<grainsize%> value must be positive",
    "pattern": "'grainsize' value must be positive",
    "replacement": "'grainsize' 值必须为正"
  },
  {
    "id": "%<priority%> value must be non-negative",
    "pattern": "'priority' value must be non-negative",
    "replacement": "'priority' 值必须非负"
  },
  {
    "id": "expected constant integer expression with valid sync-hint value",
    "pattern": "expected constant integer expression with valid sync-hint value",
    "replacement": "期待含有效同步提示值的整数常量表达式"
  },
  {
    "id": "expected %<alloc%>, %<to%>, %<from%>, %<tofrom%>, %<firstprivate%>, %<none%> or %<default%>",
    "pattern": "expected 'alloc', 'to', 'from', 'tofrom', 'firstprivate', 'none' or 'default'",
    "replacement": "期待 'alloc'、'to'、'from'、'tofrom'、'firstprivate'、'none' 或 'default'"
  },
  {
    "id": "expected %<scalar%>, %<aggregate%> or %<pointer%>",
    "pattern": "expected 'scalar', 'aggregate' or 'pointer'",
    "replacement": "期待 'scalar'、'aggregate' 或 'pointer'"
  },
  {
    "id": "too many %<defaultmap%> clauses with %qs category",
    "pattern": "too many 'defaultmap' clauses with '(.+?)' category",
    "replacement": "太多 '$1' 类别的 'defaultmap' 子句"
  },
  {
    "id": "too many %<defaultmap%> clauses with unspecified category",
    "pattern": "too many 'defaultmap' clauses with unspecified category",
    "replacement": "太多未指明类别的 'defaultmap' 子句"
  },
  {
    "id": "%qs expression must be integral",
    "pattern": "'(.+?)' expression must be integral",
    "replacement": "'$1' 表达式必须为整数类型"
  },
  {
    "id": "%qs value must be positive",
    "pattern": "'(.+?)' value must be positive",
    "replacement": "'$1' 值必须为正数"
  },
  {
    "id": "too many %<static%> arguments",
    "pattern": "too many 'static' arguments",
    "replacement": "太多 'static' 实参"
  },
  {
    "id": "unexpected argument",
    "pattern": "unexpected argument",
    "replacement": "意外的实参"
  },
  {
    "id": "%<tile%> argument needs positive integral constant",
    "pattern": "'tile' argument needs positive integral constant",
    "replacement": "'tile' 实参需要正整数常量"
  },
  {
    "id": "expected %<concurrent%>",
    "pattern": "expected 'concurrent'",
    "replacement": "期望 'concurrent'"
  },
  {
    "id": "expected %<teams%>, %<parallel%> or %<thread%>",
    "pattern": "expected 'teams', 'parallel' or 'thread'",
    "replacement": "期望 'teams'、'parallel' 或 'thread'"
  },
  {
    "id": "ordered argument needs positive constant integer expression",
    "pattern": "ordered argument needs positive constant integer expression",
    "replacement": "有序实参需要正整常量表达式"
  },
  {
    "id": "expected %<+%>, %<*%>, %<-%>, %<&%>, %<^%>, %<|%>, %<&&%>, %<||%> or identifier",
    "pattern": "expected '\\+', '\\*', '-', '&', '\\^', '\\|', '&&', '\\|\\|' or identifier",
    "replacement": "期望 '+'、'*'、'-'、'&'、'^'、'|'、'&&'、'||' 或标识符"
  },
  {
    "id": "both %<monotonic%> and %<nonmonotonic%> modifiers specified",
    "pattern": "both 'monotonic' and 'nonmonotonic' modifiers specified",
    "replacement": "同时指明 'monotonic' 和 'nonmonoconic' 修饰符"
  },
  {
    "id": "schedule %<runtime%> does not take a %<chunk_size%> parameter",
    "pattern": "schedule 'runtime' does not take a 'chunk_size' parameter",
    "replacement": "调度 'runtime' 不接受一个 'chunk_size' 形参"
  },
  {
    "id": "schedule %<auto%> does not take a %<chunk_size%> parameter",
    "pattern": "schedule 'auto' does not take a 'chunk_size' parameter",
    "replacement": "调度 'auto' 不接受一个 'chunk_size' 形参"
  },
  {
    "id": "chunk size value must be positive",
    "pattern": "chunk size value must be positive",
    "replacement": "块大小的值必须为正数"
  },
  {
    "id": "invalid schedule kind",
    "pattern": "invalid schedule kind",
    "replacement": "无效的调度类型"
  },
  {
    "id": "%<thread_limit%> value must be positive",
    "pattern": "'thread_limit' value must be positive",
    "replacement": "'thread_limit' 值必须为正数"
  },
  {
    "id": "%<aligned%> clause alignment expression must be positive constant integer expression",
    "pattern": "'aligned' clause alignment expression must be positive constant integer expression",
    "replacement": "'aligned' 子句对齐表达式必须为正整数常量表达式"
  },
  {
    "id": "%<allocate%> clause allocator expression has type %qT rather than %<omp_allocator_handle_t%>",
    "pattern": "'allocate' clause allocator expression has type '(.+?)' rather than 'omp_allocator_handle_t'",
    "replacement": "'allocate' 子句分配器表达式具有类型 '$1' 而非 'omp_allocator_handle_t'"
  },
  {
    "id": "%<iterator%> modifier incompatible with %qs",
    "pattern": "'iterator' modifier incompatible with '(.+?)'",
    "replacement": "'iterator' 修饰符与 '$1' 不兼容"
  },
  {
    "id": "invalid depend kind",
    "pattern": "invalid depend kind",
    "replacement": "无效的调度类别"
  },
  {
    "id": "invalid map kind",
    "pattern": "invalid map kind",
    "replacement": "无效的映射类别"
  },
  {
    "id": "invalid dist_schedule kind",
    "pattern": "invalid dist_schedule kind",
    "replacement": "无效的 dist_schedule 类别"
  },
  {
    "id": "%<detach%> clause event handle has type %qT rather than %<omp_event_handle_t%>",
    "pattern": "'detach' clause event handle has type '(.+?)' rather than 'omp_event_handle_t'",
    "replacement": "'detach' 子句事件句柄具有类型 '$1' 而非 'omp_event_handle_t'"
  },
  {
    "id": "expected %<#pragma acc%> clause",
    "pattern": "expected '#pragma acc' clause",
    "replacement": "需要'#pragma acc'子句"
  },
  {
    "id": "%qs is not valid for %qs",
    "pattern": "'(.+?)' is not valid for '(.+?)'",
    "replacement": "'$1' 对 '$2' 而言无效"
  },
  {
    "id": "clauses in %<simd%> trait should be separated by %<,%>",
    "pattern": "clauses in 'simd' trait should be separated by ','",
    "replacement": "'simd' 特征中的子句应该被 ',' 分隔"
  },
  {
    "id": "%qs must be the first clause of %qs",
    "pattern": "'(.+?)' must be the first clause of '(.+?)'",
    "replacement": "'$1' 必须是 '$2' 中的第一个子句"
  },
  {
    "id": "expected %<#pragma omp%> clause",
    "pattern": "expected '#pragma omp' clause",
    "replacement": "期望 '#pragma omp'子句"
  },
  {
    "id": "no valid clauses specified in %<#pragma acc declare%>",
    "pattern": "no valid clauses specified in '#pragma acc declare'",
    "replacement": "'#pragma acc declare' 中未指明有效的子句"
  },
  {
    "id": "array section in %<#pragma acc declare%>",
    "pattern": "array section in '#pragma acc declare'",
    "replacement": "'#pragma acc declare' 中选择了数组"
  },
  {
    "id": "%qD must be a global variable in %<#pragma acc declare link%>",
    "pattern": "'(.+?)' must be a global variable in '#pragma acc declare link'",
    "replacement": "'#pragma acc declare link' 中 '$1' 必须是全局变量"
  },
  {
    "id": "invalid OpenACC clause at file scope",
    "pattern": "invalid OpenACC clause at file scope",
    "replacement": "文件作用域中无效的 OpenACC 子句"
  },
  {
    "id": "invalid use of %<extern%> variable %qD in %<#pragma acc declare%>",
    "pattern": "invalid use of 'extern' variable '(.+?)' in '#pragma acc declare'",
    "replacement": "'#pragma acc declare' 中非法使用了 'extern' 变量 '$1'"
  },
  {
    "id": "invalid use of %<global%> variable %qD in %<#pragma acc declare%>",
    "pattern": "invalid use of 'global' variable '(.+?)' in '#pragma acc declare'",
    "replacement": "'#pragma acc declare' 中非法使用了 'global' 变量 '$1"
  },
  {
    "id": "%qD must be a variable declared in the same scope as %<#pragma acc declare%>",
    "pattern": "'(.+?)' must be a variable declared in the same scope as '#pragma acc declare'",
    "replacement": "'$1' 必须是声明于 '#pragma acc declare' 同一作用域的变量"
  },
  {
    "id": "variable %qD used more than once with %<#pragma acc declare%>",
    "pattern": "variable '(.+?)' used more than once with '#pragma acc declare'",
    "replacement": "变量 '$1' 使用了 '#pragma acc declare' 多于一次"
  },
  {
    "id": "expected %<data%> after %<#pragma acc %s%>",
    "pattern": "expected 'data' after '#pragma acc (.*?)'",
    "replacement": "'#pragma acc $1' 后期望 'data'"
  },
  {
    "id": "%<#pragma acc %s data%> has no data movement clause",
    "pattern": "'#pragma acc (.*?) data' has no data movement clause",
    "replacement": "'#pragma acc $1 data' 没有数据移动子句"
  },
  {
    "id": "%qE has not been declared",
    "pattern": "'(.+?)' has not been declared",
    "replacement": "'$1' 未声明"
  },
  {
    "id": "%qD does not refer to a function",
    "pattern": "'(.+?)' does not refer to a function",
    "replacement": "'(.+?)' 不指示一个函数"
  },
  {
    "id": "%<#pragma acc routine%> not immediately followed by function declaration or definition",
    "pattern": "'#pragma acc routine' not immediately followed by function declaration or definition",
    "replacement": "'#pragma acc routine' 不得立即出现在函数声明或定义后"
  },
  {
    "id": "%<#pragma acc routine%> not immediately followed by a single function declaration or definition",
    "pattern": "'#pragma acc routine' not immediately followed by a single function declaration or definition",
    "replacement": "'#pragma acc routine' 不得立即出现在单个函数声明或定义后"
  },
  {
    "id": "%<#pragma acc routine%> must be applied before use",
    "pattern": "'#pragma acc routine' must be applied before use",
    "replacement": "'#pragma acc routine' 必须在使用前应用"
  },
  {
    "id": "%<#pragma acc routine%> must be applied before definition",
    "pattern": "'#pragma acc routine' must be applied before definition",
    "replacement": "'#pragma acc routine' 必须在定义前应用"
  },
  {
    "id": "%<#pragma acc update%> must contain at least one %<device%> or %<host%> or %<self%> clause",
    "pattern": "'#pragma acc update' must contain at least one 'device' or 'host' or 'self' clause",
    "replacement": "'#pragma acc update' 必须包含至少一个 'device' 或 'host' 或 'self' 子句"
  },
  {
    "id": "expected %<allocator%>",
    "pattern": "expected 'allocator'",
    "replacement": "期望 'allocator'"
  },
  {
    "id": "%<#pragma omp allocate%> not yet supported",
    "pattern": "'#pragma omp allocate' not yet supported",
    "replacement": "'#pragma omp allocate' 尚不支持"
  },
  {
    "id": "expected %<read%>, %<write%>, %<update%>, or %<capture%> clause",
    "pattern": "expected 'read', 'write', 'update', or 'capture' clause",
    "replacement": "期望 'read'、'write'、'update' 或 'capture' 子句"
  },
  {
    "id": "expected %<read%>, %<write%>, %<update%>, %<capture%>, %<seq_cst%>, %<acq_rel%>, %<release%>, %<relaxed%> or %<hint%> clause",
    "pattern": "expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause",
    "replacement": "期望 'read'、'write'、'update'、'capture'、'seq_cst'、'acq_rel'、'release'、'relaxed' 或 'hint' 子句"
  },
  {
    "id": "too many atomic clauses",
    "pattern": "too many atomic clauses",
    "replacement": "太多的原子子句"
  },
  {
    "id": "too many memory order clauses",
    "pattern": "too many memory order clauses",
    "replacement": "太多的内存顺序子句"
  },
  {
    "id": "%<#pragma omp atomic read%> incompatible with %<acq_rel%> or %<release%> clauses",
    "pattern": "'#pragma omp atomic read' incompatible with 'acq_rel' or 'release' clauses",
    "replacement": "'#pragma omp atomic read' 与 'acq_rel' 或 'release' 子句不兼容"
  },
  {
    "id": "%<#pragma omp atomic write%> incompatible with %<acq_rel%> or %<acquire%> clauses",
    "pattern": "'#pragma omp atomic write' incompatible with 'acq_rel' or 'acquire' clauses",
    "replacement": "'#pragma omp atomic write' 与 'acq_rel' 或 'acquire' 子句不兼容"
  },
  {
    "id": "%<#pragma omp atomic update%> incompatible with %<acq_rel%> or %<acquire%> clauses",
    "pattern": "'#pragma omp atomic update' incompatible with 'acq_rel' or 'acquire' clauses",
    "replacement": "'#pragma omp atomic update' 与 'acq_rel' 或 'acquire' 子句不兼容"
  },
  {
    "id": "invalid form of %<#pragma omp atomic%>",
    "pattern": "invalid form of '#pragma omp atomic'",
    "replacement": "'#pragma omp atomic' 形式无效"
  },
  {
    "id": "invalid operator for %<#pragma omp atomic%>",
    "pattern": "invalid operator for '#pragma omp atomic'",
    "replacement": "'#pragma omp atomic' 运算符无效"
  },
  {
    "id": "%<#pragma omp atomic capture%> uses two different expressions for memory",
    "pattern": "'#pragma omp atomic capture' uses two different expressions for memory",
    "replacement": "'#pragma omp atomic capture' 使用两个不同的变量用于内存"
  },
  {
    "id": "%<depobj%> expression is not lvalue expression",
    "pattern": "'depobj' expression is not lvalue expression",
    "replacement": "'depobj' 表达式不是左值表达式"
  },
  {
    "id": "expected %<in%>, %<out%>, %<inout%> or %<mutexinoutset%>",
    "pattern": "expected 'in', 'out', 'inout' or 'mutexinoutset'",
    "replacement": "期望 'in'、'out'、'inout' 或 'mutexinoutset'"
  },
  {
    "id": "expected %<depend%>, %<destroy%> or %<update%> clause",
    "pattern": "expected 'depend', 'destroy' or 'update' clause",
    "replacement": "期望 'depend'、'destroy' 或 'update' 子句"
  },
  {
    "id": "expected %<acq_rel%>, %<release%> or %<acquire%>",
    "pattern": "expected 'acq_rel', 'release' or 'acquire'",
    "replacement": "期望 'acq_rel', 'release' 或 'acquire'"
  },
  {
    "id": "%<flush%> list specified together with memory order clause",
    "pattern": "'flush' list specified together with memory order clause",
    "replacement": "'flush' 列表与内存顺序子句共同指明"
  },
  {
    "id": "expected %<inclusive%> or %<exclusive%> clause",
    "pattern": "expected 'inclusive' or 'exclusive' clause",
    "replacement": "期望 'inclusive' 或 'exclusive' 子句"
  },
  {
    "id": "expected %<#pragma omp scan%>",
    "pattern": "expected '#pragma omp scan'",
    "replacement": "期望 '#pragma omp scan'"
  },
  {
    "id": "%<ordered%> clause parameter is less than %<collapse%>",
    "pattern": "'ordered' clause parameter is less than 'collapse'",
    "replacement": "'ordered' 子句形参比 'collapse' 小"
  },
  {
    "id": "%<linear%> clause may not be specified together with %<ordered%> clause with a parameter",
    "pattern": "'linear' clause may not be specified together with 'ordered' clause with a parameter",
    "replacement": "'linear' 子句不能和带一个形参的 'ordered' 子句共同指明"
  },
  {
    "id": "for statement expected",
    "pattern": "for statement expected",
    "replacement": "期望 for 语句"
  },
  {
    "id": "expected iteration declaration or initialization",
    "pattern": "expected iteration declaration or initialization",
    "replacement": "期望迭代声明或初始化"
  },
  {
    "id": "collapsed loops not perfectly nested",
    "pattern": "collapsed loops not perfectly nested",
    "replacement": "折叠的循环没有完美地嵌套"
  },
  {
    "id": "iteration variable %qD should not be firstprivate",
    "pattern": "iteration variable '(.+?)' should not be firstprivate",
    "replacement": "迭代变量 '$1' 不应当是 firstprivate"
  },
  {
    "id": "%<ordered%> clause with parameter may not be specified on %qs construct",
    "pattern": "'ordered' clause with parameter may not be specified on '(.+?)' construct",
    "replacement": "带形参的 'ordered' 子句不应在 '$1' 结构中指明"
  },
  {
    "id": "%<#pragma omp ordered%> with %<depend%> clause may only be used in compound statements",
    "pattern": "'#pragma omp ordered' with 'depend' clause may only be used in compound statements",
    "replacement": "带 'depend' 的 '#pragma omp ordered' 子句只能用在复合语句中"
  },
  {
    "id": "expected %<for%> after %qs",
    "pattern": "expected 'for' after '(.+?)'",
    "replacement": "期望 'for' 出现在 '$1' 之后"
  },
  {
    "id": "expected %<point%>",
    "pattern": "expected 'point'",
    "replacement": "期望 'point'"
  },
  {
    "id": "%<#pragma omp target data%> with map-type other than %<to%>, %<from%>, %<tofrom%> or %<alloc%> on %<map%> clause",
    "pattern": "'#pragma omp target data' with map-type other than 'to', 'from', 'tofrom' or 'alloc' on 'map' clause",
    "replacement": "'#pragma omp target data' 带有 map-type，'map' 子句中有 'to'、'from'、'tofrom' 或 'alloc' 除外"
  },
  {
    "id": "%<#pragma omp target data%> must contain at least one %<map%>, %<use_device_ptr%> or %<use_device_addr%> clause",
    "pattern": "'#pragma omp target data' must contain at least one 'map', 'use_device_ptr' or 'use_device_addr' clause",
    "replacement": "'#pragma omp target data' 必须包含 'map'、'use_device_ptr' 或 'use_device_addr' 子句中的至少一个"
  },
  {
    "id": "%<#pragma omp target update%> must contain at least one %<from%> or %<to%> clauses",
    "pattern": "'#pragma omp target update' must contain at least one 'from' or 'to' clauses",
    "replacement": "'#pragma omp target update' 必须包含 'from' 或 'to' 子句中的一个"
  },
  {
    "id": "%<#pragma omp target enter data%> with map-type other than %<to%> or %<alloc%> on %<map%> clause",
    "pattern": "'#pragma omp target enter data' with map-type other than 'to' or 'alloc' on 'map' clause",
    "replacement": "'#pragma omp target enter data' 带有 map-type，'map' 子句中有 'to' 或 'alloc' 除外"
  },
  {
    "id": "%<#pragma omp target enter data%> must contain at least one %<map%> clause",
    "pattern": "'#pragma omp target enter data' must contain at least one 'map' clause",
    "replacement": "'#pragma omp target enter data' 必须包含至少一个 'map' 子句"
  },
  {
    "id": "%<#pragma omp target exit data%> with map-type other than %<from%>, %<release%> or %<delete%> on %<map%> clause",
    "pattern": "'#pragma omp target exit data' with map-type other than 'from', 'release' or 'delete' on 'map' clause",
    "replacement": "'#pragma omp target exit data' 带有 map-type，'map' 子句中有 'from' 'release' 或 'delete' 除外"
  },
  {
    "id": "%<#pragma omp target exit data%> must contain at least one %<map%> clause",
    "pattern": "'#pragma omp target exit data' must contain at least one 'map' clause",
    "replacement": "'#pragma omp target exit data' 必须包含至少一个 'map' 子句"
  },
  {
    "id": "%<#pragma omp target%> with map-type other than %<to%>, %<from%>, %<tofrom%> or %<alloc%> on %<map%> clause",
    "pattern": "'#pragma omp target' with map-type other than 'to', 'from', 'tofrom' or 'alloc' on 'map' clause",
    "replacement": "'#pragma omp target' 带有 map-type，'map' 子句中有 'to' 或 'alloc' 除外"
  },
  {
    "id": "expected trait selector name",
    "pattern": "expected trait selector name",
    "replacement": "期望特征选择器名字"
  },
  {
    "id": "selector %qs not allowed for context selector set %qs",
    "pattern": "selector '(.+?)' not allowed for context selector set '(.+?)'",
    "replacement": "选择器 '$1' 不被语境选择器集 '$2' 允许"
  },
  {
    "id": "selector %qs does not accept any properties",
    "pattern": "selector '(.+?)' does not accept any properties",
    "replacement": "选择器 '$1' 不接受任何属性"
  },
  {
    "id": "score argument must be constant integer expression",
    "pattern": "score argument must be constant integer expression",
    "replacement": "分数实参必须包整数常量表达式"
  },
  {
    "id": "score argument must be non-negative",
    "pattern": "score argument must be non-negative",
    "replacement": "分数实参必须为非负"
  },
  {
    "id": "property must be constant integer expression or string literal",
    "pattern": "property must be constant integer expression or string literal",
    "replacement": "属性必须为整数常量表达式或字符串字面量"
  },
  {
    "id": "expected identifier or string literal",
    "pattern": "expected identifier or string literal",
    "replacement": "期望标识符或字符串字面量"
  },
  {
    "id": "property must be constant integer expression",
    "pattern": "property must be constant integer expression",
    "replacement": "属性必须是整数常量表达式"
  },
  {
    "id": "properties for %<simd%> selector may not be specified in %<metadirective%>",
    "pattern": "properties for 'simd' selector may not be specified in 'metadirective'",
    "replacement": "'simd' 选择器的属性不许被指明为 'metadirective'"
  },
  {
    "id": "expected %<construct%>, %<device%>, %<implementation%> or %<user%>",
    "pattern": "expected 'construct', 'device', 'implementation' or 'user'",
    "replacement": "期望 'construct'、'device'、'implementation' 或 'user'"
  },
  {
    "id": "expected %<match%>",
    "pattern": "expected 'match'",
    "replacement": "期望 'match'"
  },
  {
    "id": "variant %qD and base %qD have incompatible types",
    "pattern": "variant '(.+?)' and base '(.+?)' have incompatible types",
    "replacement": "变体 '$1' 与基 '$2' 类型不兼容"
  },
  {
    "id": "variant %qD is a built-in",
    "pattern": "variant '(.+?)' is a built-in",
    "replacement": "变体 '$1' 是内建的"
  },
  {
    "id": "%<#pragma omp declare %s%> not immediately followed by a single function declaration or definition",
    "pattern": "'#pragma omp declare (.*?)' not immediately followed by a single function declaration or definition",
    "replacement": "'#pragma omp declare $1' 不得立即跟随单个函数声明或定义"
  },
  {
    "id": "%qD specified both in declare target %<link%> and %<to%> clauses",
    "pattern": "'(.+?)' specified both in declare target 'link' and 'to' clauses",
    "replacement": "声明目标 'link' 和 'to' 子句都指明了 '$1'"
  },
  {
    "id": "directive with only %<device_type%> clauses ignored",
    "pattern": "directive with only 'device_type' clauses ignored",
    "replacement": "仅有 'device_type' 子句的指令被忽略"
  },
  {
    "id": "expected %<target%>",
    "pattern": "expected 'target'",
    "replacement": "期望 'target'"
  },
  {
    "id": "expected %<declare%>",
    "pattern": "expected 'declare'",
    "replacement": "期望 'declare'"
  },
  {
    "id": "%<#pragma omp end declare target%> without corresponding %<#pragma omp declare target%>",
    "pattern": "'#pragma omp end declare target' without corresponding '#pragma omp declare target'",
    "replacement": "'#pragma omp end declare target' 缺少相应的 '#pragma omp declare target'"
  },
  {
    "id": "expected %<simd%>, %<reduction%>, %<target%> or %<variant%>",
    "pattern": "expected 'simd', 'reduction', 'target' or 'variant'",
    "replacement": "期望 'simd'、'reduction'、'target' 或 'variant'"
  },
  {
    "id": "expected %<seq_cst%>, %<relaxed%> or %<acq_rel%>",
    "pattern": "expected 'seq_cst', 'relaxed' or 'acq_rel'",
    "replacement": "期望 'seq_cst'、'relaxed' 或 'acq_rel'"
  },
  {
    "id": "expected %<unified_address%>, %<unified_shared_memory%>, %<dynamic_allocators%>, %<reverse_offload%> or %<atomic_default_mem_order%> clause",
    "pattern": "expected 'unified_address', 'unified_shared_memory', 'dynamic_allocators', 'reverse_offload' or 'atomic_default_mem_order' clause",
    "replacement": "期望 'unified_address'、'unified_shared_memory'、'dynamic_allocators'、'reverse_offload' 或 'atomic_default_mem_order' 子句"
  },
  {
    "id": "%qs clause on %<requires%> directive not supported yet",
    "pattern": "'(.+?)' clause on 'requires' directive not supported yet",
    "replacement": "'requires' 指令的 '$1' 子句尚不支持"
  },
  {
    "id": "%qs clause used lexically after first target construct or offloading API",
    "pattern": "'(.+?)' clause used lexically after first target construct or offloading API",
    "replacement": "'$1' 子句词法上在目标构建或卸载 API 后使用"
  },
  {
    "id": "more than one %<atomic_default_mem_order%> clause in a single compilation unit",
    "pattern": "more than one 'atomic_default_mem_order' clause in a single compilation unit",
    "replacement": "单个翻译单元中出现多于一次的 'atomic_default_mem_order' 子句"
  },
  {
    "id": "%<atomic_default_mem_order%> clause used lexically after first %<atomic%> construct without memory order clause",
    "pattern": "'atomic_default_mem_order' clause used lexically after first 'atomic' construct without memory order clause",
    "replacement": "'atomic_default_mem_order' 子句词法上在不带内存顺序子句的首次 'atomic' 构造后使用"
  },
  {
    "id": "%<pragma omp requires%> requires at least one clause",
    "pattern": "'pragma omp requires' requires at least one clause",
    "replacement": "'#pragma omp requires' 要求至少一个子句"
  },
  {
    "id": "%qE declared %<threadprivate%> after first use",
    "pattern": "'(.+?)' declared 'threadprivate' after first use",
    "replacement": "'$1' 在其首次使用后才被声明为 'threadprivate'"
  },
  {
    "id": "automatic variable %qE cannot be %<threadprivate%>",
    "pattern": "automatic variable '(.+?)' cannot be 'threadprivate'",
    "replacement": "自动变量 '$1' 不能是 'threadprivate'"
  },
  {
    "id": "%<threadprivate%> %qE has incomplete type",
    "pattern": "'threadprivate' '(.+?)' has incomplete type",
    "replacement": "'threadprivate' '$1' 是不完整类型"
  },
  {
    "id": "%<__transaction_cancel%> without transactional memory support enabled",
    "pattern": "'__transaction_cancel' without transactional memory support enabled",
    "replacement": "'__transaction_cancel' 而无需 transactional 内存支持已启用"
  },
  {
    "id": "%<__transaction_cancel%> within a %<__transaction_relaxed%>",
    "pattern": "'__transaction_cancel' within a '__transaction_relaxed'",
    "replacement": "'__transaction_cancel'在 '__transaction_relaxed' 之内"
  },
  {
    "id": "%<__transaction_cancel%> not within %<__transaction_atomic%>",
    "pattern": "'__transaction_cancel' not within '__transaction_atomic'",
    "replacement": "'__transaction_cancel'无法在 '__transaction_atomic' 之内"
  },
  {
    "id": "invalid use of void expression",
    "pattern": "invalid use of void expression",
    "replacement": "非法地使用了 void 表达式"
  },
  {
    "id": "invalid use of array with unspecified bounds",
    "pattern": "invalid use of array with unspecified bounds",
    "replacement": "非法地使用了未指定边界的数组"
  },
  {
    "id": "array subscript is not an integer",
    "pattern": "array subscript is not an integer",
    "replacement": "数组下标不是一个整数"
  },
  {
    "id": "%<sizeof%> on array function parameter %qE will return size of %qT",
    "pattern": "'sizeof' on array function parameter '(.+?)' will return size of '(.+?)'",
    "replacement": "对数组函数形参 '$1' 使用 'sizeof' 会返回 '$2' 的大小"
  },
  {
    "id": "comparison with string literal results in unspecified behavior",
    "pattern": "comparison with string literal results in unspecified behavior",
    "replacement": "与字面字符串比较的结果是未指明行为"
  },
  {
    "id": "comparison between pointer and zero character constant",
    "pattern": "comparison between pointer and zero character constant",
    "replacement": "指针和零字符常量的比较"
  },
  {
    "id": "did you mean to dereference the pointer?",
    "pattern": "did you mean to dereference the pointer\\?",
    "replacement": "你的意思是对指针解地址吗？"
  },
  {
    "id": "arithmetic on pointer to an empty aggregate",
    "pattern": "arithmetic on pointer to an empty aggregate",
    "replacement": "对指向空聚合类型的指针做算术运算"
  },
  {
    "id": "in call to %qD, declared here",
    "pattern": "in call to '(.+?)', declared here",
    "replacement": "在 '$1' 的调用中，于此声明"
  },
  {
    "id": "cast to pointer from integer of different size",
    "pattern": "cast to pointer from integer of different size",
    "replacement": "将一个整数转换为大小不同的指针"
  },
  {
    "id": "return type might be a candidate for a format attribute",
    "pattern": "return type might be a candidate for a format attribute",
    "replacement": "返回类型可能是 format 属性的备选"
  },
  {
    "id": "initialization of a flexible array member",
    "pattern": "initialization of a flexible array member",
    "replacement": "对柔性数组成员的初始化"
  },
  {
    "id": "cannot initialize array of %qT from a string literal with type array of %qT",
    "pattern": "cannot initialize array of '(.+?)' from a string literal with type array of '(.+?)'",
    "replacement": "不能从具有 '$2' 的数组类型的字符串字面量初始化 '$1' 的数组"
  },
  {
    "id": "invalid use of non-lvalue array",
    "pattern": "invalid use of non-lvalue array",
    "replacement": "非法地使用了非左值数组"
  },
  {
    "id": "opaque vector types cannot be initialized",
    "pattern": "opaque vector types cannot be initialized",
    "replacement": "不透明的向量类型不能被初始化"
  },
  {
    "id": "initialization of flexible array member in a nested context",
    "pattern": "initialization of flexible array member in a nested context",
    "replacement": "在嵌套的上下文中初始化柔性数组成员"
  },
  {
    "id": "non-static initialization of a flexible array member",
    "pattern": "non-static initialization of a flexible array member",
    "replacement": "对柔性数组成员的非静态初始化"
  },
  {
    "id": "function declared %<noreturn%> has a %<return%> statement",
    "pattern": "function declared 'noreturn' has a 'return' statement",
    "replacement": "被声明为 'noreturn' 的函数却有 'return' 语句"
  },
  {
    "id": "switch quantity not an integer",
    "pattern": "switch quantity not an integer",
    "replacement": "switch 语句中的控制表达式不是一个整数"
  },
  {
    "id": "case label not within a switch statement",
    "pattern": "case label not within a switch statement",
    "replacement": "case 标号出现在 switch 语句外"
  },
  {
    "id": "break statement not within loop or switch",
    "pattern": "break statement not within loop or switch",
    "replacement": "break 语句不在循环或 switch 语句内"
  },
  {
    "id": "invalid exit from OpenMP structured block",
    "pattern": "invalid exit from OpenMP structured block",
    "replacement": "OpenMP 结构块出口无效"
  },
  {
    "id": "break statement used with OpenMP for loop",
    "pattern": "break statement used with OpenMP for loop",
    "replacement": "OpenMP for 循环中使用了 break 语句"
  },
  {
    "id": "continue statement not within a loop",
    "pattern": "continue statement not within a loop",
    "replacement": "continue 语句出现在循环以外"
  },
  {
    "id": "statement with no effect",
    "pattern": "statement with no effect",
    "replacement": "语句没有作用"
  },
  {
    "id": "comparing vectors with different element types",
    "pattern": "comparing vectors with different element types",
    "replacement": "比较元素类型不同的向量"
  },
  {
    "id": "comparing vectors with different number of elements",
    "pattern": "comparing vectors with different number of elements",
    "replacement": "比较元素数量不同的向量"
  },
  {
    "id": "could not find an integer type of the same size as %qT",
    "pattern": "could not find an integer type of the same size as '(.+?)'",
    "replacement": "找不到和 '$2' 大小相同的整数类型"
  },
  {
    "id": "comparing floating-point with %<==%> or %<!=%> is unsafe",
    "pattern": "comparing floating-point with '==' or '!=' is unsafe",
    "replacement": "使用 == 或 != 比较浮点数是不安全的"
  },
  {
    "id": "%<#pragma omp cancel%> must specify one of %<parallel%>, %<for%>, %<sections%> or %<taskgroup%> clauses",
    "pattern": "'#pragma omp cancel' must specify one of 'parallel', 'for', 'sections' or 'taskgroup' clauses",
    "replacement": "'#pragma omp cancel' 必须指明 'parallel'、'for'、'sections' 或 'taskgroup' 子句中的一个"
  },
  {
    "id": "expected %<cancel%> %<if%> clause modifier",
    "pattern": "expected 'cancel' 'if' clause modifier",
    "replacement": "期望 'cancel 'if' 子句修饰符"
  },
  {
    "id": "%<#pragma omp cancellation point%> must specify one of %<parallel%>, %<for%>, %<sections%> or %<taskgroup%> clauses",
    "pattern": "'#pragma omp cancellation point' must specify one of 'parallel', 'for', 'sections' or 'taskgroup' clauses",
    "replacement": "'#pragma omp cancellation point' 必须指明 'parallel'、'for'、'sections' 或 'taskgroup' 子句中的一个"
  },
  {
    "id": "bit-field %qE in %qs clause",
    "pattern": "bit-field '(.+?)' in '(.+?)' clause",
    "replacement": "'$2' 子句中的位域 '$1'"
  },
  {
    "id": "%qE is a member of a union",
    "pattern": "'(.+?)' is a member of a union",
    "replacement": "'$1' 不是一个联合体的成员"
  },
  {
    "id": "%qD is not a variable in %qs clause",
    "pattern": "'(.+?)' is not a variable in '(.+?)' clause",
    "replacement": "'$1' 不是子句 '$2' 中的变量"
  },
  {
    "id": "%qD is threadprivate variable in %qs clause",
    "pattern": "'(.+?)' is threadprivate variable in '(.+?)' clause",
    "replacement": "'$1' 是子句 '$2' 中的 threadprivate 变量"
  },
  {
    "id": "low bound %qE of array section does not have integral type",
    "pattern": "low bound '(.+?)' of array section does not have integral type",
    "replacement": "数组节的下界 '$1' 不是整数类型"
  },
  {
    "id": "length %qE of array section does not have integral type",
    "pattern": "length '(.+?)' of array section does not have integral type",
    "replacement": "数组节的长度 '$1' 不是整数类型"
  },
  {
    "id": "expected single pointer in %qs clause",
    "pattern": "expected single pointer in '(.+?)' clause",
    "replacement": "'$1' 子句中期望单个指针"
  },
  {
    "id": "zero length array section in %qs clause",
    "pattern": "zero length array section in '(.+?)' clause",
    "replacement": "'$1' 子句中零长度数组节"
  },
  {
    "id": "for unknown bound array type length expression must be specified",
    "pattern": "for unknown bound array type length expression must be specified",
    "replacement": "对于未知大小数组类型，长度表达式必须指明"
  },
  {
    "id": "negative low bound in array section in %qs clause",
    "pattern": "negative low bound in array section in '(.+?)' clause",
    "replacement": "'$1' 子句中数组节的下界为负"
  },
  {
    "id": "negative length in array section in %qs clause",
    "pattern": "negative length in array section in '(.+?)' clause",
    "replacement": "'$1' 子句中数组节的长度为负"
  },
  {
    "id": "low bound %qE above array section size in %qs clause",
    "pattern": "low bound '(.+?)' above array section size in '(.+?)' clause",
    "replacement": "下界 '$1' 高于 '$2' 子句中的数组节的大小"
  },
  {
    "id": "length %qE above array section size in %qs clause",
    "pattern": "length '(.+?)' above array section size in '(.+?)' clause",
    "replacement": "长度 '$1' 高于 '$2' 子句中的数组节大小"
  },
  {
    "id": "high bound %qE above array section size in %qs clause",
    "pattern": "high bound '(.+?)' above array section size in '(.+?)' clause",
    "replacement": "上界 '$1' 高于 '$2' 子句中的数组节大小"
  },
  {
    "id": "for array function parameter length expression must be specified",
    "pattern": "for array function parameter length expression must be specified",
    "replacement": "对于数组函数形参，长度表达式必须指明"
  },
  {
    "id": "for pointer type length expression must be specified",
    "pattern": "for pointer type length expression must be specified",
    "replacement": "对于指针类型，长度表达式必须指明"
  },
  {
    "id": "array section is not contiguous in %qs clause",
    "pattern": "array section is not contiguous in '(.+?)' clause",
    "replacement": "数组节在 '$1' 子句中不连续"
  },
  {
    "id": "%qE does not have pointer or array type",
    "pattern": "'(.+?)' does not have pointer or array type",
    "replacement": "$1 不具有指针或数组类型"
  },
  {
    "id": "iterator %qD has neither integral nor pointer type",
    "pattern": "iterator '(.+?)' has neither integral nor pointer type",
    "replacement": "迭代器 '$1' 既不是整数类型，也不是指针类型"
  },
  {
    "id": "iterator %qD has const qualified type",
    "pattern": "iterator '(.+?)' has const qualified type",
    "replacement": "迭代器 '$1' 具有 const 限定类型"
  },
  {
    "id": "iterator step with non-integral type",
    "pattern": "iterator step with non-integral type",
    "replacement": "迭代器以非整数类型步进"
  },
  {
    "id": "iterator %qD has zero step",
    "pattern": "iterator '(.+?)' has zero step",
    "replacement": "迭代器 '$1' 步进了零"
  },
  {
    "id": "begin expression refers to outer iterator %qD",
    "pattern": "begin expression refers to outer iterator '(.+?)'",
    "replacement": "起始表达式指示了外部迭代器 '$1'"
  },
  {
    "id": "end expression refers to outer iterator %qD",
    "pattern": "end expression refers to outer iterator '(.+?)'",
    "replacement": "终止表达式指示了外部迭代器 '$1'"
  },
  {
    "id": "step expression refers to outer iterator %qD",
    "pattern": "step expression refers to outer iterator '(.+?)'",
    "replacement": "步进表达式指示了外部迭代器 '$1'"
  },
  {
    "id": "expected pointer in %qs clause",
    "pattern": "expected pointer in '(.+?)' clause",
    "replacement": "'$1' 子句中期望指针"
  },
  {
    "id": "%<inscan%> and non-%<inscan%> %<reduction%> clauses on the same construct",
    "pattern": "'inscan' and non-'inscan' 'reduction' clauses on the same construct",
    "replacement": "'inscan' 和 non-'inscan' 'reduction' 子句在同一结构中"
  },
  {
    "id": "%<inscan%> %<reduction%> clause with array section",
    "pattern": "'inscan' 'reduction' clause with array section",
    "replacement": "'inscan' 'reduction' 子句含有数组节"
  },
  {
    "id": "user defined reduction not found for %qE",
    "pattern": "user defined reduction not found for '(.+?)'",
    "replacement": "找不到为 '$1' 用户定义的归约"
  },
  {
    "id": "%<nowait%> clause must not be used together with %<copyprivate%>",
    "pattern": "'nowait' clause must not be used together with 'copyprivate'",
    "replacement": "'nowait' 子句不得同 'copyprivate' 一起使用"
  },
  {
    "id": "%qE must be %<threadprivate%> for %<copyin%>",
    "pattern": "'(.+?)' must be 'threadprivate' for 'copyin'",
    "replacement": "'$1' 必须是 'threadprivate' 方可 'copyin'"
  },
  {
    "id": "modifier should not be specified in %<linear%> clause on %<simd%> or %<for%> constructs",
    "pattern": "modifier should not be specified in 'linear' clause on 'simd' or 'for' constructs",
    "replacement": "在 'simd' 或 'for' 结构上，'linear' 子句不得指明修饰符"
  },
  {
    "id": "%<linear%> clause step %qE is neither constant nor a parameter",
    "pattern": "'linear' clause step '(.+?)' is neither constant nor a parameter",
    "replacement": "'linear' 子句步进 '$1' 既不是常量也不是形参"
  },
  {
    "id": "%qD appears more than once in reduction clauses",
    "pattern": "'(.+?)' appears more than once in reduction clauses",
    "replacement": "'$1' 在规约子句中多次出现"
  },
  {
    "id": "%qD appears more than once in data clauses",
    "pattern": "'(.+?)' appears more than once in data clauses",
    "replacement": "'$1' 在数据子句中多次出现"
  },
  {
    "id": "%qD appears both in data and map clauses",
    "pattern": "'(.+?)' appears both in data and map clauses",
    "replacement": "'$1' 在数据和映射子句中多次出现"
  },
  {
    "id": "%qE is not a variable in clause %<firstprivate%>",
    "pattern": "'(.+?)' is not a variable in clause 'firstprivate'",
    "replacement": "'$1' 不是子句 'firstprivate' 中的变量"
  },
  {
    "id": "%qE is not a variable in clause %<lastprivate%>",
    "pattern": "'(.+?)' is not a variable in clause 'lastprivate'",
    "replacement": "'$1' 不是子句 'lastprivate' 中的变量"
  },
  {
    "id": "%qE is not a variable in %<aligned%> clause",
    "pattern": "'(.+?)' is not a variable in 'aligned' clause",
    "replacement": "'$1' 不是子句 'aligned' 中的变量"
  },
  {
    "id": "%qE is not a variable in %<nontemporal%> clause",
    "pattern": "'(.+?)' is not a variable in 'nontemporal' clause",
    "replacement": "'$1' 不是子句 'notemoral' 中的变量"
  },
  {
    "id": "%qE is not a variable in %<allocate%> clause",
    "pattern": "'(.+?)' is not a variable in 'allocate' clause",
    "replacement": "'$1' 不是子句 'allocate' 中的变量"
  },
  {
    "id": "%<depend%> clause with %<depobj%> dependence type on array section",
    "pattern": "'depend' clause with 'depobj' dependence type on array section",
    "replacement": "带 'depobj' 依赖类型的 'depend' 子句在数组节中"
  },
  {
    "id": "%qE is not lvalue expression nor array section in %<depend%> clause",
    "pattern": "'(.+?)' is not lvalue expression nor array section in 'depend' clause",
    "replacement": "'depend' 子句中的 '$1' 既不是左值表达式也不是数组节"
  },
  {
    "id": "%qE does not have %<omp_depend_t%> type in %<depend%> clause with %<depobj%> dependence type",
    "pattern": "'(.+?)' does not have 'omp_depend_t' type in 'depend' clause with 'depobj' dependence type",
    "replacement": "带 'depobj' 依赖类型的 'depend' 子句中 '$1' 不是 'omp_depend_t' 类型"
  },
  {
    "id": "%qE should not have %<omp_depend_t%> type in %<depend%> clause with dependence type other than %<depobj%>",
    "pattern": "'(.+?)' should not have 'omp_depend_t' type in 'depend' clause with dependence type other than 'depobj'",
    "replacement": "当 'depend' 子句的依赖类型不是 'depobj' 时，其中的 '$1' 不应为 'omp_depend_t' 类型"
  },
  {
    "id": "array section does not have mappable type in %qs clause",
    "pattern": "array section does not have mappable type in '(.+?)' clause",
    "replacement": " '$1' 子句中的数组节不具有可映射类型"
  },
  {
    "id": "%qD appears more than once in motion clauses",
    "pattern": "'(.+?)' appears more than once in motion clauses",
    "replacement": "'$1' 在动作子句中多次出现"
  },
  {
    "id": "%qD appears more than once in map clauses",
    "pattern": "'(.+?)' appears more than once in map clauses",
    "replacement": "'$1' 在映射子句中多次出现"
  },
  {
    "id": "%qE does not have a mappable type in %qs clause",
    "pattern": "'(.+?)' does not have a mappable type in '(.+?)' clause",
    "replacement": "'$1' 在 '$2' 子句中不具有可映射类型"
  },
  {
    "id": "%qE is neither a variable nor a function name in clause %qs",
    "pattern": "'(.+?)' is neither a variable nor a function name in clause '(.+?)'",
    "replacement": "'$1' 在 '$2' 子句中既不是变量又不是函数名"
  },
  {
    "id": "%qE appears more than once on the same %<declare target%> directive",
    "pattern": "'(.+?)' appears more than once on the same 'declare target' directive",
    "replacement": "'$1' 在同一个 'declare target' 指令中多次出现"
  },
  {
    "id": "%qD is not an argument in %<uniform%> clause",
    "pattern": "'(.+?)' is not an argument in 'uniform' clause",
    "replacement": "'$1' 不是 'uniform' 子句的实参"
  },
  {
    "id": "%<order%> clause must not be used together with %<ordered%>",
    "pattern": "'order' clause must not be used together with 'ordered'",
    "replacement": "'order' 子句不得和 'ordered' 一起使用"
  },
  {
    "id": "too many %qs clauses on a task construct",
    "pattern": "too many '(.+?)' clauses on a task construct",
    "replacement": "任务构造中有太多的 '$1' 子句"
  },
  {
    "id": "%<inbranch%> clause is incompatible with %<notinbranch%>",
    "pattern": "'inbranch' clause is incompatible with 'notinbranch'",
    "replacement": "'inbranch' 子句与 'notinbranch' 不兼容"
  },
  {
    "id": "%qE is predetermined %qs for %qs",
    "pattern": "'(.+?)' is predetermined '(.+?)' for '(.+?)'",
    "replacement": "'$1' 可被 '$3' 预先确定为'$2'"
  },
  {
    "id": "%<simdlen%> clause value is bigger than %<safelen%> clause value",
    "pattern": "'simdlen' clause value is bigger than 'safelen' clause value",
    "replacement": "'simdlen' 子句的值比 'safelen' 子句的值大"
  },
  {
    "id": "%<nonmonotonic%> schedule modifier specified together with %<ordered%> clause",
    "pattern": "'nonmonotonic' schedule modifier specified together with 'ordered' clause",
    "replacement": "'nonmonotonic' 调度修饰符与 'ordered' 子句一起指定"
  },
  {
    "id": "%qs clause specified together with %<inscan%> %<reduction%> clause",
    "pattern": "'(.+?)' clause specified together with 'inscan' 'reduction' clause",
    "replacement": "'$1' 子句与 'inscan' 'reduction' 子句一起指定"
  },
  {
    "id": "%<linear%> clause step is a parameter %qD not specified in %<uniform%> clause",
    "pattern": "'linear' clause step is a parameter '(.+?)' not specified in 'uniform' clause",
    "replacement": "'linear' 子句步进是一个未在 'uniform' 子句中指明的 '$1' 形参"
  },
  {
    "id": "%<nogroup%> clause must not be used together with %<reduction%> clause",
    "pattern": "'nogroup' clause must not be used together with 'reduction' clause",
    "replacement": "'nogroup' 子句不得与 'reduction' 子句一起使用"
  },
  {
    "id": "%<detach%> clause must not be used together with %<mergeable%> clause",
    "pattern": "'detach' clause must not be used together with 'mergeable' clause",
    "replacement": "'detach' 子句不得与 'mergeable' 子句一起使用"
  },
  {
    "id": "the event handle of a %<detach%> clause should not be in a data-sharing clause",
    "pattern": "the event handle of a 'detach' clause should not be in a data-sharing clause",
    "replacement": "'detach' 子句的事件句柄不得在数据共享子句内"
  },
  {
    "id": "  passing %qT as %<this%> argument discards qualifiers",
    "pattern": "  passing '(.+?)' as 'this' argument discards qualifiers",
    "replacement": "  以 '$1' 为 'this' 实参丢失了限定符"
  },
  {
    "id": "  no known conversion for implicit %<this%> parameter from %qH to %qI",
    "pattern": "  no known conversion for implicit 'this' parameter from '(.+?)' to '(.+?)'",
    "replacement": "  对于隐式 'this' 形参，没有已知的从 '$1' 到 '$2' 的转换"
  },
  {
    "id": "  conversion of argument %d would be ill-formed:",
    "pattern": "  conversion of argument (\\d+) would be ill-formed:",
    "replacement": "  第 $1 个实参的转换是非良构的："
  },
  {
    "id": "  no known conversion from %qH to %qI",
    "pattern": "  no known conversion from '(.+?)' to '(.+?)'",
    "replacement": "  没有已知的从 '$1' 到 '$2' 的转换"
  },
  {
    "id": "  no known conversion for argument %d from %qH to %qI",
    "pattern": "  no known conversion for argument (\\d+) from '(.+?)' to '(.+?)'",
    "replacement": "  对于第 $1 个实参，没有已知的从 '$2' 到 '$3' 的转换"
  },
  {
    "id": "  candidate expects %d argument, %d provided",
    "pattern": "  candidate expects (\\d+) arguments?, (\\d+) provided",
    "replacement": "备选期望 $1 个实参，但提供了 $2 个"
  },
  {
    "id": "%s%<%D(%T, %T, %T)%> (built-in)",
    "pattern": "\\(built-in\\)",
    "replacement": "(内建)"
  },
  {
    "id": "%s%qT (conversion)",
    "pattern": "\\(conversion\\)",
    "replacement": "(转换)"
  },
  {
    "id": "%s%#qD (near match)",
    "pattern": "\\(near match\\)",
    "replacement": "(就近匹配)"
  },
  {
    "id": "%s%#qD (deleted)",
    "pattern": "\\(deleted\\)",
    "replacement": "(被删除)"
  },
  {
    "id": "%s%#qD (reversed)",
    "pattern": "\\(reversed\\)",
    "replacement": "(还原的)"
  },
  {
    "id": "%s%#qD (rewritten)",
    "pattern": "\\(rewritten\\)",
    "replacement": "(重写的)"
  },
  {
    "id": "  inherited here",
    "pattern": "  inherited here",
    "replacement": "  在此处继承"
  },
  {
    "id": "  return type %qT of explicit conversion function cannot be converted to %qT with a qualification conversion",
    "pattern": "  return type '(.+?)' of explicit conversion function cannot be converted to '(.+?)' with a qualification conversion",
    "replacement": "  显式转换函数的返回类型 '$1' 无法通过限定转换转换到 '$2'"
  },
  {
    "id": "  conversion from return type %qT of template conversion function specialization to %qT is not an exact match",
    "pattern": "  conversion from return type '(.+?)' of template conversion function specialization to '(.+?)' is not an exact match",
    "replacement": "  从模板转换函数特化的返回类型 '$1' 到 '$2' 的转换不是精确匹配"
  },
  {
    "id": "  substitution of deduced template arguments resulted in errors seen above",
    "pattern": "  substitution of deduced template arguments resulted in errors seen above",
    "replacement": "  模板实参推导的匹配结果错误见上"
  },
  {
    "id": "  template argument deduction/substitution failed:",
    "pattern": "  template argument deduction/substitution failed:",
    "replacement": "  模板实参推导/匹配失败："
  },
  {
    "id": "  a constructor taking a single argument of its own class type is invalid",
    "pattern": "  a constructor taking a single argument of its own class type is invalid",
    "replacement": "  一个构造函数接受单个实参，且该实参就是这个类的类型，则构造函数无效"
  },
  {
    "id": "  an inherited constructor is not a candidate for initialization from an expression of the same or derived type",
    "pattern": "  an inherited constructor is not a candidate for initialization from an expression of the same or derived type",
    "replacement": "  一个继承而来的构造函数不是该类或其派生类表达式初始化的候选"
  },
  {
    "id": "designated initializers cannot be used with a non-aggregate type %qT",
    "pattern": "designated initializers cannot be used with a non-aggregate type '(.+?)'",
    "replacement": "指派初始化器不能在非聚合类型 '$1' 上使用"
  },
  {
    "id": "conversion from %qH to %qI is ambiguous",
    "pattern": "conversion from '(.+?)' to '(.+?)' is ambiguous",
    "replacement": "从 '$1' 到 '$2' 的转换有歧义"
  },
  {
    "id": "could not convert %qE from %qH to %qI",
    "pattern": "could not convert '(.+?)' from '(.+?)' to '(.+?)'",
    "replacement": "不能将 '$1' 从 '$2' 转换到 '$2'"
  },
  {
    "id": "initializing %qH with %qI in converted constant expression does not bind directly",
    "pattern": "initializing '(.+?)' with '(.+?)' in converted constant expression does not bind directly",
    "replacement": "在经转换的常量表达式中以 $2 初始化 $1 未直接绑定"
  },
  {
    "id": "conversion from %qH to %qI in a converted constant expression",
    "pattern": "conversion from '(.+?)' to '(.+?)' in a converted constant expression",
    "replacement": "在经转换的常量表达式中从 $1 转换到 $2"
  },
  {
    "id": "no matching function for call to %<%D(%A)%>",
    "pattern": "no matching function for call to '(.+?)'",
    "replacement": "对 '$1' 的调用没有匹配的函数"
  },
  {
    "id": "call of overloaded %<%D(%A)%> is ambiguous",
    "pattern": "call of overloaded '(.+?)' is ambiguous",
    "replacement": "对有重载的 '$1' 的调用有歧义"
  },
  {
    "id": "pointer-to-member function %qE cannot be called without an object; consider using %<.*%> or %<->*%>",
    "pattern": "pointer-to-member function '(.+?)' cannot be called without an object; consider using '.\\*' or '->\\*'",
    "replacement": "成员函数指针 '$1' 不能在没有对象的情形下调用；考虑使用 .* 或 ->*"
  },
  {
    "id": "no match for call to %<(%T) (%A)%>",
    "pattern": "no match for call to '(.+?)'",
    "replacement": "对 '$1' 的调用没有匹配"
  },
  {
    "id": "call of %<(%T) (%A)%> is ambiguous",
    "pattern": "call of '(.+?)' is ambiguous",
    "replacement": "对 '$1' 的调用有歧义"
  },
  {
    "id": "ambiguous overload for ",
    "pattern": "ambiguous overload for ",
    "replacement": "有歧义的重载，对于 "
  },
  {
    "id": "no match for ",
    "pattern": "no match for ",
    "replacement": "没有匹配，对于 "
  },
  {
    "id": " (operand types are %qT, %qT, and %qT)",
    "pattern": " \\(operand types are '(.+?)', '(.+?)', and '(.+?)'\\)",
    "replacement": "（操作数类型是 '$1'、'$2' 和 '$3'）"
  },
  {
    "id": " (operand types are %qT and %qT)",
    "pattern": " \\(operand types are '(.+?)' and '(.+?)'\\)",
    "replacement": "（操作数类型是 '$1' 和 '$2'）"
  },
  {
    "id": " (operand type is %qT)",
    "pattern": " \\(operand type (is|are) '(.+?)'\\)",
    "replacement": "（操作数类型是 '$2'）"
  },
  {
    "id": "ternary %<operator?:%>",
    "pattern": "ternary 'operator\\?:'",
    "replacement": "三元 'operator?:'"
  },
  {
    "id": "ternary %<operator?:%> in %<%E ? %E : %E%>",
    "pattern": "ternary 'operator\\?:' in '(.+?) \\? (.+?) : (.+?)'",
    "replacement": "'$1 ? $2 : $3' 中的三元 'operator?:'"
  },
  {
    "id": "%<operator%s%> in %<%E%s%>",
    "pattern": "'operator(.*?)' in '(.+?)'",
    "replacement": "'$2' 中的 'operator$1'"
  },
  {
    "id": "ISO C++ forbids omitting the middle term of a %<?:%> expression",
    "pattern": "ISO C\\+\\+ forbids omitting the middle term of a '?:' expression",
    "replacement": "ISO C++ 禁止省略 '?:' 表达式中的第二项"
  },
  {
    "id": "inferred scalar type %qT is not an integer or floating-point type of the same size as %qT",
    "pattern": "inferred scalar type '(.+?)' is not an integer or floating-point type of the same size as '(.+?)'",
    "replacement": "推导的标量类型 '$1' 不是与 '$2' 相同大小的整数或浮点类型"
  },
  {
    "id": "incompatible vector types in conditional expression: %qT, %qT and %qT",
    "pattern": "incompatible vector types in conditional expression: '(.+?)', '(.+?)' and '(.+?)'",
    "replacement": "条件表达式中含不兼容的向量类型：'$1'、'$2' 和 '$3'"
  },
  {
    "id": "second operand to the conditional operator is of type %<void%>, but the third operand is neither a throw-expression nor of type %<void%>",
    "pattern": "second operand to the conditional operator is of type 'void', but the third operand is neither a throw-expression nor of type 'void'",
    "replacement": "条件运算符的第二个操作数类型为 'void' ，但第三个操作数既不是异常表达式，也不具有 'void' 类型"
  },
  {
    "id": "third operand to the conditional operator is of type %<void%>, but the second operand is neither a throw-expression nor of type %<void%>",
    "pattern": "third operand to the conditional operator is of type 'void', but the second operand is neither a throw-expression nor of type 'void'",
    "replacement": "条件运算符的第三个操作数类型为 'void' ，但第二个操作数既不是异常表达式，也不具有 'void' 类型"
  },
  {
    "id": "operands to %<?:%> have different types %qT and %qT",
    "pattern": "operands to '?:' have different types '(.+?)' and '(.+?)'",
    "replacement": "'?:' 的操作数类型不一致，分别为 '$1' 和 '$2'"
  },
  {
    "id": "  and each type can be converted to the other",
    "pattern": "  and each type can be converted to the other",
    "replacement": "  且每个类型都可以转换到其它类型"
  },
  {
    "id": "implicit conversion from %qH to %qI to match other result of conditional",
    "pattern": "implicit conversion from '(.+?)' to '(.+?)' to match other result of conditional",
    "replacement": "隐式转换 '$1' 到 '$2' 来匹配条件表达式的其它结果"
  },
  {
    "id": "enumerated mismatch in conditional expression: %qT vs %qT",
    "pattern": "enumerated mismatch in conditional expression: '(.+?)' vs '(.+?)'",
    "replacement": "条件表达式中枚举不匹配：'$1' 和 '$2'"
  },
  {
    "id": "conditional expression between enumeration type %qT and floating-point type %qT is deprecated",
    "pattern": "conditional expression between enumeration type '(.+?)' and floating-point type '(.+?)' is deprecated",
    "replacement": "由枚举类型 '$1' 和浮点类型 '$2' 组成的条件表达式是被弃用的"
  },
  {
    "id": "conditional expression between floating-point type %qT and enumeration type %qT is deprecated",
    "pattern": "conditional expression between floating-point type '(.+?)' and enumeration type '(.+?)' is deprecated",
    "replacement": "由浮点类型 '$1' 和枚举类型 '$2' 组成的条件表达式是被弃用的"
  },
  {
    "id": "enumerated and non-enumerated type in conditional expression",
    "pattern": "enumerated and non-enumerated type in conditional expression",
    "replacement": "枚举和非枚举类型一起出现在条件表达式中"
  },
  {
    "id": "no %<%D(int)%> declared for postfix %qs, trying prefix operator instead",
    "pattern": "no '(.+?)\\(int\\)' declared for postfix '(.+?)', trying prefix operator instead",
    "replacement": "后缀 '$2' 未声明 '$1(int)'，尝试使用前缀运算符代替"
  },
  {
    "id": "no %<%D(int)%> declared for postfix %qs",
    "pattern": "no '(.+?)\\(int\\)' declared for postfix '(.+?)'",
    "replacement": "后缀 '$2' 未声明 '$1(int)'，"
  },
  {
    "id": "in C++20 this comparison calls the current function recursively with reversed arguments",
    "pattern": "in C\\+\\+20 this comparison calls the current function recursively with reversed arguments",
    "replacement": "在 C++20 中，此比较会递归地、以相反实参调用当前函数"
  },
  {
    "id": "return type of %qD is not %qs",
    "pattern": "return type of '(.+?)' is not '(.+?)'",
    "replacement": "'$1' 的返回类型不是 '$2'"
  },
  {
    "id": "used as rewritten candidate for comparison of %qT and %qT",
    "pattern": "used as rewritten candidate for comparison of '(.+?)' and '(.+?)'",
    "replacement": "'$1' 和 '$2' 的比较使用重写的候选"
  },
  {
    "id": "comparison between %q#T and %q#T",
    "pattern": "comparison between '(.+?)' and '(.+?)'",
    "replacement": "在 '(.+?)' 和 '(.+?)' 间比较"
  },
  {
    "id": "exception cleanup for this placement new selects non-placement %<operator delete%>",
    "pattern": "exception cleanup for this placement new selects non-placement 'operator delete'",
    "replacement": "此布置 new 的异常清理选择了非布置的 'operator delete'"
  },
  {
    "id": "%qD is a usual (non-placement) deallocation function in C++14 (or with %<-fsized-deallocation%>)",
    "pattern": "'(.+?)' is a usual \\(non-placement\\) deallocation function in C\\+\\+14 \\(or with '-fsized-deallocation'\\)",
    "replacement": "'$1' 在 C++14 中是一个常规（非布置）的释放函数（或启用 '-fsized-deallocation'）"
  },
  {
    "id": "%qD is a usual (non-placement) deallocation function",
    "pattern": "'(.+?)' is a usual \\(non-placement\\) deallocation function",
    "replacement": "'$1' 在 C++14 中是一个常规（非布置）的释放函数"
  },
  {
    "id": "no corresponding deallocation function for %qD",
    "pattern": "no corresponding deallocation function for '(.+?)'",
    "replacement": "没有 '$1' 相应的释放函数"
  },
  {
    "id": "no suitable %<operator %s%> for %qT",
    "pattern": "no suitable 'operator (.*?)' for '(.+?)'",
    "replacement": "没有为 '$2' 合适的 'operator $1'"
  },
  {
    "id": "%q#D is private within this context",
    "pattern": "'(.+?)' is private within this context",
    "replacement": "'$1' 在此语境下是私有的"
  },
  {
    "id": "declared private here",
    "pattern": "declared private here",
    "replacement": "在此声明为私有的"
  },
  {
    "id": "%q#D is protected within this context",
    "pattern": "'(.+?)' is protected within this context",
    "replacement": "'$1' 在此语境下是保护的"
  },
  {
    "id": "declared protected here",
    "pattern": "declared protected here",
    "replacement": "在此声明为保护的"
  },
  {
    "id": "%q#D is inaccessible within this context",
    "pattern": "'(.+?)' is inaccessible within this context",
    "replacement": "'$1' 在此语境下不可访问"
  },
  {
    "id": "passing NULL to non-pointer argument %P of %qD",
    "pattern": "passing NULL to non-pointer argument (.*?) of '(.+?)'",
    "replacement": "将 NULL 作为 '$2' 的第 $1 个实参，其不是指针类型"
  },
  {
    "id": "  declared here",
    "pattern": "  declared here",
    "replacement": "  在此声明"
  },
  {
    "id": "converting to non-pointer type %qT from NULL",
    "pattern": "converting to non-pointer type '(.+?)' from NULL",
    "replacement": "将 NULL 转换到非指针类型 '$1'"
  },
  {
    "id": "converting %<false%> to pointer type for argument %P of %qD",
    "pattern": "converting 'false' to pointer type for argument (.*?) of '(.+?)'",
    "replacement": "将 'false' 转换为指针类型，作为第 $1 个实参传递给 '$2'"
  },
  {
    "id": "converting %<false%> to pointer type %qT",
    "pattern": "converting 'false' to pointer type '(.+?)'",
    "replacement": "将 'false' 转换为指针类型 '$1'"
  },
  {
    "id": "  initializing argument %P of %qD",
    "pattern": "  initializing argument (.*?) of '(.+?)'",
    "replacement": "  初始化 '$2' 的第 $1 个实参"
  },
  {
    "id": "conversions to arrays of unknown bound are only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "conversions to arrays of unknown bound are only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "转换到未知边界数组仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "too many braces around initializer for %qT",
    "pattern": "too many braces around initializer for '(.+?)'",
    "replacement": "'$1' 的初始化器中花括号太多"
  },
  {
    "id": "converting to %qH from %qI requires direct-initialization",
    "pattern": "converting to '(.+?)' from '(.+?)' requires direct-initialization",
    "replacement": "从 '$1' 转换到 '$2' 需要直接初始化"
  },
  {
    "id": "invalid user-defined conversion from %qH to %qI",
    "pattern": "invalid user-defined conversion from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的用户定义转换无效"
  },
  {
    "id": "invalid conversion from %qH to %qI",
    "pattern": "invalid conversion from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的转换无效"
  },
  {
    "id": "converting to %qT from initializer list would use explicit constructor %qD",
    "pattern": "converting to '(.+?)' from initializer list would use explicit constructor '(.+?)'",
    "replacement": "从初始化列表转换为 '$1' 将使用显式构造函数 '$2'"
  },
  {
    "id": "in C++11 and above a default constructor can be explicit",
    "pattern": "in C\\+\\+11 and above a default constructor can be explicit",
    "replacement": "C++11 起，一个默认构造函数可以为显式的"
  },
  {
    "id": "cannot bind rvalue reference of type %qH to lvalue of type %qI",
    "pattern": "cannot bind rvalue reference of type '(.+?)' to lvalue of type '(.+?)'",
    "replacement": "不能将 '$1' 类型的右值引用绑定到 '$2' 类型的左值上"
  },
  {
    "id": "cannot bind non-const lvalue reference of type %qH to a value of type %qI",
    "pattern": "cannot bind non-const lvalue reference of type '(.+?)' to a value of type '(.+?)'",
    "replacement": "不能将非只读的 '$1' 类型的左值引用绑定到 '$2' 类型的值上"
  },
  {
    "id": "cannot bind non-const lvalue reference of type %qH to an rvalue of type %qI",
    "pattern": "cannot bind non-const lvalue reference of type '(.+?)' to an rvalue of type '(.+?)'",
    "replacement": "不能将非只读的 '$1' 类型的左值引用绑定到 '$2' 类型的右值上"
  },
  {
    "id": "cannot bind reference of type %qH to %qI due to different array bounds",
    "pattern": "cannot bind reference of type '(.+?)' to '(.+?)' due to different array bounds",
    "replacement": "不能将 '$1' 类型的引用绑定到 '$2'，因为它们具有不同的数组大小"
  },
  {
    "id": "binding reference of type %qH to %qI discards qualifiers",
    "pattern": "binding reference of type '(.+?)' to '(.+?)' discards qualifiers",
    "replacement": "将 '$1' 类型的引用绑定到 '$2' 时丢弃了限定符"
  },
  {
    "id": "cannot bind bit-field %qE to %qT",
    "pattern": "cannot bind bit-field '(.+?)' to '(.+?)'",
    "replacement": "不能将位域 '$1' 绑定到 '$2'"
  },
  {
    "id": "cannot bind packed field %qE to %qT",
    "pattern": "cannot bind packed field '(.+?)' to '(.+?)'",
    "replacement": "不能将紧实的字段 '$1' 绑定到 '$2'"
  },
  {
    "id": "cannot bind rvalue %qE to %qT",
    "pattern": "cannot bind rvalue '(.+?)' to '(.+?)'",
    "replacement": "不能将右值 '$1' 绑定到 '$2'"
  },
  {
    "id": "implicit conversion from %qH to %qI when passing argument to function",
    "pattern": "implicit conversion from '(.+?)' to '(.+?)' when passing argument to function",
    "replacement": "当传递实参给函数时，从 '$1' 到 '$2' 的隐式转换"
  },
  {
    "id": "scoped enum %qT passed through %<...%> as %qT before %<-fabi-version=6%>, %qT after",
    "pattern": "scoped enum '(.+?)' passed through '\\.\\.\\.' as '(.+?)' before '-fabi-version=6', '(.+?)' after",
    "replacement": "在 '-fabi-version=6' 之前，有作用域的枚举 '$1' 通过 '...' 时将作为 '$2'；之后将作为 '$3'"
  },
  {
    "id": "passing objects of non-trivially-copyable type %q#T through %<...%> is conditionally supported",
    "pattern": "passing objects of non-trivially-copyable type '(.+?)' through '\\.\\.\\.' is conditionally supported",
    "replacement": "通过 '...' 传递有非平凡复制的类型 '$1' 是条件性支持的"
  },
  {
    "id": "cannot receive reference type %qT through %<...%>",
    "pattern": "cannot receive reference type '(.+?)' through '\\.\\.\\.'",
    "replacement": "不能通过 '...' 接受引用类型 '$1'"
  },
  {
    "id": "receiving objects of non-trivially-copyable type %q#T through %<...%> is conditionally-supported",
    "pattern": "receiving objects of non-trivially-copyable type '(.+?)' through '\\.\\.\\.' is conditionally-supported",
    "replacement": "通过 '...' 接受非平凡复制的类型 '$1' 是条件性支持的"
  },
  {
    "id": "recursive evaluation of default argument for %q#D",
    "pattern": "recursive evaluation of default argument for '(.+?)'",
    "replacement": "递归计算 '$1' 的默认实参"
  },
  {
    "id": "call to %qD uses the default argument for parameter %P, which is not yet defined",
    "pattern": "call to '(.+?)' uses the default argument for parameter (.*?), which is not yet defined",
    "replacement": "在调用 '$1' 时第 $2 个形参使用了默认实参，但其尚未定义"
  },
  {
    "id": "argument of function call might be a candidate for a format attribute",
    "pattern": "argument of function call might be a candidate for a format attribute",
    "replacement": "函数的实参可能是 format 特性的备选"
  },
  {
    "id": "use of multiversioned function without a default",
    "pattern": "use of multiversioned function without a default",
    "replacement": "使用多版本的函数却不带默认值"
  },
  {
    "id": "passing %qT as %<this%> argument discards qualifiers",
    "pattern": "passing '(.+?)' as 'this' argument discards qualifiers",
    "replacement": "作为 'this' 实参传递 '$1' 丢弃了限定符"
  },
  {
    "id": "  in call to %qD",
    "pattern": "  in call to '(.+?)'",
    "replacement": "  在调用 '$1' 时"
  },
  {
    "id": "%qT is not an accessible base of %qT",
    "pattern": "'(.+?)' is not an accessible base of '(.+?)'",
    "replacement": "'$1' 是 '$2' 的不可访问的基类"
  },
  {
    "id": "passing arguments to ellipsis of inherited constructor %qD",
    "pattern": "passing arguments to ellipsis of inherited constructor '(.+?)'",
    "replacement": "传递实参到继承而来的构造函数 '$1' 的省略号中"
  },
  {
    "id": "assignment from temporary %<initializer_list%> does not extend the lifetime of the underlying array",
    "pattern": "assignment from temporary 'initializer_list' does not extend the lifetime of the underlying array",
    "replacement": "从临时的 'initializer_list' 赋值并不延长底层数组的生命期"
  },
  {
    "id": "%qD writing to an object of type %#qT with no trivial copy-assignment",
    "pattern": "'(.+?)' writing to an object of type '(.+?)' with no trivial copy-assignment",
    "replacement": "'$1' 写入 '$2' 类型的对象，该类型没有平凡复制赋值"
  },
  {
    "id": "%qD writing to an object of non-trivial type %#qT%s",
    "pattern": "'(.+?)' writing to an object of non-trivial type '(.+?)'",
    "replacement": "'$1' 写入 '$2' 类型的对象，该类型是非平凡的"
  },
  {
    "id": "%qD writing to an object of type %#qT with %qs member %qD",
    "pattern": "'(.+?)' writing to an object of type '(.+?)' with '(.+?)' member '(.+?)'",
    "replacement": "'$1' 写入 '$2' 类型的对象，其成员 '$4' 是 '$3' 的"
  },
  {
    "id": "%qD writing to an object of type %#qT containing a pointer to data member%s",
    "pattern": "'(.+?)' writing to an object of type '(.+?)' containing a pointer to data member",
    "replacement": "'$1' 写入 '$2' 类型的对象，其包含一个成员数据指针"
  },
  {
    "id": "; use assignment or value-initialization instead",
    "pattern": "; use assignment or value-initialization instead",
    "replacement": "；使用赋值或值初始化代替"
  },
  {
    "id": "; use assignment instead",
    "pattern": "; use assignment instead",
    "replacement": "；使用赋值代替"
  },
  {
    "id": "; use value-initialization instead",
    "pattern": "; use value-initialization instead",
    "replacement": "；使用值初始化代替"
  },
  {
    "id": "%qD clearing an object of type %#qT with no trivial copy-assignment%s",
    "pattern": "'(.+?)' clearing an object of type '(.+?)' with no trivial copy-assignment",
    "replacement": "'$1' 清除了 '$2' 类型的对象，该类型没有平凡复制赋值"
  },
  {
    "id": "%qD clearing an object of non-trivial type %#qT%s",
    "pattern": "'(.+?)' clearing an object of non-trivial type '(.+?)'",
    "replacement": "'$1' 清除了非平凡类型 '$2' 的对象"
  },
  {
    "id": "%qD clearing an object of type %#qT containing a pointer-to-member%s",
    "pattern": "'(.+?)' clearing an object of type '(.+?)' containing a pointer-to-member",
    "replacement": "'$1' 清除了 '$2' 类型的对象，其包含一个成员指针"
  },
  {
    "id": "; use copy-assignment or copy-initialization instead",
    "pattern": "; use copy-assignment or copy-initialization instead",
    "replacement": "；使用复制赋值或复制初始化代替"
  },
  {
    "id": "; use copy-assignment instead",
    "pattern": "; use copy-assignment instead",
    "replacement": "；使用复制赋值代替"
  },
  {
    "id": "; use copy-initialization instead",
    "pattern": "; use copy-initialization instead",
    "replacement": "；使用复制初始化代替"
  },
  {
    "id": "%qD writing to an object of non-trivially copyable type %#qT%s",
    "pattern": "'(.+?)' writing to an object of non-trivially copyable type '(.+?)'",
    "replacement": "'$1' 写入 '$2' 类型的对象，该类型不可平凡复制"
  },
  {
    "id": "%qD writing to an object with a deleted copy constructor",
    "pattern": "'(.+?)' writing to an object with a deleted copy constructor",
    "replacement": "'$1' 写入一个复制构造函数被删除的对象"
  },
  {
    "id": "%qD copying an object of non-trivial type %#qT from an array of %#qT",
    "pattern": "'(.+?)' copying an object of non-trivial type '(.+?)' from an array of '(.+?)'",
    "replacement": "'$1' 从 '$3' 的数组复制非平凡类型 '$2' 的对象"
  },
  {
    "id": "%qD copying an object of type %#qT with %qs member %qD from an array of %#qT; use assignment or copy-initialization instead",
    "pattern": "'(.+?)' copying an object of type '(.+?)' with '(.+?)' member '(.+?)' from an array of '(.+?)'; use assignment or copy-initialization instead",
    "replacement": "'$1' 复制 '$2' 类型的对象，其 '$3' 成员 '$4' 从 '$5' 数组复制而来；使用赋值或复制初始化代替"
  },
  {
    "id": "%qD writing to an object of a non-trivial type %#qT leaves %wu bytes unchanged",
    "pattern": "'(.+?)' writing to an object of a non-trivial type '(.+?)' leaves (.*?) bytes? unchanged",
    "replacement": "'$1' 写入非平凡类型 '$2' 的对象，其中 $3 个字节未发生改变"
  },
  {
    "id": "%qD moving an object of non-trivially copyable type %#qT; use %<new%> and %<delete%> instead",
    "pattern": "'(.+?)' moving an object of non-trivially copyable type '(.+?)'; use 'new' and 'delete' instead",
    "replacement": "'$1' 移动 '$2' 类型的对象，该类型不可平凡复制；使用 'new' 和 'delete' 代替"
  },
  {
    "id": "%qD moving an object of type %#qT with deleted copy constructor; use %<new%> and %<delete%> instead",
    "pattern": "'(.+?)' moving an object of type '(.+?)' with deleted copy constructor; use 'new' and 'delete' instead",
    "replacement": "'$1' 移动 '$2' 类型的对象，该类型的复制构造函数被删除；使用 'new' 和 'delete' 代替"
  },
  {
    "id": "%qD moving an object of type %#qT with deleted destructor",
    "pattern": "'(.+?)' moving an object of type '(.+?)' with deleted destructor",
    "replacement": "'$1' 移动 '$2' 类型的对象，该类型的析构函数被删除"
  },
  {
    "id": "%qD moving an object of non-trivial type %#qT and size %E into a region of size %E",
    "pattern": "'(.+?)' moving an object of non-trivial type '(.+?)' and size (.*?) into a region of size (.*?)",
    "replacement": "'$1' 移动非平凡类型 '$2' 、大小为 $3 的对象到大小为 $4 的区域中"
  },
  {
    "id": "%#qT declared here",
    "pattern": "'(.+?)' declared here",
    "replacement": "'$1' 在此声明"
  },
  {
    "id": "constructor delegates to itself",
    "pattern": "constructor delegates to itself",
    "replacement": "构造函数委托自身构造"
  },
  {
    "id": "cannot convert %qH to %qI",
    "pattern": "cannot convert '(.+?)' to '(.+?)'",
    "replacement": "不能将 '$1' 转换为 '$2'"
  },
  {
    "id": "call to non-function %qD",
    "pattern": "call to non-function '(.+?)'",
    "replacement": "调用 '(.+?)'，它不是函数"
  },
  {
    "id": "cannot call constructor %<%T::%D%> directly",
    "pattern": "cannot call constructor '(.+?)::(.+?)' directly",
    "replacement": "不能直接调用构造函数 '$1::$2'"
  },
  {
    "id": "for a function-style cast, remove the redundant %<::%D%>",
    "pattern": "for a function-style cast, remove the redundant '::(.+?)'",
    "replacement": "对于函数风格类型转换，移除冗余的 '::$1'"
  },
  {
    "id": "pure virtual %q#D called from non-static data member initializer",
    "pattern": "pure virtual '(.+?)' called from non-static data member initializer",
    "replacement": "在非静态数据成员初始化器中调用纯虚的 '$1'"
  },
  {
    "id": "pure virtual %q#D called from constructor",
    "pattern": "pure virtual '(.+?)' called from constructor",
    "replacement": "在构造函数中调用纯虚的 '$1'"
  },
  {
    "id": "pure virtual %q#D called from destructor",
    "pattern": "pure virtual '(.+?)' called from destructor",
    "replacement": "在析构函数中调用纯虚的 '$1'"
  },
  {
    "id": "cannot call member function %qD without object",
    "pattern": "cannot call member function '(.+?)' without object",
    "replacement": "不能在没有对象的情形下调用成员函数 '$1'"
  },
  {
    "id": "passing %qT chooses %qT over %qT",
    "pattern": "passing '(.+?)' chooses '(.+?)' over '(.+?)'",
    "replacement": "传递 '$1' 时选择 '$2' 而不是 '$3'"
  },
  {
    "id": "choosing %qD over %qD",
    "pattern": "choosing '(.+?)' over '(.+?)'",
    "replacement": "选择 '$1' 而不是 '$2'"
  },
  {
    "id": "  for conversion from %qH to %qI",
    "pattern": "  for conversion from '(.+?)' to '(.+?)'",
    "replacement": "  以从 '$1' 转换为 '$2'"
  },
  {
    "id": "  because conversion sequence for the argument is better",
    "pattern": "  because conversion sequence for the argument is better",
    "replacement": "  因为此实参的类型转换序列更好"
  },
  {
    "id": "default argument mismatch in overload resolution",
    "pattern": "default argument mismatch in overload resolution",
    "replacement": "重载解析时默认实参不匹配"
  },
  {
    "id": " candidate 1: %q#F",
    "pattern": " candidate 1: ",
    "replacement": "备选 1: "
  },
  {
    "id": " candidate 2: %q#F",
    "pattern": " candidate 2: ",
    "replacement": "备选 2: "
  },
  {
    "id": "ISO C++ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for the second:",
    "pattern": "ISO C\\+\\+ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for the second:",
    "replacement": "ISO C++ 认为这是有歧义的，尽管第一个备选的最差类型转换要好于第二个备选的最差类型转换"
  },
  {
    "id": "a temporary bound to %qD only persists until the constructor exits",
    "pattern": "a temporary bound to '(.+?)' only persists until the constructor exits",
    "replacement": "暂时的约束到 '$1' 只有持续直到构造函数离开"
  },
  {
    "id": "invalid initialization of non-const reference of type %qH from an rvalue of type %qI",
    "pattern": "invalid initialization of non-const reference of type '(.+?)' from an rvalue of type '(.+?)'",
    "replacement": "非法地用 '$2' 类型的右值初始化非只读的 '$1' 类型的引用"
  },
  {
    "id": "invalid initialization of reference of type %qH from expression of type %qI",
    "pattern": "invalid initialization of reference of type '(.+?)' from expression of type '(.+?)'",
    "replacement": "非法地用 '$2' 类型的表达式初始化 '$1' 类型的引用"
  },
  {
    "id": "cannot convert from pointer to base class %qT to pointer to derived class %qT because the base is virtual",
    "pattern": "cannot convert from pointer to base class '(.+?)' to pointer to derived class '(.+?)' because the base is virtual",
    "replacement": "不能将指向基类 '$1' 的指针转换为指向派生类 '$2' 的指针，因为基类是虚的"
  },
  {
    "id": "cannot convert from base class %qT to derived class %qT because the base is virtual",
    "pattern": "cannot convert from base class '(.+?)' to derived class '(.+?)' because the base is virtual",
    "replacement": "不能将基类 '$1' 转换到派生类 '$2'，因为基类是虚的"
  },
  {
    "id": "cannot convert from pointer to base class %qT to pointer to derived class %qT via virtual base %qT",
    "pattern": "cannot convert from pointer to base class '(.+?)' to pointer to derived class '(.+?)' via virtual base '(.+?)'",
    "replacement": "不能通过虚基类 '$3' 将指向基类 '$1' 的指针转换为指向派生类 '$2' 的指针"
  },
  {
    "id": "cannot convert from base class %qT to derived class %qT via virtual base %qT",
    "pattern": "cannot convert from base class '(.+?)' to derived class '(.+?)' via virtual base '(.+?)'",
    "replacement": "不能通过虚基类 '$3' 将指向基类 '$1' 转换到派生类 '$2'"
  },
  {
    "id": "cannot convert from %qT to base class %qT because %qT is incomplete",
    "pattern": "cannot convert from '(.+?)' to base class '(.+?)' because '(.+?)' is incomplete",
    "replacement": "不能将 '$1' 转换到基类 '$2'，因为 '$3' 是不完整类型"
  },
  {
    "id": "%q#D conflicts with version inherited from %qT",
    "pattern": "'(.+?)' conflicts with version inherited from '(.+?)'",
    "replacement": "'$1' 与从 '$2' 继承而来的版本冲突"
  },
  {
    "id": "version inherited from %qT declared here",
    "pattern": "version inherited from '(.+?)' declared here",
    "replacement": "从 '$1' 继承而来的版本在此声明"
  },
  {
    "id": "%q#D cannot be overloaded with %q#D",
    "pattern": "'(.+?)' cannot be overloaded with '(.+?)'",
    "replacement": "'$1' 不能重载 '$2'"
  },
  {
    "id": "previous declaration %q#D",
    "pattern": "previous declaration '(.+?)'",
    "replacement": "之前的声明 '$1'"
  },
  {
    "id": "conflicting access specifications for method %q+D, ignored",
    "pattern": "conflicting access specifications for method %q+D, ignored",
    "replacement": "方法 '$1' 的访问说明符冲突，已忽略"
  },
  {
    "id": "conflicting access specifications for field %qE, ignored",
    "pattern": "conflicting access specifications for field '(.+?)', ignored",
    "replacement": "字段 '$1' 的访问说明符冲突，已忽略"
  },
  {
    "id": "%qD invalid in %q#T because of local method %q#D with same name",
    "pattern": "'(.+?)' invalid in '(.+?)' because of local method '(.+?)' with same name",
    "replacement": "'$2' 中的 '$1' 无效，因为局部方法 '$3' 具有相同名字"
  },
  {
    "id": "local method %q#D declared here",
    "pattern": "local method '(.+?)' declared here",
    "replacement": "局部方法 '$3' 在此声明"
  },
  {
    "id": "%qD invalid in %q#T because of local member %q#D with same name",
    "pattern": "'(.+?)' invalid in '(.+?)' because of local member '(.+?)' with same name",
    "replacement": "'$2' 中的 '$1' 无效，因为局部成员 '$3' 具有相同名字"
  },
  {
    "id": "local member %q#D declared here",
    "pattern": "local member '(.+?)' declared here",
    "replacement": "局部成员 '$1' 在此声明"
  },
  {
    "id": "%qD inherits the %E ABI tag that %qT (used in its return type) has",
    "pattern": "'(.+?)' inherits the (.*?) ABI tag that '(.+?)' \\(used in its return type\\) has",
    "replacement": "'$1' 继承了 '$3'（在返回类型中使用）持有的 $2 ABI 标签"
  },
  {
    "id": "%qT declared here",
    "pattern": "'(.+?)' declared here",
    "replacement": "'$1' 在此声明"
  },
  {
    "id": "%qD inherits the %E ABI tag that %qT (used in its type) has",
    "pattern": "'(.+?)' inherits the (.*?) ABI tag that '(.+?)' \\(used in its type\\) has",
    "replacement": "'$1' 继承了 '$3'（在自身类型中使用）持有的 $2 ABI 标签"
  },
  {
    "id": "%qT does not have the %E ABI tag that base %qT has",
    "pattern": "'(.+?)' does not have the (.*?) ABI tag that base '(.+?)' has",
    "replacement": "'$1' 没有基类 '$3' 持有的 $2 ABI 标签"
  },
  {
    "id": "%qT does not have the %E ABI tag that %qT (used in the type of %qD) has",
    "pattern": "'(.+?)' does not have the (.*?) ABI tag that '(.+?)' (used in the type of '(.+?)') has",
    "replacement": "'$1' 没有 '$3'（在类型 '$4' 中使用）持有的 $2 ABI 标签"
  },
  {
    "id": "cannot derive from %<final%> base %qT in derived type %qT",
    "pattern": "cannot derive from 'final' base '(.+?)' in derived type '(.+?)'",
    "replacement": "不能从 'final' 基类 '$1' 派生派生类 '$2'"
  },
  {
    "id": "all member functions in class %qT are private",
    "pattern": "all member functions in class '(.+?)' are private",
    "replacement": "类 '$1' 中所有成员函数都是私有的"
  },
  {
    "id": "%q#T only defines a private destructor and has no friends",
    "pattern": "'(.+?)' only defines a private destructor and has no friends",
    "replacement": "'$1' 仅定义了一个私有析构函数且没有友元"
  },
  {
    "id": "%q#T only defines private constructors and has no friends",
    "pattern": "'(.+?)' only defines private constructors and has no friends",
    "replacement": "'$1' 仅定义了私有构造函数且没有友元"
  },
  {
    "id": "%q#D is public, but requires an existing %q#T object",
    "pattern": "'(.+?)' is public, but requires an existing '(.+?)' object",
    "replacement": "'$1' 是公开的，但要求一个存在的 '$1' 对象"
  },
  {
    "id": "no unique final overrider for %qD in %qT",
    "pattern": "no unique final overrider for '(.+?)' in '(.+?)'",
    "replacement": "'$2' 中 '$1' 最终覆盖不唯一"
  },
  {
    "id": "%qD can be marked override",
    "pattern": "'(.+?)' can be marked override",
    "replacement": "'$1' 可以被标记为 override"
  },
  {
    "id": "%q+#D marked %<override%>, but does not override",
    "pattern": "'(.+?)' marked 'override', but does not override",
    "replacement": "'$1' 被标记为 'override'，但它没有重写任何东西"
  },
  {
    "id": "%q+#D marked %<final%>, but is not virtual",
    "pattern": "'(.+?)' marked 'final', but is not virtual",
    "replacement": "'$1' 被标记为 'final'，但它不是虚的"
  },
  {
    "id": "%qD was hidden",
    "pattern": "'(.+?)' was hidden",
    "replacement": "'$1' 被隐藏"
  },
  {
    "id": "  by %qD",
    "pattern": "  by '(.+?)'",
    "replacement": "（由 '$1'）"
  },
  {
    "id": "%q#D invalid; an anonymous union may only have public non-static data members",
    "pattern": "'(.+?)' invalid; an anonymous union may only have public non-static data members",
    "replacement": "'$1' 无效；匿名联合体只能有非静态的数据成员"
  },
  {
    "id": "this flexibility is deprecated and will be removed",
    "pattern": "this flexibility is deprecated and will be removed",
    "replacement": "此适应性是被弃用的，且将被移除"
  },
  {
    "id": "the ellipsis in %qD is not inherited",
    "pattern": "the ellipsis in '(.+?)' is not inherited",
    "replacement": "'$1' 中的省略号未被继承"
  },
  {
    "id": "bit-field %q#D with non-integral type %qT",
    "pattern": "bit-field '(.+?)' with non-integral type '(.+?)'",
    "replacement": "位域 '$1' 的类型 '$2' 不是整数"
  },
  {
    "id": "bit-field %q+D width not an integer constant",
    "pattern": "bit-field '(.+?)' width not an integer constant",
    "replacement": "位域 '$1' 的宽度不是整数常量"
  },
  {
    "id": "negative width in bit-field %q+D",
    "pattern": "negative width in bit-field '(.+?)'",
    "replacement": "位域 '$1' 的宽度为负"
  },
  {
    "id": "zero width for bit-field %q+D",
    "pattern": "zero width for bit-field '(.+?)'",
    "replacement": "位域 '$1' 的宽度为 0"
  },
  {
    "id": "width of %qD exceeds its type",
    "pattern": "width of '(.+?)' exceeds its type",
    "replacement": "'$1' 的宽度超过了它的类型"
  },
  {
    "id": "%qD is too small to hold all values of %q#T",
    "pattern": "'(.+?)' is too small to hold all values of '(.+?)'",
    "replacement": "'$1' 太小，不能存放 '(.+?)' 的所有可能值"
  },
  {
    "id": "member %q+#D with constructor not allowed in union",
    "pattern": "member '(.+?)' with constructor not allowed in union",
    "replacement": "带构造函数的成员 '$1' 不能用在联合体中"
  },
  {
    "id": "member %q+#D with destructor not allowed in union",
    "pattern": "member '(.+?)' with destructor not allowed in union",
    "replacement": "带析构函数的成员 '$1' 不能用在联合体中"
  },
  {
    "id": "member %q+#D with copy assignment operator not allowed in union",
    "pattern": "member '(.+?)' with copy assignment operator not allowed in union",
    "replacement": "带复制赋值运算符的成员 '$1' 不能用在联合体中"
  },
  {
    "id": "unrestricted unions only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "unrestricted unions only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "无限制的联合体仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "in C++98 %q+D may not be static because it is a member of a union",
    "pattern": "in C\\+\\+98 '(.+?)' may not be static because it is a member of a union",
    "replacement": "C++98 中 '$1' 可能不是静态的，因为它是联合体的成员"
  },
  {
    "id": "non-static data member %q+D in a union may not have reference type %qT",
    "pattern": "non-static data member '(.+?)' in a union may not have reference type '(.+?)'",
    "replacement": "联合体的非静态数据成员 '$1' 不能是引用类型 '$2'"
  },
  {
    "id": "data member %q+D invalidly declared function type",
    "pattern": "data member '(.+?)' invalidly declared function type",
    "replacement": "数据成员 '$1' 非法地声明为函数类型"
  },
  {
    "id": "data member %q+D invalidly declared method type",
    "pattern": "data member '(.+?)' invalidly declared method type",
    "replacement": "数据成员 '$1' 非法地声明为方法类型"
  },
  {
    "id": "ignoring packed attribute because of unpacked non-POD field %q#D",
    "pattern": "ignoring packed attribute because of unpacked non-POD field '(.+?)'",
    "replacement": "为非紧实、非POD字段 '$1' 忽略 packed 特性"
  },
  {
    "id": "member %q+D cannot be declared as a %<mutable%> reference",
    "pattern": "member '(.+?)' cannot be declared as a 'mutable' reference",
    "replacement": "成员 '$1' 不能被声明为 'mutable' 引用"
  },
  {
    "id": "member %q+D cannot be declared both %<const%> and %<mutable%>",
    "pattern": "member '(.+?)' cannot be declared both 'const' and 'mutable'",
    "replacement": "成员 '$1' 不能同时声明为 'const' 和 'mutable'"
  },
  {
    "id": "multiple fields in union %qT initialized",
    "pattern": "multiple fields in union '(.+?)' initialized",
    "replacement": "初始化了联合体 '(.+?)' 中的多个字段"
  },
  {
    "id": "initialized member %q+D declared here",
    "pattern": "initialized member '(.+?)' declared here",
    "replacement": "已初始化成员 '$1' 在此声明"
  },
  {
    "id": "field %q#D with same name as class",
    "pattern": "field '(.+?)' with same name as class",
    "replacement": "字段 '$1' 的名字与类名相同"
  },
  {
    "id": "%q#T has pointer data members",
    "pattern": "'(.+?)' has pointer data members",
    "replacement": "'$1' 有指针数据成员"
  },
  {
    "id": "  but does not declare %<%T(const %T&)%>",
    "pattern": "  but does not declare '(.+?)\\(const (.+?)&\\)'",
    "replacement": "  但没有声明 '$1(const $2&)'"
  },
  {
    "id": "  or %<operator=(const %T&)%>",
    "pattern": "  or 'operator=\\(const (.+?)&\\)'",
    "replacement": "  或 'operator=(const $1&)'"
  },
  {
    "id": "  but does not declare %<operator=(const %T&)%>",
    "pattern": "  but does not declare 'operator=\\(const (.+?)&\\)'",
    "replacement": "  但没有声明 'operator=(const $1&)'"
  },
  {
    "id": "pointer member %q+D declared here",
    "pattern": "pointer member '(.+?)' declared here",
    "replacement": "指针成员 '$1' 在此声明"
  },
  {
    "id": "alignment of %qD increased in %<-fabi-version=9%> (GCC 5.2)",
    "pattern": "alignment of '(.+?)' increased in '-fabi-version=9' \\(GCC 5.2\\)",
    "replacement": "'$1' 的对齐在 '-fabi-version=9'（GCC 5.2）中增加"
  },
  {
    "id": "alignment of %qD will increase in %<-fabi-version=9%>",
    "pattern": "alignment of '(.+?)' will increase in '-fabi-version=9'",
    "replacement": "'$1' 的对齐将在 '-fabi-version=9' 中增加"
  },
  {
    "id": "initializer specified for non-virtual method %q+D",
    "pattern": "initializer specified for non-virtual method '(.+?)'",
    "replacement": "为非虚方法 '$1' 指定了初始化器"
  },
  {
    "id": "destructor for %qT is ambiguous",
    "pattern": "destructor for '(.+?)' is ambiguous",
    "replacement": "'$1' 的析构函数有歧义"
  },
  {
    "id": "method overrides both %<transaction_pure%> and %qE methods",
    "pattern": "method overrides both 'transaction_pure' and '(.+?)' methods",
    "replacement": "方法同时覆盖了 'transaction_pure' 和 '$1' 方法"
  },
  {
    "id": "method declared %qE overriding %qE method",
    "pattern": "method declared '(.+?)' overriding '(.+?)' method",
    "replacement": "声明为 '$1' 的方法覆盖了 '$2' 方法"
  },
  {
    "id": "enclosing class of %<constexpr%> non-static member function %q+#D is not a literal type",
    "pattern": "enclosing class of 'constexpr' non-static member function '(.+?)' is not a literal type",
    "replacement": "包含 'constexpr' 非静态成员函数的类 '$1' 不是字面类型"
  },
  {
    "id": "%q+T is not literal because:",
    "pattern": "'(.+?)' is not literal because:",
    "replacement": "'$1' 不是字面类型，因为："
  },
  {
    "id": "  %qT is a closure type, which is only literal in C++17 and later",
    "pattern": "  '(.+?)' is a closure type, which is only literal in C\\+\\+17 and later",
    "replacement": "  '$1' 是闭包类型，它在 C++17 及其之后才是字面类型"
  },
  {
    "id": "  %q+T has a non-trivial destructor",
    "pattern": "  '(.+?)' has a non-trivial destructor",
    "replacement": "  '$1' 有一个非平凡析构函数"
  },
  {
    "id": "  %q+T does not have %<constexpr%> destructor",
    "pattern": "  '(.+?)' does not have 'constexpr' destructor",
    "replacement": "  '$1' 不拥有 'constexpr' 析构函数"
  },
  {
    "id": "  %q+T is not an aggregate, does not have a trivial default constructor, and has no %<constexpr%> constructor that is not a copy or move constructor",
    "pattern": "  '(.+?)'is not an aggregate, does not have a trivial default constructor, and has no 'constexpr' constructor that is not a copy or move constructor",
    "replacement": "  '$1' 不是聚合体，不拥有平凡默认构造函数，且不拥有 'constexpr' 的复制或移动构造函数"
  },
  {
    "id": "  base class %qT of %q+T is non-literal",
    "pattern": "  base class '(.+?)' of '(.+?)' is non-literal",
    "replacement": "  '$2' 的基类 '$1' 不是字面类型"
  },
  {
    "id": "  non-static data member %qD has non-literal type",
    "pattern": "  non-static data member '(.+?)' has non-literal type",
    "replacement": "  非静态数据成员 '$1' 不具有字面类型"
  },
  {
    "id": "  non-static data member %qD has volatile type",
    "pattern": "  non-static data member '(.+?)' has volatile type",
    "replacement": "  非静态数据成员 '$1' 具有易变类型"
  },
  {
    "id": "base class %q#T has accessible non-virtual destructor",
    "pattern": "base class '(.+?)' has accessible non-virtual destructor",
    "replacement": "基类 '$1' 拥有可访问的非虚析构函数"
  },
  {
    "id": "non-static reference %q#D in class without a constructor",
    "pattern": "non-static reference '(.+?)' in class without a constructor",
    "replacement": "不含构造函数的类中存在非静态引用 '$1' "
  },
  {
    "id": "non-static const member %q#D in class without a constructor",
    "pattern": "non-static const member '(.+?)' in class without a constructor",
    "replacement": "不含构造函数的类中存在非静态只读成员 '$1'"
  },
  {
    "id": "direct base %qT inaccessible in %qT due to ambiguity",
    "pattern": "direct base '(.+?)' inaccessible in '(.+?)' due to ambiguity",
    "replacement": "由于存在歧义，直接基类 '$1' 在 '$2' 中不可访问"
  },
  {
    "id": "virtual base %qT inaccessible in %qT due to ambiguity",
    "pattern": "virtual base '(.+?)' inaccessible in '(.+?)' due to ambiguity",
    "replacement": "由于存在歧义，虚基类 '$1' 在 '$2' 中无法访问"
  },
  {
    "id": "offset of %qD is not ABI-compliant and may change in a future version of GCC",
    "pattern": "offset of '(.+?)' is not ABI-compliant and may change in a future version of GCC",
    "replacement": "'$1' 的偏移量是 ABI 不兼容的，并且在 GCC 的未来版本中可能会有变化"
  },
  {
    "id": "size of type %qT is too large (%qE bytes)",
    "pattern": "size of type '(.+?)' is too large ('(.+?)' bytes)",
    "replacement": "类型 '$1' 的大小太大（'$2' 字节）"
  },
  {
    "id": "invalid use of %q#T with a zero-size array in %q#D",
    "pattern": "invalid use of '(.+?)' with a zero-size array in '(.+?)'",
    "replacement": "对 '$2' 中零长度数组非法地使用了 '$1'"
  },
  {
    "id": "invalid use of %q#T with a flexible array member in %q#T",
    "pattern": "invalid use of '(.+?)' with a flexible array member in '(.+?)'",
    "replacement": "对 '$2' 中柔性数组非法地使用了 '$1'"
  },
  {
    "id": "array member %q#D declared here",
    "pattern": "array member '(.+?)' declared here",
    "replacement": "数组成员 '$1' 在此声明"
  },
  {
    "id": "zero-size array member %qD not at end of %q#T",
    "pattern": "zero-size array member '(.+?)' not at end of '(.+?)'",
    "replacement": "零长度数组成员 '$1' 没有出现在 '$2' 的末尾"
  },
  {
    "id": "zero-size array member %qD in an otherwise empty %q#T",
    "pattern": "zero-size array member '(.+?)' in an otherwise empty '(.+?)'",
    "replacement": "除零长度数组成员 '$1' 外，'$2' 是空的"
  },
  {
    "id": "in the definition of %q#T",
    "pattern": "in the definition of '(.+?)'",
    "replacement": "在 '$1' 的定义中"
  },
  {
    "id": "flexible array member %qD not at end of %q#T",
    "pattern": "flexible array member '(.+?)' not at end of '(.+?)'",
    "replacement": "柔性数组成员 '$1' 没有出现在 '$2' 的末尾"
  },
  {
    "id": "flexible array member %qD in an otherwise empty %q#T",
    "pattern": "flexible array member '(.+?)' in an otherwise empty '(.+?)'",
    "replacement": "除柔性数组成员 '$1' 外，'$2' 是空的"
  },
  {
    "id": "next member %q#D declared here",
    "pattern": "next member '(.+?)' declared here",
    "replacement": "下一个成员 '$2' 在此声明"
  },
  {
    "id": "redefinition of %q#T",
    "pattern": "redefinition of '(.+?)'",
    "replacement": "'$1' 的重定义"
  },
  {
    "id": "%q#T has virtual functions and accessible non-virtual destructor",
    "pattern": "'(.+?)' has virtual functions and accessible non-virtual destructor",
    "replacement": "'$1' 有虚函数和可访问的非虚析构函数"
  },
  {
    "id": "type transparent %q#T does not have any fields",
    "pattern": "type transparent '(.+?)' does not have any fields",
    "replacement": "类型透明的 '$1' 没有任何字段"
  },
  {
    "id": "type transparent class %qT has base classes",
    "pattern": "type transparent class '(.+?)' has base classes",
    "replacement": "类型透明类 '$1' 拥有基类"
  },
  {
    "id": "type transparent class %qT has virtual functions",
    "pattern": "type transparent class '(.+?)' has virtual functions",
    "replacement": "类型透明类 '$1' 拥有虚函数"
  },
  {
    "id": "type transparent %q#T cannot be made transparent because the type of the first field has a different ABI from the class overall",
    "pattern": "type transparent '(.+?)' cannot be made transparent because the type of the first field has a different ABI from the class overall",
    "replacement": "类型透明的 '$1' 不能为透明的，因为其第一个字段的类型和整个类的 ABI 不同"
  },
  {
    "id": "definition of %qD does not match %<#include <initializer_list>%>",
    "pattern": "definition of '(.+?)' does not match '#include <initializer_list>'",
    "replacement": "'$1' 的定义与 '#include <initializer_list>' 不匹配"
  },
  {
    "id": "trying to finish struct, but kicked out due to previous parse errors",
    "pattern": "trying to finish struct, but kicked out due to previous parse errors",
    "replacement": "试图完成结构体，但被先前的解析错误中断"
  },
  {
    "id": "language string %<\\\"%E\\\"%> not recognized",
    "pattern": "language string '(.+?)' not recognized",
    "replacement": "语言字符串 '$1'不可识别"
  },
  {
    "id": "cannot resolve overloaded function %qD based on conversion to type %qT",
    "pattern": "cannot resolve overloaded function '(.+?)' based on conversion to type '(.+?)'",
    "replacement": "基于到类型 '$2' 的转换，无法解析重载函数 '$1'"
  },
  {
    "id": "no matches converting function %qD to type %q#T",
    "pattern": "no matches converting function '(.+?)' to type '(.+?)'",
    "replacement": "从函数 '$1' 到类型 '$2' 没有匹配的转换"
  },
  {
    "id": "converting overloaded function %qD to type %q#T is ambiguous",
    "pattern": "converting overloaded function '(.+?)' to type '(.+?)' is ambiguous",
    "replacement": "将重载函数 '$1' 转换到类型 '$2' 有歧义"
  },
  {
    "id": "assuming pointer to member %qD",
    "pattern": "assuming pointer to member '(.+?)'",
    "replacement": "假定是成员指针 '$1'"
  },
  {
    "id": "(a pointer to member can only be formed with %<&%E%>)",
    "pattern": "\\(a pointer to member can only be formed with '&(.+?)'\\)",
    "replacement": "（成员指针只能由 '&$1' 构成）"
  },
  {
    "id": "not enough type information",
    "pattern": "not enough type information",
    "replacement": "类型信息不足"
  },
  {
    "id": "cannot convert %qE from type %qT to type %qT",
    "pattern": "cannot convert '(.+?)' from type '(.+?)' to type '(.+?)'",
    "replacement": "不能将 '$1' 从类型 '$2' 转换到类型 '$3'"
  },
  {
    "id": "declaration of %q#D changes meaning of %qD",
    "pattern": "declaration of '(.+?)' changes meaning of '(.+?)'",
    "replacement": "'$1' 的声明改变了 '$2' 的含义"
  },
  {
    "id": "%qD declared here as %q#D",
    "pattern": "'(.+?)' declared here as '(.+?)'",
    "replacement": "'$1' 此处又被声明为 '$2'"
  },
  {
    "id": "the type %qT of %<constexpr%> variable %qD is not literal",
    "pattern": "the type '(.+?)' of 'constexpr' variable '(.+?)' is not literal",
    "replacement": "'constexpr' 变量 '$2' 的类型 '$1' 不是字面类型"
  },
  {
    "id": "variable %qD of non-literal type %qT in %<constexpr%> function",
    "pattern": "variable '(.+?)' of non-literal type '(.+?)' in 'constexpr' function",
    "replacement": "'constexpr' 函数中的变量 '$1' 具有非字面类型 '$2'"
  },
  {
    "id": "%<constexpr%> variable %qD has variably-modified type %qT",
    "pattern": "'constexpr' variable '(.+?)' has variably-modified type '(.+?)'",
    "replacement": "'constexpr' 变量 '$1' 具有可变修改类型 '$2'"
  },
  {
    "id": "inherited constructor %qD is not %<constexpr%>",
    "pattern": "inherited constructor '(.+?)' is not 'constexpr'",
    "replacement": "继承而来的构造函数 '$1' 不是 'constexpr'"
  },
  {
    "id": "invalid type for parameter %d of %<constexpr%> function %q+#D",
    "pattern": "invalid type for parameter (\\d+) of 'constexpr' function '(.+?)'",
    "replacement": "'constexpr' 函数 '$2' 的第 $1 个形参类型非法"
  },
  {
    "id": "lambdas are implicitly %<constexpr%> only in C++17 and later",
    "pattern": "lambdas are implicitly 'constexpr' only in C\\+\\+17 and later",
    "replacement": "lambda 表达式仅在 C++17 及其之后才是隐式 'constexpr' 的"
  },
  {
    "id": "invalid return type %qT of %<constexpr%> function %q+D",
    "pattern": "invalid return type '(.+?)' of 'constexpr' function '(.+?)'",
    "replacement": "'constexpr' 函数 '$2' 的返回类型 '$1' 非法"
  },
  {
    "id": "%q#T has virtual base classes",
    "pattern": "'(.+?)' has virtual base classes",
    "replacement": "'$1' 拥有虚基类"
  },
  {
    "id": "%<constexpr%> constructor does not have empty body",
    "pattern": "'constexpr' constructor does not have empty body",
    "replacement": "'constexpr' 构造函数没有空函数体"
  },
  {
    "id": "%<constexpr%> constructor for union %qT must initialize exactly one non-static data member",
    "pattern": "'constexpr' constructor for union '(.+?)' must initialize exactly one non-static data member",
    "replacement": "'constexpr' 构造函数必须初始化联合体 '$1' 中仅一个非静态数据成员"
  },
  {
    "id": "member %qD must be initialized by mem-initializer in %<constexpr%> constructor",
    "pattern": "member '(.+?)' must be initialized by mem-initializer in 'constexpr' constructor",
    "replacement": "成员 '$1' 必须被 'constexpr' 构造函数的内存初始化器初始化"
  },
  {
    "id": "body of %<constexpr%> function %qD not a return-statement",
    "pattern": "body of 'constexpr' function '(.+?)' not a return-statement",
    "replacement": "'constexpr' 函数 '$1' 的函数体不是一条返回语句"
  },
  {
    "id": "%qD is not usable as a %<constexpr%> function because:",
    "pattern": "'(.+?)' is not usable as a 'constexpr' function because:",
    "replacement": "'$1' 不能被用作 'constexpr' 函数，因为："
  },
  {
    "id": "%<constexpr%> call flows off the end of the function",
    "pattern": "'constexpr' call flows off the end of the function",
    "replacement": "控制流抵达 'constexpr' 调用函数的结尾"
  },
  {
    "id": "%q+E is not a constant expression",
    "pattern": "'(.+?)' is not a constant expression",
    "replacement": "'$1' 不是常量表达式"
  },
  {
    "id": "call to internal function %qE",
    "pattern": "call to internal function '(.+?)'",
    "replacement": "对内部函数 '$1' 的调用"
  },
  {
    "id": "modifying a const object %qE is not allowed in a constant expression",
    "pattern": "modifying a const object '(.+?)' is not allowed in a constant expression",
    "replacement": "不允许在常量表达式中修改只读变量 '$1'"
  },
  {
    "id": "originally declared %<const%> here",
    "pattern": "originally declared 'const' here",
    "replacement": "原先于此处声明为 'const'"
  },
  {
    "id": "reference %<dynamic_cast%> failed",
    "pattern": "reference 'dynamic_cast' failed",
    "replacement": "引用的 'dynamic_cast' 失败"
  },
  {
    "id": "dynamic type %qT of its operand does not have a base class of type %qT",
    "pattern": "dynamic type '(.+?)' of its operand does not have a base class of type '(.+?)'",
    "replacement": "其操作数的动态类型 '$1' 不拥有 '$2' 类型的基类"
  },
  {
    "id": "virtual table pointer is used uninitialized",
    "pattern": "virtual table pointer is used uninitialized",
    "replacement": "虚表指针使用时未初始化"
  },
  {
    "id": "static type %qT of its operand is a non-public base class of dynamic type %qT",
    "pattern": "static type '(.+?)' of its operand is a non-public base class of dynamic type '(.+?)'",
    "replacement": "其操作数的静态类型 '$1' 是动态类型 '$2' 的非公开基类"
  },
  {
    "id": "%qT is an ambiguous base class of dynamic type %qT of its operand",
    "pattern": "'(.+?)' is an ambiguous base class of dynamic type '(.+?)' of its operand",
    "replacement": "'$1' 是其操作数的动态类型 '$2' 的有歧义基类"
  },
  {
    "id": "dynamic type %qT of its operand does not have an unambiguous public base class %qT",
    "pattern": "dynamic type '(.+?)' of its operand does not have an unambiguous public base class '(.+?)'",
    "replacement": "其操作数的动态类型 '$1' 不拥有一个无歧义公开基类 '$2'"
  },
  {
    "id": "call to non-%<constexpr%> function %qD",
    "pattern": "call to non-'constexpr' function '(.+?)'",
    "replacement": "调用非 'constexpr' 函数 '$1'"
  },
  {
    "id": "expression %qE does not designate a %<constexpr%> function",
    "pattern": "expression '(.+?)' does not designate a 'constexpr' function",
    "replacement": "表达式 '$1' 不指派一个 'constexpr' 函数"
  },
  {
    "id": "array deallocation of object allocated with non-array allocation",
    "pattern": "array deallocation of object allocated with non-array allocation",
    "replacement": "由非数组形式分配得到的对象被数组形式释放"
  },
  {
    "id": "allocation performed here",
    "pattern": "allocation performed here",
    "replacement": "分配在这里进行"
  },
  {
    "id": "non-array deallocation of object allocated with array allocation",
    "pattern": "non-array deallocation of object allocated with array allocation",
    "replacement": "由数组形式分配得到的对象被非数组形式释放"
  },
  {
    "id": "deallocation of already deallocated storage",
    "pattern": "deallocation of already deallocated storage",
    "replacement": "释放已经释放过的存储空间"
  },
  {
    "id": "deallocation of storage that was not previously allocated",
    "pattern": "deallocation of storage that was not previously allocated",
    "replacement": "释放之前未经分配的存储空间"
  },
  {
    "id": "%qD called in a constant expression before its definition is complete",
    "pattern": "'(.+?)' called in a constant expression before its definition is complete",
    "replacement": "'$1' 在完整定义出现前在常量表达式中调用"
  },
  {
    "id": "%qD called in a constant expression",
    "pattern": "'(.+?)' called in a constant expression",
    "replacement": "'$1' 在常量表达式中调用"
  },
  {
    "id": "%qD used before its definition",
    "pattern": "'(.+?)' used before its definition",
    "replacement": "'$1' 的使用早于其定义"
  },
  {
    "id": "call has circular dependency",
    "pattern": "call has circular dependency",
    "replacement": "调用存在循环依赖"
  },
  {
    "id": "%<constexpr%> evaluation depth exceeds maximum of %d (use %<-fconstexpr-depth=%> to increase the maximum)",
    "pattern": "'constexpr' evaluation depth exceeds maximum of (\\d+) \\(use '-fconstexpr-depth=' to increase the maximum\\)",
    "replacement": "'constexpr' 求值深度超过最大值 $1（使用 '-fconstexpr-depth=' 来增加最大值）"
  },
  {
    "id": "right operand of shift expression %q+E is negative",
    "pattern": "right operand of shift expression '(.+?)' is negative",
    "replacement": "移位表达式的右操作数 '$1' 是负的"
  },
  {
    "id": "right operand of shift expression %q+E is greater than or equal to the precision %wu of the left operand",
    "pattern": "right operand of shift expression '(.+?)' is greater than or equal to the precision (.*?) of the left operand",
    "replacement": "移位表达式的右操作数 '$1' 大于等于左操作数的精度 '$2'"
  },
  {
    "id": "left operand of shift expression %q+E is negative",
    "pattern": "left operand of shift expression '(.+?)' is negative",
    "replacement": "移位表达式的左操作数 '$1' 是负的"
  },
  {
    "id": "shift expression %q+E overflows",
    "pattern": "shift expression '(.+?)' overflows",
    "replacement": "移位表达式 '$1' 溢出"
  },
  {
    "id": "arithmetic involving a null pointer in %qE",
    "pattern": "arithmetic involving a null pointer in '(.+?)'",
    "replacement": "'$1' 中空指针参与了算术运算"
  },
  {
    "id": "array subscript value %qE is outside the bounds of array %qD of type %qT",
    "pattern": "array subscript value '(.+?)' is outside the bounds of array '(.+?)' of type '(.+?)'",
    "replacement": "数组下标值 '$1' 超过了 '$3' 类型的数组 '$2' 的边界"
  },
  {
    "id": "nonzero array subscript %qE is used with array %qD of type %qT with unknown bounds",
    "pattern": "nonzero array subscript '(.+?)' is used with array '(.+?)' of type '(.+?)' with unknown bounds",
    "replacement": "非零数组下标 '$1' 被用于 '$3' 类型的未知边界数组 '$2'"
  },
  {
    "id": "array subscript value %qE is outside the bounds of array type %qT",
    "pattern": "array subscript value '(.+?)' is outside the bounds of array type '(.+?)'",
    "replacement": "数组下标值 '$1' 超过了 '$2' 类型的数组的边界"
  },
  {
    "id": "nonzero array subscript %qE is used with array of type %qT with unknown bounds",
    "pattern": "nonzero array subscript '(.+?)' is used with array of type '(.+?)' with unknown bounds",
    "replacement": "非零数组下标 '$1' 被用于 '$2' 类型的未知边界数组"
  },
  {
    "id": "accessing uninitialized array element",
    "pattern": "accessing uninitialized array element",
    "replacement": "访问未初始化的数组元素"
  },
  {
    "id": "dereferencing a null pointer in %qE",
    "pattern": "dereferencing a null pointer in '(.+?)'",
    "replacement": "对 '$1' 中的空指针解地址"
  },
  {
    "id": "%qE is not a constant expression",
    "pattern": "'(.+?)' is not a constant expression",
    "replacement": "'$1' 不是一个常量表达式"
  },
  {
    "id": "mutable %qD is not usable in a constant expression",
    "pattern": "mutable '(.+?)' is not usable in a constant expression",
    "replacement": "可变的 '$1' 不能在常量表达式中使用"
  },
  {
    "id": "accessing uninitialized member %qD",
    "pattern": "accessing uninitialized member '(.+?)'",
    "replacement": "访问未初始化的成员 '$1'"
  },
  {
    "id": "accessing %qD member instead of initialized %qD member in constant expression",
    "pattern": "accessing '(.+?)' member instead of initialized '(.+?)' member in constant expression",
    "replacement": "在常量表达式中访问 '$1' 成员而非初始化 '$2' 成员"
  },
  {
    "id": "%qs is not a constant expression because %qT is a union type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' is a union type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 是联合体类型"
  },
  {
    "id": "%qs is not a constant expression because %qT contains a union type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' contains a union type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 包含联合体类型"
  },
  {
    "id": "%qs is not a constant expression because %qT is a pointer type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' is a pointer type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 是指针类型"
  },
  {
    "id": "%qs is not a constant expression because %qT contains a pointer type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' contains a pointer type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 包含指针类型"
  },
  {
    "id": "%qs is not a constant expression because %qT is a reference type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' is a reference type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 是引用类型"
  },
  {
    "id": "%qs is not a constant expression because %qT contains a reference type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' contains a reference type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 包含引用类型"
  },
  {
    "id": "%qs is not a constant expression because %qT is a pointer to member type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' is a pointer to member type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 是成员指针类型"
  },
  {
    "id": "%qs is not a constant expression because %qT contains a pointer to member type",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' contains a pointer to member type",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 包含成员指针类型"
  },
  {
    "id": "%qs is not a constant expression because %qT is volatile",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' is volatile",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 是易变的"
  },
  {
    "id": "%qs is not a constant expression because %qT contains a volatile subobject",
    "pattern": "'(.+?)' is not a constant expression because '(.+?)' contains a volatile subobject",
    "replacement": "'$1' 不是常量表达式，因为 '$2' 包含易变的子对象"
  },
  {
    "id": "%qs cannot be constant evaluated on the target",
    "pattern": "'(.+?)' cannot be constant evaluated on the target",
    "replacement": "'$1' 不能在此目标上被常量求值"
  },
  {
    "id": "%qs cannot be constant evaluated because the type is too large",
    "pattern": "'(.+?)' cannot be constant evaluated because the type is too large",
    "replacement": "'$1' 不能被常量求值，因为其类型太大"
  },
  {
    "id": "%qs cannot be constant evaluated because the argument cannot be encoded",
    "pattern": "'(.+?)' cannot be constant evaluated because the argument cannot be encoded",
    "replacement": "'$1' 不能被常量求值，因为无法解码其实参"
  },
  {
    "id": "%qs accessing uninitialized byte at offset %d",
    "pattern": "'(.+?)' accessing uninitialized byte at offset (\\d+)",
    "replacement": "'$1' 在偏置 $2 处访问未初始化的字节"
  },
  {
    "id": "%qs cannot be constant evaluated because the argument cannot be interpreted",
    "pattern": "'(.+?)' cannot be constant evaluated because the argument cannot be interpreted",
    "replacement": "'$1' 不能被常量求值，因为无法解释其实参"
  },
  {
    "id": "dereferencing a null pointer",
    "pattern": "dereferencing a null pointer",
    "replacement": "对空指针解地址"
  },
  {
    "id": "accessing value of %qE through a %qT glvalue in a constant expression",
    "pattern": "accessing value of '(.+?)' through a '(.+?)' glvalue in a constant expression",
    "replacement": "在常量表达式中通过泛左值 '$2' 访问 '$1' 的值"
  },
  {
    "id": "the content of uninitialized storage is not usable in a constant expression",
    "pattern": "the content of uninitialized storage is not usable in a constant expression",
    "replacement": "常量表达式中未经初始化的存储空间内容是不可用的"
  },
  {
    "id": "allocated here",
    "pattern": "allocated here",
    "replacement": "在此分配"
  },
  {
    "id": "use of allocated storage after deallocation in a constant expression",
    "pattern": "use of allocated storage after deallocation in a constant expression",
    "replacement": "常量表达式中使用已释放的分配存储空间"
  },
  {
    "id": "the value of %qD is not usable in a constant expression",
    "pattern": "the value of '(.+?)' is not usable in a constant expression",
    "replacement": "常量表达式中 '$1' 的值不可用"
  },
  {
    "id": "%qD used in its own initializer",
    "pattern": "'(.+?)' used in its own initializer",
    "replacement": "'$1' 用在其自身的初始化器中"
  },
  {
    "id": "%q#D is not const",
    "pattern": "'(.+?)' is not const",
    "replacement": "'$1'不是只读的"
  },
  {
    "id": "%q#D is volatile",
    "pattern": "'(.+?)' is volatile",
    "replacement": "'$1' 是易变的"
  },
  {
    "id": "%qD was not initialized with a constant expression",
    "pattern": "'(.+?)' was not initialized with a constant expression",
    "replacement": "'$1' 在常量表达式中未初始化"
  },
  {
    "id": "%qD was not declared %<constexpr%>",
    "pattern": "'(.+?)' was not declared 'constexpr'",
    "replacement": "'$1' 未声明为 'constexpr'"
  },
  {
    "id": "%qD does not have integral or enumeration type",
    "pattern": "'(.+?)' does not have integral or enumeration type",
    "replacement": "'$1' 不具有整数或枚举类型"
  },
  {
    "id": "modification of %qE is not a constant expression",
    "pattern": "modification of '(.+?)' is not a constant expression",
    "replacement": "修改 '$1' 不是常量表达式"
  },
  {
    "id": "change of the active member of a union from %qD to %qD",
    "pattern": "change of the active member of a union from '(.+?)' to '(.+?)'",
    "replacement": "切换联合体的活跃成员从 '$1' 到 '$2'"
  },
  {
    "id": "change of the active member of a union from %qD to %qD during initialization",
    "pattern": "change of the active member of a union from '(.+?)' to '(.+?)' during initialization",
    "replacement": "在初始化中，切换联合体的活跃成员从 '$1' 到 '$2'"
  },
  {
    "id": "statement is not a constant expression",
    "pattern": "statement is not a constant expression",
    "replacement": "语句不是常量表达式"
  },
  {
    "id": "%<constexpr%> loop iteration count exceeds limit of %d (use %<-fconstexpr-loop-limit=%> to increase the limit)",
    "pattern": "'constexpr' loop iteration count exceeds limit of (\\d+) \\(use '-fconstexpr-loop-limit=' to increase the limit\\)",
    "replacement": "'constexpr' 循环迭代数量超过 $1 次的限制（使用 '-fconstexpr-loop-limit=' 来增加此限制）"
  },
  {
    "id": "inline assembly is not a constant expression",
    "pattern": "inline assembly is not a constant expression",
    "replacement": "内联汇编不是常量表达式"
  },
  {
    "id": "only unevaluated inline assembly is allowed in a %<constexpr%> function in C++20",
    "pattern": "only unevaluated inline assembly is allowed in a 'constexpr' function in C\\+\\+20",
    "replacement": "在 C++20 中只允许不求值的内联汇编出现在 'constexpr' 函数中"
  },
  {
    "id": "value %qE of type %qT is not a constant expression",
    "pattern": "value '(.+?)' of type '(.+?)' is not a constant expression",
    "replacement": "'$2' 类型的值 '$1' 不是常量表达式"
  },
  {
    "id": "%<constexpr%> evaluation operation count exceeds limit of %wd (use %<-fconstexpr-ops-limit=%> to increase the limit)",
    "pattern": "'constexpr' evaluation operation count exceeds limit of (.*?) \\(use '-fconstexpr-ops-limit=' to increase the limit\\)",
    "replacement": "'constexpr' 求值操作数量超过 $1 次的限制（使用 '-fconstexpr-ops-limit=' 来增加此限制）"
  },
  {
    "id": "temporary of non-literal type %qT in a constant expression",
    "pattern": "temporary of non-literal type '(.+?)' in a constant expression",
    "replacement": "常量表达式中临时的非字面类型 '$1'"
  },
  {
    "id": "%<reinterpret_cast%> is not a constant expression",
    "pattern": "'reinterpret_cast' is not a constant expression",
    "replacement": "'reinterpret_cast' 不是常量表达式"
  },
  {
    "id": "conversion from pointer type %qT to arithmetic type %qT in a constant expression",
    "pattern": "conversion from pointer type '(.+?)' to arithmetic type '(.+?)' in a constant expression",
    "replacement": "常量表达式中从指针类型 '$1' 转换到算术类型 '$2'"
  },
  {
    "id": "cast from %qT is not allowed",
    "pattern": "cast from '(.+?)' is not allowed",
    "replacement": "不允许从 '$1' 的类型转换"
  },
  {
    "id": "%<reinterpret_cast<%T>(%E)%> is not a constant expression",
    "pattern": "'reinterpret_cast<(.*?)>\\((.*?)\\)' is not a constant expression",
    "replacement": "'reinterpret_cast<$1>($2)' 不是常量表达式"
  },
  {
    "id": "expression %qE is not a constant expression",
    "pattern": "expression '(.+?)' is not a constant expression",
    "replacement": "表达式 '$1' 不是常量表达式"
  },
  {
    "id": "unexpected template-id %qE",
    "pattern": "unexpected template-id '(.+?)'",
    "replacement": "意外的模板标识 '$1'"
  },
  {
    "id": "function concept must be called",
    "pattern": "function concept must be called",
    "replacement": "函数概念必须被调用"
  },
  {
    "id": "address of a call to %qs is not a constant expression",
    "pattern": "address of a call to '(.+?)' is not a constant expression",
    "replacement": "调用 '$1' 的地址不是常量表达式"
  },
  {
    "id": "unexpected expression %qE of kind %s",
    "pattern": "unexpected expression '(.+?)' of kind (.*?)",
    "replacement": "意外的 '$2' 类别的表达式 '$1'"
  },
  {
    "id": "%qE is not a constant expression because it refers to mutable subobjects of %qT",
    "pattern": "'(.+?)' is not a constant expression because it refers to mutable subobjects of '(.+?)'",
    "replacement": "'$1' 不是常量表达式，因为它指示了 '$2' 的可变子类型"
  },
  {
    "id": "%qE is not a constant expression because it refers to an incompletely initialized variable",
    "pattern": "'(.+?)' is not a constant expression because it refers to an incompletely initialized variable",
    "replacement": "'$1' 不是常量表达式，因为它指示了未完整初始化的变量"
  },
  {
    "id": "%qE is not a constant expression because it refers to a result of %<operator new%>",
    "pattern": "'(.+?)' is not a constant expression because it refers to a result of 'operator new'",
    "replacement": "'$1' 不是常量表达式，因为它指示了 'operator new' 的结果"
  },
  {
    "id": "%qE is not a constant expression because allocated storage has not been deallocated",
    "pattern": "'(.+?)' is not a constant expression because allocated storage has not been deallocated",
    "replacement": "'$1' 不是常量表达式，因为它分配的内存空间未被释放"
  },
  {
    "id": "immediate evaluation returns address of immediate function %qD",
    "pattern": "immediate evaluation returns address of immediate function '(.+?)'",
    "replacement": "立即求值返回了立即函数 '$1' 的地址"
  },
  {
    "id": "lvalue-to-rvalue conversion of a volatile lvalue %qE with type %qT",
    "pattern": "lvalue-to-rvalue conversion of a volatile lvalue '(.+?)' with type '(.+?)'",
    "replacement": "'$2' 类型的易变左值 '$1' 的左值到右值转换"
  },
  {
    "id": "lambda capture of %qE is not a constant expression",
    "pattern": "lambda capture of '(.+?)' is not a constant expression",
    "replacement": "'$1' 的 lambda 捕获不是常量表达式"
  },
  {
    "id": "because it is used as a glvalue",
    "pattern": "because it is used as a glvalue",
    "replacement": "因为它以泛左值使用"
  },
  {
    "id": "%<reinterpret_cast%> from integer to pointer",
    "pattern": "'reinterpret_cast' from integer to pointer",
    "replacement": "转换整数为指针的 'reinterpret_cast'"
  },
  {
    "id": "address-of an object %qE with thread local or automatic storage is not a constant expression",
    "pattern": "address-of an object '(.+?)' with thread local or automatic storage is not a constant expression",
    "replacement": "线程局部或自动存储期的对象 '(.+?)' 的地址并非常量表达式"
  },
  {
    "id": "use of %<this%> in a constant expression",
    "pattern": "use of 'this' in a constant expression",
    "replacement": "在常量表达式中使用 'this'"
  },
  {
    "id": "lambda-expression is not a constant expression before C++17",
    "pattern": "lambda-expression is not a constant expression before C\\+\\+17",
    "replacement": "lambda 表达式在 C++17 前不是常量表达式"
  },
  {
    "id": "virtual functions cannot be %<constexpr%> before C++20",
    "pattern": "virtual functions cannot be 'constexpr' before C\\+\\+20",
    "replacement": "C++20 前，虚函数不能是 'constexpr'"
  },
  {
    "id": "%<typeid%> is not a constant expression because %qE is of polymorphic type",
    "pattern": "'typeid' is not a constant expression because '(.+?)' is of polymorphic type",
    "replacement": "'typeid' 不是常量表达式，因为 '$1' 是多态类型"
  },
  {
    "id": "cast to non-integral type %qT in a constant expression",
    "pattern": "cast to non-integral type '(.+?)' in a constant expression",
    "replacement": "常量表达式中转换非整数类型 '$1'"
  },
  {
    "id": "%qD declared %<static%> in %<constexpr%> context",
    "pattern": "'(.+?)' declared 'static' in 'constexpr' context",
    "replacement": "在 'constexpr' 语境中，'$1' 被声明为 'static'"
  },
  {
    "id": "%qD declared %<thread_local%> in %<constexpr%> context",
    "pattern": "'(.+?)' declared 'thread_local' in 'constexpr' context",
    "replacement": "在 'constexpr' 语境中，'$1' 被声明为 'thread_local'"
  },
  {
    "id": "division by zero is not a constant expression",
    "pattern": "division by zero is not a constant expression",
    "replacement": "除以零不是常量表达式"
  },
  {
    "id": "%<delete[]%> is not a constant expression",
    "pattern": "'delete[]' is not a constant expression",
    "replacement": "'delete[]' 不是常量表达式"
  },
  {
    "id": "non-constant array initialization",
    "pattern": "non-constant array initialization",
    "replacement": "非常量数组初始化"
  },
  {
    "id": "%<goto%> is not a constant expression",
    "pattern": "'goto' is not a constant expression",
    "replacement": "'goto' 不是常量表达式"
  },
  {
    "id": "label definition is not a constant expression",
    "pattern": "label definition is not a constant expression",
    "replacement": "标号定义不是常量表达式"
  },
  {
    "id": "unexpected AST of kind %s",
    "pattern": "unexpected AST of kind (.*?)",
    "replacement": "意外的 AST 类别 '$1'"
  },
  {
    "id": "both branches of %<if%> statement marked as %qs",
    "pattern": "both branches of 'if' statement marked as '(.+?)'",
    "replacement": "'if' 的两个分支都被标记为 '$1'"
  },
  {
    "id": "%<throw%> will always call %<terminate%>",
    "pattern": "'throw' will always call 'terminate'",
    "replacement": "'throw' 总是会调用 'terminate'"
  },
  {
    "id": "in C++11 destructors default to %<noexcept%>",
    "pattern": "in C\\+\\+11 destructors default to 'noexcept'",
    "replacement": "在 C++11 中，析构函数默认为 'noexcept'"
  },
  {
    "id": "in C++11 this %<throw%> will call %<terminate%> because destructors default to %<noexcept%>",
    "pattern": "in C\\+\\+11 this 'throw' will call 'terminate' because destructors default to 'noexcept'",
    "replacement": "在 C++11 中，此 'throw' 会调用 'terminate'，因为析构函数默认为 'noexcept'"
  },
  {
    "id": "ignoring attribute %qE after earlier %qE",
    "pattern": "ignoring attribute '(.+?)' after earlier '(.+?)'",
    "replacement": "忽略较早的 '$2' 之后的特性 '$1'"
  },
  {
    "id": "%qD is not a type",
    "pattern": "'(.+?)' is not a type",
    "replacement": "'$1' 不是类型"
  },
  {
    "id": "%qD is not a class type",
    "pattern": "'(.+?)' is not a class type",
    "replacement": "'$1' 不是类类型"
  },
  {
    "id": "%qD does not have %<const char *%> type",
    "pattern": "'(.+?)' does not have 'const char *' type",
    "replacement": "'$1' 不具有 'const char *' 类型"
  },
  {
    "id": "%qD does not have integral type",
    "pattern": "'(.+?)' does not have integral type",
    "replacement": "'$1' 不具有整数类型"
  },
  {
    "id": "%<std::source_location::__impl%> does not contain only non-static data members %<_M_file_name%>, %<_M_function_name%>, %<_M_line%> and %<_M_column%>",
    "pattern": "'std::source_location::__impl' does not contain only non-static data members '_M_file_name', '_M_function_name', '_M_line' and '_M_column'",
    "replacement": "'std::source_location::__impl' 不包含任何非静态数据成员 '_M_file_name'、'_M_function_name'、'_M_line' 和 '_M_column'"
  },
  {
    "id": "evaluating %qs",
    "pattern": "evaluating '(.+?)'",
    "replacement": "求值 '$1' 中"
  },
  {
    "id": "cannot convert from incomplete type %qH to %qI",
    "pattern": "cannot convert from incomplete type '(.+?)' to '(.+?)'",
    "replacement": "无法从不完整类型 '$1' 转换到 '$2'"
  },
  {
    "id": "conversion of %qE from %qH to %qI is ambiguous",
    "pattern": "conversion of '(.+?)' from '(.+?)' to '(.+?)' is ambiguous",
    "replacement": "将 '$1' 从 '$2' 转换到 '$3' 有歧义"
  },
  {
    "id": "cannot convert %qE from type %qH to type %qI",
    "pattern": "cannot convert '(.+?)' from type '(.+?)' to type '(.+?)'",
    "replacement": "不能将 '$1' 从类型 '$2' 转换到类型 '$3'"
  },
  {
    "id": "initialization of volatile reference type %q#T from rvalue of type %qT",
    "pattern": "initialization of volatile reference type '(.+?)' from rvalue of type '(.+?)'",
    "replacement": "用 '$2' 类型的右值初始化 '$1' 类型的易变引用"
  },
  {
    "id": "conversion to volatile reference type %q#T from rvalue of type %qT",
    "pattern": "conversion to volatile reference type '(.+?)' from rvalue of type '(.+?)'",
    "replacement": "将 '$2' 类型的右值转换到 '$1' 类型的易变引用"
  },
  {
    "id": "initialization of non-const reference type %q#T from rvalue of type %qT",
    "pattern": "initialization of non-const reference type '(.+?)' from rvalue of type '(.+?)'",
    "replacement": "用 '$2' 类型的右值初始化 '$2' 类型的非只读引用"
  },
  {
    "id": "conversion to non-const reference type %q#T from rvalue of type %qT",
    "pattern": "conversion to non-const reference type '(.+?)' from rvalue of type '(.+?)'",
    "replacement": "将'$2' 类型的右值转换到 '$1' 类型的非只读引用"
  },
  {
    "id": "conversion from %qH to %qI discards qualifiers",
    "pattern": "conversion from '(.+?)' to '(.+?)' discards qualifiers",
    "replacement": "从 '$1' 到 '$2' 的转换丢失了限定符"
  },
  {
    "id": "casting %qT to %qT does not dereference pointer",
    "pattern": "casting '(.+?)' to '(.+?)' does not dereference pointer",
    "replacement": "从 '$1' 转换到 '$2' 时未对指针解地址"
  },
  {
    "id": "cannot convert type %qH to type %qI",
    "pattern": "cannot convert type '(.+?)' to type '(.+?)'",
    "replacement": "不能将类型 '$1' 转换到类型 '$2'"
  },
  {
    "id": "conversion from %q#T to %q#T",
    "pattern": "conversion from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 的转换"
  },
  {
    "id": "the result of the conversion is unspecified because %qE is outside the range of type %qT",
    "pattern": "the result of the conversion is unspecified because '(.+?)' is outside the range of type '(.+?)'",
    "replacement": "转换的结果是未指明的，因为 '$1' 超过了类型 '$2' 的范围"
  },
  {
    "id": "%q#T used where a %qT was expected",
    "pattern": "'(.+?)' used where a '(.+?)' was expected",
    "replacement": "期望一个 '$2'，但 '$1' 被使用"
  },
  {
    "id": "could not convert %qE from %<void%> to %<bool%>",
    "pattern": "could not convert '(.+?)' from 'void' to 'bool'",
    "replacement": "不能将 '$1' 从 'void' 转换到 'bool'"
  },
  {
    "id": "%q#T used where a floating-point value was expected",
    "pattern": "'(.+?)' used where a floating-point value was expected",
    "replacement": "期望一个浮点值，但 '$1' 被使用"
  },
  {
    "id": "conversion from %qH to non-scalar type %qI requested",
    "pattern": "conversion from '(.+?)' to non-scalar type '(.+?)' requested",
    "replacement": "请求从 '$1' 到非标量类型 '$2' 的转换"
  },
  {
    "id": "ignoring return value of %qD, declared with attribute %<nodiscard%>: %<%s%>",
    "pattern": "ignoring return value of '(.+?)', declared with attribute 'nodiscard': '(.+?)'",
    "replacement": "忽略声明有 'nodiscard' 特性的 '$1' 的返回值：'$2'"
  },
  {
    "id": "ignoring return value of %qD, declared with attribute %<nodiscard%>%s",
    "pattern": "ignoring return value of '(.+?)', declared with attribute 'nodiscard'",
    "replacement": "忽略声明有 'nodiscard' 特性的 '$1' 的返回值"
  },
  {
    "id": "ignoring returned value of type %qT, declared with attribute %<nodiscard%>: %<%s%>",
    "pattern": "ignoring returned value of type '(.+?)', declared with attribute 'nodiscard': '(.+?)'",
    "replacement": "忽略 '$1' 类型的返回值，其声明带有特性 'nodiscard'：'$2'"
  },
  {
    "id": "ignoring returned value of type %qT, declared with attribute %<nodiscard%>%s",
    "pattern": "ignoring returned value of type '(.+?)', declared with attribute 'nodiscard'(.*?)",
    "replacement": "忽略 '$1' 类型的返回值，其声明带有特性 'nodiscard'"
  },
  {
    "id": "ignoring return value of %qD, declared with attribute %<warn_unused_result%>",
    "pattern": "ignoring return value of '(.+?)', declared with attribute 'warn_unused_result'",
    "replacement": "忽略声明有 'warn_unused_result' 特性的 '$1' 的返回值"
  },
  {
    "id": "pseudo-destructor is not called",
    "pattern": "pseudo-destructor is not called",
    "replacement": "伪析构函数未被调用"
  },
  {
    "id": "conversion to void will not access object of incomplete type %qT",
    "pattern": "conversion to void will not access object of incomplete type '(.+?)'",
    "replacement": "到 void 的转换不会访问具有不完整类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of incomplete type %qT in second operand of conditional expression",
    "pattern": "indirection will not access object of incomplete type '(.+?)' in second operand of conditional expression",
    "replacement": "解地址不会访问作为条件表达式第二操作数的具有不完整类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of incomplete type %qT in third operand of conditional expression",
    "pattern": "indirection will not access object of incomplete type '(.+?)' in third operand of conditional expression",
    "replacement": "解地址不会访问作为条件表达式第三操作数的具有不完整类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of incomplete type %qT in right operand of comma operator",
    "pattern": "indirection will not access object of incomplete type '(.+?)' in right operand of comma operator",
    "replacement": "解地址不会访问作为逗号运算符右操作数的具有不完整类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of incomplete type %qT in left operand of comma operator",
    "pattern": "indirection will not access object of incomplete type '(.+?)' in left operand of comma operator",
    "replacement": "解地址不会访问作为逗号运算符左操作数的具有不完整类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of incomplete type %qT in statement",
    "pattern": "indirection will not access object of incomplete type '(.+?)' in statement",
    "replacement": "解地址不会访问语句中具有不完整类型的对象 '$1'"
  },
  {
    "id": "indirection will not access object of incomplete type %qT in for increment expression",
    "pattern": "indirection will not access object of incomplete type '(.+?)' in for increment expression",
    "replacement": "解地址不会访问 for 循环迭代表达式中具有不完整类型 '$1' 的对象"
  },
  {
    "id": "conversion to void will not access object of type %qT",
    "pattern": "conversion to void will not access object of type '(.+?)'",
    "replacement": "到 void 的转换不会访问类型为 '$1' 的对象"
  },
  {
    "id": "implicit dereference will not access object of type %qT in second operand of conditional expression",
    "pattern": "implicit dereference will not access object of type '(.+?)' in second operand of conditional expression",
    "replacement": "隐式解地址不会访问作为条件表达式第二操作数的类型为 '$1' 的对象"
  },
  {
    "id": "implicit dereference will not access object of type %qT in third operand of conditional expression",
    "pattern": "implicit dereference will not access object of type '(.+?)' in third operand of conditional expression",
    "replacement": "隐式解地址不会访问作为条件表达式第三操作数的类型为 '$1' 的对象"
  },
  {
    "id": "implicit dereference will not access object of type %qT in right operand of comma operator",
    "pattern": "implicit dereference will not access object of type '(.+?)' in right operand of comma operator",
    "replacement": "隐式解地址不会访问作为逗号运算符右操作数的类型为 '$1' 的对象"
  },
  {
    "id": "implicit dereference will not access object of type %qT in left operand of comma operator",
    "pattern": "implicit dereference will not access object of type '(.+?)' in left operand of comma operator",
    "replacement": "隐式解地址不会访问作为逗号运算符左操作数的类型为 '$1' 的对象"
  },
  {
    "id": "implicit dereference will not access object of type %qT in statement",
    "pattern": "implicit dereference will not access object of type '(.+?)' in statement",
    "replacement": "隐式解地址不会访问语句中类型为 '$1' 的对象"
  },
  {
    "id": "implicit dereference will not access object of type %qT in for increment expression",
    "pattern": "implicit dereference will not access object of type '(.+?)' in for increment expression",
    "replacement": "隐式解地址不会访问 for 循环迭代表达式中类型为 '$1' 的对象"
  },
  {
    "id": "conversion to void will not access object of non-trivially-copyable type %qT",
    "pattern": "conversion to void will not access object of non-trivially-copyable type '(.+?)'",
    "replacement": "到 void 的转换不会访问具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of non-trivially-copyable type %qT in second operand of conditional expression",
    "pattern": "indirection will not access object of non-trivially-copyable type '(.+?)' in second operand of conditional expression",
    "replacement": "解地址不会访问作为条件表达式第二操作数的具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of non-trivially-copyable type %qT in third operand of conditional expression",
    "pattern": "indirection will not access object of non-trivially-copyable type '(.+?)' in third operand of conditional expression",
    "replacement": "解地址不会访问作为条件表达式第三操作数的具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of non-trivially-copyable type %qT in right operand of comma operator",
    "pattern": "indirection will not access object of non-trivially-copyable type '(.+?)' in right operand of comma operator",
    "replacement": "解地址不会访问作为逗号运算符右操作数的具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of non-trivially-copyable type %qT in left operand of comma operator",
    "pattern": "indirection will not access object of non-trivially-copyable type '(.+?)' in left operand of comma operator",
    "replacement": "解地址不会访问作为逗号运算符左操作数的具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of non-trivially-copyable type %qT in statement",
    "pattern": "indirection will not access object of non-trivially-copyable type '(.+?)' in statement",
    "replacement": "解地址不会访问语句中具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "indirection will not access object of non-trivially-copyable type %qT in for increment expression",
    "pattern": "indirection will not access object of non-trivially-copyable type '(.+?)' in for increment expression",
    "replacement": "解地址不会访问 for 循环迭代表达式中具有非平凡复制类型 '$1' 的对象"
  },
  {
    "id": "conversion to void will not access object %qE of incomplete type %qT",
    "pattern": "conversion to void will not access object '(.+?)' of incomplete type '(.+?)'",
    "replacement": "到 void 的转换不会访问具有不完整类型 '$2' 的对象 '$1'"
  },
  {
    "id": "variable %qE of incomplete type %qT will not be accessed in second operand of conditional expression",
    "pattern": "variable '(.+?)' of incomplete type '(.+?)' will not be accessed in second operand of conditional expression",
    "replacement": "条件表达式第二操作数中的对象 '$1' 具有不完整类型 '$2'，不会被访问"
  },
  {
    "id": "variable %qE of incomplete type %qT will not be accessed in third operand of conditional expression",
    "pattern": "variable '(.+?)' of incomplete type '(.+?)' will not be accessed in third operand of conditional expression",
    "replacement": "条件表达式第三操作数中的对象 '$1' 具有不完整类型 '$2'，不会被访问"
  },
  {
    "id": "variable %qE of incomplete type %qT will not be accessed in right operand of comma operator",
    "pattern": "variable '(.+?)' of incomplete type '(.+?)' will not be accessed in right operand of comma operator",
    "replacement": "逗号运算符的右操作数中的对象 '$1' 具有不完整类型 '$2'，不会被访问"
  },
  {
    "id": "variable %qE of incomplete type %qT will not be accessed in left operand of comma operator",
    "pattern": "variable '(.+?)' of incomplete type '(.+?)' will not be accessed in left operand of comma operator",
    "replacement": "逗号运算符的左操作数中的对象 '$1' 具有不完整类型 '$2'，不会被访问"
  },
  {
    "id": "variable %qE of incomplete type %qT will not be accessed in statement",
    "pattern": "variable '(.+?)' of incomplete type '(.+?)' will not be accessed in statement",
    "replacement": "语句中的对象 '$1' 具有不完整类型 '$2'，不会被访问"
  },
  {
    "id": "variable %qE of incomplete type %qT will not be accessed in for increment expression",
    "pattern": "variable '(.+?)' of incomplete type '(.+?)' will not be accessed in for increment expression",
    "replacement": "for 循环迭代表达式中的对象 '$1' 具有不完整类型 '$2'，不会被访问"
  },
  {
    "id": "conversion to void cannot resolve address of overloaded function",
    "pattern": "conversion to void cannot resolve address of overloaded function",
    "replacement": "到 void 的转换中无法解析重载函数的地址"
  },
  {
    "id": "second operand of conditional expression cannot resolve address of overloaded function",
    "pattern": "second operand of conditional expression cannot resolve address of overloaded function",
    "replacement": "无法解析作为条件表达式第二操作数的重载函数的地址"
  },
  {
    "id": "third operand of conditional expression cannot resolve address of overloaded function",
    "pattern": "third operand of conditional expression cannot resolve address of overloaded function",
    "replacement": "无法解析作为条件表达式第三操作数的重载函数的地址"
  },
  {
    "id": "right operand of comma operator cannot resolve address of overloaded function",
    "pattern": "right operand of comma operator cannot resolve address of overloaded function",
    "replacement": "无法解析作为逗号运算符右操作数的重载函数的地址"
  },
  {
    "id": "left operand of comma operator cannot resolve address of overloaded function",
    "pattern": "left operand of comma operator cannot resolve address of overloaded function",
    "replacement": "无法解析作为逗号运算符左操作数的重载函数的地址"
  },
  {
    "id": "statement cannot resolve address of overloaded function",
    "pattern": "statement cannot resolve address of overloaded function",
    "replacement": "语句中无法解析重载函数的地址"
  },
  {
    "id": "for increment expression cannot resolve address of overloaded function",
    "pattern": "for increment expression cannot resolve address of overloaded function",
    "replacement": "for 循环迭代表达式中无法解析重载函数的地址"
  },
  {
    "id": "second operand of conditional expression is a reference, not call, to function %qE",
    "pattern": "second operand of conditional expression is a reference, not call, to function '(.+?)'",
    "replacement": "条件表达式的第二操作数是对函数 '$1' 的一个引用而非调用"
  },
  {
    "id": "third operand of conditional expression is a reference, not call, to function %qE",
    "pattern": "third operand of conditional expression is a reference, not call, to function '(.+?)'",
    "replacement": "条件表达式的第三操作数是对函数 '$1' 的一个引用而非调用"
  },
  {
    "id": "right operand of comma operator is a reference, not call, to function %qE",
    "pattern": "right operand of comma operator is a reference, not call, to function '(.+?)'",
    "replacement": "逗号运算符的右操作数是对函数 '$1' 的一个引用而非调用"
  },
  {
    "id": "left operand of comma operator is a reference, not call, to function %qE",
    "pattern": "left operand of comma operator is a reference, not call, to function '(.+?)'",
    "replacement": "逗号运算符的左操作数是对函数 '$1' 的一个引用而非调用"
  },
  {
    "id": "statement is a reference, not call, to function %qE",
    "pattern": "statement is a reference, not call, to function '(.+?)'",
    "replacement": "语句是对函数 '$1' 的一个引用而非调用"
  },
  {
    "id": "for increment expression is a reference, not call, to function %qE",
    "pattern": "for increment expression is a reference, not call, to function '(.+?)'",
    "replacement": "for 循环迭代表达式是对函数 '$1' 的一个引用而非调用"
  },
  {
    "id": "second operand of conditional expression has no effect",
    "pattern": "second operand of conditional expression has no effect",
    "replacement": "条件表达式的第二操作数没有作用"
  },
  {
    "id": "third operand of conditional expression has no effect",
    "pattern": "third operand of conditional expression has no effect",
    "replacement": "条件表达式的第三操作数没有作用"
  },
  {
    "id": "right operand of comma operator has no effect",
    "pattern": "right operand of comma operator has no effect",
    "replacement": "逗号运算符的右操作数没有作用"
  },
  {
    "id": "left operand of comma operator has no effect",
    "pattern": "left operand of comma operator has no effect",
    "replacement": "逗号运算符的左操作数没有作用"
  },
  {
    "id": "statement has no effect",
    "pattern": "statement has no effect",
    "replacement": "语句没有作用"
  },
  {
    "id": "for increment expression has no effect",
    "pattern": "for increment expression has no effect",
    "replacement": "for 循环増量表达式没有作用"
  },
  {
    "id": "converting NULL to non-pointer type",
    "pattern": "converting NULL to non-pointer type",
    "replacement": "将 NULL 转换为非指针类型"
  },
  {
    "id": "default type conversion cannot deduce template argument for %qD",
    "pattern": "default type conversion cannot deduce template argument for '(.+?)'",
    "replacement": "默认类型转换不能推导 '$1' 的模板实参"
  },
  {
    "id": "ambiguous default type conversion from %qT",
    "pattern": "ambiguous default type conversion from '(.+?)'",
    "replacement": "'$1' 中的默认类型转换有歧义"
  },
  {
    "id": "  candidate conversions include %qD and %qD",
    "pattern": "  candidate conversions include '(.+?)' and '(.+?)'",
    "replacement": "  备选转换包括 '$1' 和 '$2'"
  },
  {
    "id": "template-parameter-",
    "pattern": "template-parameter-",
    "replacement": "模板形参-"
  },
  {
    "id": "with",
    "pattern": "\\[with",
    "replacement": "[其中"
  },
  {
    "id": "unused structured binding declaration",
    "pattern": "unused structured binding declaration",
    "replacement": "未使用的结构化绑定声明"
  },
  {
    "id": "unused variable %qD",
    "pattern": "unused variable '(.+?)'",
    "replacement": "未使用的变量 '$1'"
  },
  {
    "id": "structured binding declaration set but not used",
    "pattern": "structured binding declaration set but not used",
    "replacement": "结构化绑定声明被设定但未使用"
  },
  {
    "id": "%qF declared %<static%> but never defined",
    "pattern": "'(.+?)' declared 'static' but never defined",
    "replacement": "'$1' 声明为 'static' 却从未定义过"
  },
  {
    "id": "odr-used inline variable %qD is not defined",
    "pattern": "odr-used inline variable '(.+?)' is not defined",
    "replacement": "ODR-使用了未定义的内联变量 '$1'"
  },
  {
    "id": "%qD was declared %<extern%> and later %<static%>",
    "pattern": "'(.+?)' was declared 'extern' and later 'static'",
    "replacement": "'$1' 曾声明为 'extern'，后又声明为 'static'"
  },
  {
    "id": "declaration of %qF has a different exception specifier",
    "pattern": "declaration of '(.+?)' has a different exception specifier",
    "replacement": "'$1' 的声明具有不同的异常说明符"
  },
  {
    "id": "from previous declaration %qF",
    "pattern": "from previous declaration '(.+?)'",
    "replacement": "从之前的声明 '$1'"
  },
  {
    "id": "redeclaration %qD differs in %qs from previous declaration",
    "pattern": "redeclaration '(.+?)' differs in '(.+?)' from previous declaration",
    "replacement": "重声明 '$1' 与先前声明中的 '$2' 不同"
  },
  {
    "id": "previous declaration %qD",
    "pattern": "previous declaration '(.+?)'",
    "replacement": "之前的声明 '$1'"
  },
  {
    "id": "cannot specialize concept %q#D",
    "pattern": "cannot specialize concept '(.+?)'",
    "replacement": "不能特化概念 '$1'"
  },
  {
    "id": "redeclaration of %q#D may not have default arguments",
    "pattern": "redeclaration of '(.+?)' may not have default arguments",
    "replacement": "'$1' 的重声明不能有默认实参"
  },
  {
    "id": "friend declaration of %q#D specifies default arguments and isn%'t the only declaration",
    "pattern": "friend declaration of '(.+?)' specifies default arguments and isn't the only declaration",
    "replacement": "'$1' 的友元声明指示了默认实参，且它并非唯一的声明"
  },
  {
    "id": "previous declaration of %q#D",
    "pattern": "previous declaration of '(.+?)'",
    "replacement": "'$1' 之前的声明"
  },
  {
    "id": "ambiguating new declaration %q+#D",
    "pattern": "ambiguating new declaration '(.+?)'",
    "replacement": "有歧义的新声明 '$1'"
  },
  {
    "id": "old declaration %q#D",
    "pattern": "old declaration '(.+?)'",
    "replacement": "旧声明 '$2'"
  },
  {
    "id": "built-in function %qD declared as non-function",
    "pattern": "built-in function '(.+?)' declared as non-function",
    "replacement": "内建函数 '$1' 声明为非函数"
  },
  {
    "id": "shadowing built-in function %q#D",
    "pattern": "shadowing built-in function '(.+?)'",
    "replacement": "隐藏了内建函数 '$1'"
  },
  {
    "id": "shadowing library function %q#D",
    "pattern": "shadowing library function '(.+?)'",
    "replacement": "隐藏了库函数 '$1'"
  },
  {
    "id": "library function %q#D redeclared as non-function %q#D",
    "pattern": "library function '(.+?)' redeclared as non-function '(.+?)'",
    "replacement": "库函数 '$1' 重声明为非函数 '$2'"
  },
  {
    "id": "declaration of %q#D conflicts with built-in declaration %q#D",
    "pattern": "declaration of '(.+?)' conflicts with built-in declaration '(.+?)'",
    "replacement": "'$1' 的声明与内建声明 '$2' 冲突"
  },
  {
    "id": "definition of %q#D ambiguates built-in declaration %q#D",
    "pattern": "definition of '(.+?)' ambiguates built-in declaration '(.+?)'",
    "replacement": "定义 '$1' 使得内建声明 '$2' 出现歧义"
  },
  {
    "id": "new declaration %q#D ambiguates built-in declaration %q#D",
    "pattern": "new declaration '(.+?)' ambiguates built-in declaration '(.+?)'",
    "replacement": "新声明 '$1' 使得内建声明 '$2' 出现歧义"
  },
  {
    "id": "ignoring the %q#D declaration",
    "pattern": "ignoring the '(.+?)' declaration",
    "replacement": "忽略 '$1' 声明"
  },
  {
    "id": "literal operator %q#D conflicts with raw literal operator",
    "pattern": "literal operator '(.+?)' conflicts with raw literal operator",
    "replacement": "字面量运算符 '$1' 与原生字面量运算符冲突"
  },
  {
    "id": "raw literal operator %q#D conflicts with literal operator template",
    "pattern": "raw literal operator '(.+?)' conflicts with literal operator template",
    "replacement": "原生字面量运算符 '$1' 与字面量运算符模板冲突"
  },
  {
    "id": "%q#D redeclared as different kind of entity",
    "pattern": "'(.+?)' redeclared as different kind of entity",
    "replacement": "'$1' 被重声明为不同类别的实体"
  },
  {
    "id": "conflicting declaration of template %q#D",
    "pattern": "conflicting declaration of template '(.+?)'",
    "replacement": "模板 '$1' 冲突的声明"
  },
  {
    "id": "conflicting declaration of C function %q#D",
    "pattern": "conflicting declaration of C function '(.+?)'",
    "replacement": "C 函数 '$1' 冲突的声明"
  },
  {
    "id": "ambiguating new declaration of %q#D",
    "pattern": "ambiguating new declaration of '(.+?)'",
    "replacement": "'$1' 新声明导致歧义"
  },
  {
    "id": "conflicting declaration %q#D",
    "pattern": "conflicting declaration '(.+?)'",
    "replacement": "冲突的声明 '$1'"
  },
  {
    "id": "previous declaration as %q#D",
    "pattern": "previous declaration as '(.+?)'",
    "replacement": "之前声明为 '$1'"
  },
  {
    "id": "redeclaration of %<pragma omp declare reduction%>",
    "pattern": "redeclaration of 'pragma omp declare reduction'",
    "replacement": "'pragma omp declare reduction' 的重声明"
  },
  {
    "id": "previous %<pragma omp declare reduction%> declaration",
    "pattern": "previous 'pragma omp declare reduction' declaration",
    "replacement": "之前的 'pragma omp declare reduction' 声明"
  },
  {
    "id": "%q#D previously defined here",
    "pattern": "'(.+?)' previously defined here",
    "replacement": "'$1' 之前在此定义"
  },
  {
    "id": "%q#D previously declared here",
    "pattern": "'(.+?)' previously declared here",
    "replacement": "'$1' 之前在此声明"
  },
  {
    "id": "prototype specified for %q#D",
    "pattern": "prototype specified for '(.+?)'",
    "replacement": "为 '$1' 指明原型"
  },
  {
    "id": "previous non-prototype definition here",
    "pattern": "previous non-prototype definition here",
    "replacement": "之前的非原型定义在此"
  },
  {
    "id": "conflicting declaration of %q#D with %qL linkage",
    "pattern": "conflicting declaration of '(.+?)' with '(.+?)' linkage",
    "replacement": "带有 '$2' 连接的 '$1' 声明引起冲突"
  },
  {
    "id": "previous declaration with %qL linkage",
    "pattern": "previous declaration with '(.+?)' linkage",
    "replacement": "之前的声明带有 '$1' 连接"
  },
  {
    "id": "default argument given for parameter %d of %q#D",
    "pattern": "default argument given for parameter (\\d+) of '(.+?)'",
    "replacement": "为 '$2' 的第 $1 个形参指定了默认实参"
  },
  {
    "id": "previous specification in %q#D here",
    "pattern": "previous specification in '(.+?)' here",
    "replacement": "之前的指定在 '$1' 这里"
  },
  {
    "id": "declaration %qD conflicts with builtin",
    "pattern": "declaration '(.+?)' conflicts with builtin",
    "replacement": "声明 '$1' 与内建冲突"
  },
  {
    "id": "declaration %qD conflicts with import",
    "pattern": "declaration '(.+?)' conflicts with import",
    "replacement": "声明 '$1' 与导入冲突"
  },
  {
    "id": "import declared %q#D here",
    "pattern": "import declared '(.+?)' here",
    "replacement": "导入的声明 '$1' 在此"
  },
  {
    "id": "conflicting exporting declaration %qD",
    "pattern": "conflicting exporting declaration '(.+?)'",
    "replacement": "冲突的导出声明 '$1'"
  },
  {
    "id": "previous declaration %q#D here",
    "pattern": "previous declaration '(.+?)' here",
    "replacement": "之前的声明 '$1' 在此"
  },
  {
    "id": "previous definition of %qD here",
    "pattern": "previous definition of '(.+?)' here",
    "replacement": "之前 '$1' 的定义在此"
  },
  {
    "id": "previous declaration of %qD here",
    "pattern": "previous declaration of '(.+?)' here",
    "replacement": "之前 '$1' 的声明在此"
  },
  {
    "id": "function %qD declared %<[[noreturn]]%> but its first declaration was not",
    "pattern": "function '(.+?)' declared '\\[\\[noreturn\\]\\]' but its first declaration was not",
    "replacement": "函数 '$1' 声明为 '[[noreturn]]' 但其首个声明却没有"
  },
  {
    "id": "redundant redeclaration of %qD in same scope",
    "pattern": "redundant redeclaration of '(.+?)' in same scope",
    "replacement": "同一作用域中 '$1' 冗余的重声明"
  },
  {
    "id": "deleted definition of %qD is not first declaration",
    "pattern": "deleted definition of '(.+?)' is not first declaration",
    "replacement": "'$1' 被删除的定义不是首个声明"
  },
  {
    "id": "explicit specialization of %qD after first use",
    "pattern": "explicit specialization of '(.+?)' after first use",
    "replacement": "'$1' 在其首次使用后才显式实例化"
  },
  {
    "id": "%qD: visibility attribute ignored because it conflicts with previous declaration",
    "pattern": "'(.+?)': visibility attribute ignored because it conflicts with previous declaration",
    "replacement": "'$1': visibility 特性被忽略，因为其与之前的声明冲突"
  },
  {
    "id": "redefinition of %q#D",
    "pattern": "redefinition of '(.+?)'",
    "replacement": "'$1' 的重定义"
  },
  {
    "id": "%qD conflicts with used function",
    "pattern": "'(.+?)' conflicts with used function",
    "replacement": "'$1'与已使用的函数冲突"
  },
  {
    "id": "%q#D not declared in class",
    "pattern": "'(.+?)' not declared in class",
    "replacement": "'$1' 未在类中声明"
  },
  {
    "id": "%q+D redeclared inline with %<gnu_inline%> attribute",
    "pattern": "'(.+?)' redeclared inline with 'gnu_inline' attribute",
    "replacement": "'$1' 重声明为内联的，并带有 'gnu_inline' 特性"
  },
  {
    "id": "%q+D redeclared inline without %<gnu_inline%> attribute",
    "pattern": "'(.+?)' redeclared inline without 'gnu_inline' attribute",
    "replacement": "'$1' 重声明为内联，未带有 'gnu_inline' 特性"
  },
  {
    "id": "deduction guide %q+D redeclared",
    "pattern": "deduction guide '(.+?)' redeclared",
    "replacement": "推导指引 '$1' 被重声明"
  },
  {
    "id": "comparison operator %q+D defaulted after its first declaration",
    "pattern": "comparison operator '(.+?)' defaulted after its first declaration",
    "replacement": "比较运算符 '$1' 在其第一次声明后才设置为预置的"
  },
  {
    "id": "redeclaration of friend %q#D may not have default template arguments",
    "pattern": "redeclaration of friend '(.+?)' may not have default template arguments",
    "replacement": "友元 '(.+?)' 的重声明不能拥有默认模板实参"
  },
  {
    "id": "thread-local declaration of %q#D follows non-thread-local declaration",
    "pattern": "thread-local declaration of '(.+?)' follows non-thread-local declaration",
    "replacement": "'$1' 的线程局部声明出现在其非线程局部声明之后"
  },
  {
    "id": "non-thread-local declaration of %q#D follows thread-local declaration",
    "pattern": "non-thread-local declaration of '(.+?)' follows thread-local declaration",
    "replacement": "'$1' 的非线程局部声明出现在其线程局部声明之后"
  },
  {
    "id": "redeclaration of %q#D",
    "pattern": "redeclaration of '(.+?)'",
    "replacement": "'$1' 的重声明"
  },
  {
    "id": "redundant redeclaration of %<constexpr%> static data member %qD",
    "pattern": "redundant redeclaration of 'constexpr' static data member '(.+?)'",
    "replacement": "'constexpr' 静态数据成员 '$1' 冗余的重声明"
  },
  {
    "id": "local label %qE conflicts with existing label",
    "pattern": "local label '(.+?)' conflicts with existing label",
    "replacement": "局部标号 '$1' 与已有标号冲突"
  },
  {
    "id": "previous label",
    "pattern": "previous label",
    "replacement": "上一个标号"
  },
  {
    "id": "  from here",
    "pattern": "  from here",
    "replacement": "  从这里"
  },
  {
    "id": "  exits OpenMP structured block",
    "pattern": "  exits OpenMP structured block",
    "replacement": "  退出了 OpenMP 结构块"
  },
  {
    "id": "  crosses initialization of %q#D",
    "pattern": "  crosses initialization of '(.+?)'",
    "replacement": "  跳过了 '$1' 的初始化"
  },
  {
    "id": "  enters scope of %q#D, which has non-trivial destructor",
    "pattern": "  enters scope of '(.+?)', which has non-trivial destructor",
    "replacement": "  进入了拥有不平凡析构函数的 '$1' 的作用域"
  },
  {
    "id": "  enters %<try%> block",
    "pattern": "  enters 'try' block",
    "replacement": "  进入了 'try' 块"
  },
  {
    "id": "  enters %<catch%> block",
    "pattern": "  enters 'catch' block",
    "replacement": "  进入了 'catch' 块"
  },
  {
    "id": "  enters OpenMP structured block",
    "pattern": "  enters OpenMP structured block",
    "replacement": "  进入了 OpenMP 结构块"
  },
  {
    "id": "  enters synchronized or atomic statement",
    "pattern": "  enters synchronized or atomic statement",
    "replacement": "  进入了同步或原子语句"
  },
  {
    "id": "  enters %<constexpr if%> statement",
    "pattern": "  enters 'constexpr if' statement",
    "replacement": "  进入了 'constexpr if' 语句"
  },
  {
    "id": "  skips initialization of %q#D",
    "pattern": "  skips initialization of '(.+?)'",
    "replacement": "  跳过了 '$1' 的初始化"
  },
  {
    "id": "  enters scope of %q#D which has non-trivial destructor",
    "pattern": "  enters scope of '(.+?)' which has non-trivial destructor",
    "replacement": "  进入了拥有不平凡析构函数的 '$1' 的作用域"
  },
  {
    "id": "%qD used without template arguments",
    "pattern": "'(.+?)' used without template arguments",
    "replacement": "'$1' 使用时未带模板实参"
  },
  {
    "id": "%qD is a function, not a type",
    "pattern": "'(.+?)' is a function, not a type",
    "replacement": "'$1' 是一个函数，不是类型"
  },
  {
    "id": "%q#T is not a class",
    "pattern": "'(.+?)' is not a class",
    "replacement": "'$1' 不是一个类"
  },
  {
    "id": "no class template named %q#T in %q#T",
    "pattern": "no class template named '(.+?)' in '(.+?)'",
    "replacement": "在 '$2' 中没有名为 '$1' 的类模板"
  },
  {
    "id": "no type named %q#T in %q#T",
    "pattern": "no type named '(.+?)' in '(.+?)'",
    "replacement": "在 '$2' 中没有名为 '$1' 的类型"
  },
  {
    "id": "lookup of %qT in %qT is ambiguous",
    "pattern": "lookup of '(.+?)' in '(.+?)' is ambiguous",
    "replacement": "在 '$2' 中查找 '$1' 是有歧义的"
  },
  {
    "id": "%<typename %T::%D%> names %q#T, which is not a class template",
    "pattern": "'typename (.+?)::(.+?)' names '(.+?)', which is not a class template",
    "replacement": "'typename $1::$2' 指名了 '$3'，而后者不是一个类模板"
  },
  {
    "id": "%<typename %T::%D%> names %q#T, which is not a type",
    "pattern": "'typename (.+?)::(.+?)' names '(.+?)', which is not a type",
    "replacement": "'typename $1::$2' 指名了 '$3'，而后者不是一个类型"
  },
  {
    "id": "template parameters do not match template %qD",
    "pattern": "template parameters do not match template '(.+?)'",
    "replacement": "模板形参不匹配模板 '$1'"
  },
  {
    "id": "%<-faligned-new=%d%> is not a power of two",
    "pattern": "'-faligned-new=(\\d+)' is not a power of two",
    "replacement": "'-faligned-new=$1' 不是 2 的幂"
  },
  {
    "id": "member %q+#D with constructor not allowed in anonymous aggregate",
    "pattern": "member '(.+?)' with constructor not allowed in anonymous aggregate",
    "replacement": "带有构造函数的成员 '$1' 不允许出现在匿名聚合体中"
  },
  {
    "id": "member %q+#D with destructor not allowed in anonymous aggregate",
    "pattern": "member '(.+?)' with destructor not allowed in anonymous aggregate",
    "replacement": "带有析构函数的成员 '$1' 不允许出现在匿名聚合体中"
  },
  {
    "id": "member %q+#D with copy assignment operator not allowed in anonymous aggregate",
    "pattern": "member '(.+?)' with copy assignment operator not allowed in anonymous aggregate",
    "replacement": "带有复制赋值运算符的成员 '$1' 不允许出现在匿名聚合体中"
  },
  {
    "id": "attribute ignored in declaration of %q#T",
    "pattern": "attribute ignored in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中的特性被忽略"
  },
  {
    "id": "attribute for %q#T must follow the %qs keyword",
    "pattern": "attribute for '(.+?)' must follow the '(.+?)' keyword",
    "replacement": "'$1' 的特性必须跟在 '$2' 关键字后面"
  },
  {
    "id": "multiple types in one declaration",
    "pattern": "multiple types in one declaration",
    "replacement": "一个声明指定了多个类型"
  },
  {
    "id": "redeclaration of C++ built-in type %qT",
    "pattern": "redeclaration of C\\+\\+ built-in type '(.+?)'",
    "replacement": "对 C++ 内建类型 '$1' 的重声明"
  },
  {
    "id": "%<auto%> can only be specified for variables or function declarations",
    "pattern": "'auto' can only be specified for variables or function declarations",
    "replacement": "只能为变量和函数指定 'auto'"
  },
  {
    "id": "missing type-name in typedef-declaration",
    "pattern": "missing type-name in typedef-declaration",
    "replacement": "typedef 声明中缺少类型名"
  },
  {
    "id": "ISO C++ prohibits anonymous structs",
    "pattern": "ISO C\\+\\+ prohibits anonymous structs",
    "replacement": "ISO C++ 不允许匿名结构体"
  },
  {
    "id": "%<inline%> can only be specified for functions",
    "pattern": "'inline' can only be specified for functions",
    "replacement": "只能为函数指定 'inline'"
  },
  {
    "id": "%<virtual%> can only be specified for functions",
    "pattern": "'virtual' can only be specified for functions",
    "replacement": "只能为函数指定'(.+?)'"
  },
  {
    "id": "%<friend%> can only be specified inside a class",
    "pattern": "'friend' can only be specified inside a class",
    "replacement": "'friend' 只能在类中指定"
  },
  {
    "id": "%<explicit%> can only be specified for constructors",
    "pattern": "'explicit' can only be specified for constructors",
    "replacement": "只能为构造函数指定 'explicit'"
  },
  {
    "id": "a storage class can only be specified for objects and functions",
    "pattern": "a storage class can only be specified for objects and functions",
    "replacement": "只能为对象和函数指定存储类"
  },
  {
    "id": "%<const%> can only be specified for objects and functions",
    "pattern": "'const' can only be specified for objects and functions",
    "replacement": "只能为对象和函数指定 'const'"
  },
  {
    "id": "%<volatile%> can only be specified for objects and functions",
    "pattern": "'volatile' can only be specified for objects and functions",
    "replacement": "只能为对象和函数指定 'volatile'"
  },
  {
    "id": "%<__restrict%> can only be specified for objects and functions",
    "pattern": "'__restrict' can only be specified for objects and functions",
    "replacement": "只能为对象和函数指定 '__restrict'"
  },
  {
    "id": "%<__thread%> can only be specified for objects and functions",
    "pattern": "'__thread' can only be specified for objects and functions",
    "replacement": "只能为对象和函数指定 '__thread'"
  },
  {
    "id": "%<typedef%> was ignored in this declaration",
    "pattern": "'typedef' was ignored in this declaration",
    "replacement": "此声明中的 'typedef' 被忽略"
  },
  {
    "id": "%qs cannot be used for type declarations",
    "pattern": "'(.+?)' cannot be used for type declarations",
    "replacement": "'$1' 不能被用作类型声明"
  },
  {
    "id": "attribute ignored in explicit instantiation %q#T",
    "pattern": "attribute ignored in explicit instantiation '(.+?)'",
    "replacement": "显式实例化 '$1' 中的特性被忽略"
  },
  {
    "id": "no attribute can be applied to an explicit instantiation",
    "pattern": "no attribute can be applied to an explicit instantiation",
    "replacement": "没有可以应用于显式实例化的特性"
  },
  {
    "id": "ignoring attributes applied to class type %qT outside of definition",
    "pattern": "ignoring attributes applied to class type '(.+?)' outside of definition",
    "replacement": "忽略在定义之外为类类型 '$1' 应用的特性"
  },
  {
    "id": "ignoring attributes applied to dependent type %qT without an associated declaration",
    "pattern": "ignoring attributes applied to dependent type '(.+?)' without an associated declaration",
    "replacement": "待决类型 '$1' 未关联到声明，忽略应用于其上的特性"
  },
  {
    "id": "typedef %qD is initialized (use %qs instead)",
    "pattern": "typedef '(.+?)' is initialized (use '(.+?)' instead)",
    "replacement": "typedef '$1' 被初始化（使用 '$1' 代替）"
  },
  {
    "id": "declaration of %q#D has %<extern%> and is initialized",
    "pattern": "declaration of '(.+?)' has 'extern' and is initialized",
    "replacement": "'$1' 的声明带 'extern' 且被初始化"
  },
  {
    "id": "definition of %q#D is marked %<dllimport%>",
    "pattern": "definition of '(.+?)' is marked 'dllimport'",
    "replacement": "'$1' 的定义被标记为 'dllimport'"
  },
  {
    "id": "%q+#D is not a static data member of %q#T",
    "pattern": "'(.+?)' is not a static data member of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的非静态数据成员"
  },
  {
    "id": "non-member-template declaration of %qD",
    "pattern": "non-member-template declaration of '(.+?)'",
    "replacement": "'$1' 的非成员模板声明"
  },
  {
    "id": "does not match member template declaration here",
    "pattern": "does not match member template declaration here",
    "replacement": "不匹配在此处声明的成员模板"
  },
  {
    "id": "ISO C++ does not permit %<%T::%D%> to be defined as %<%T::%D%>",
    "pattern": "ISO C\\+\\+ does not permit '(.+?)::(.+?)' to be defined as '(.+?)::(.+?)'",
    "replacement": "ISO C++ 不允许将 '$1::$2' 定义为'$3::$4'"
  },
  {
    "id": "duplicate initialization of %qD",
    "pattern": "duplicate initialization of '(.+?)'",
    "replacement": "'$1' 重复的初始化"
  },
  {
    "id": "declaration of %q#D outside of class is not definition",
    "pattern": "declaration of '(.+?)' outside of class is not definition",
    "replacement": "出现在类外的 '$1' 的声明不是定义"
  },
  {
    "id": "block-scope extern declaration %q#D not permitted in module purview",
    "pattern": "block-scope extern declaration '(.+?)' not permitted in module purview",
    "replacement": "块作用域的 extern 声明 '$1' 不允许出现在模块中"
  },
  {
    "id": "%qD declared %<thread_local%> in %qs function",
    "pattern": "'(.+?)' declared 'thread_local' in '(.+?)' function",
    "replacement": "'$2' 函数中 '$1' 被声明为 'thread_local'"
  },
  {
    "id": "%qD declared %<static%> in %qs function",
    "pattern": "'(.+?)' declared 'static' in '(.+?)' function",
    "replacement": "'$2' 函数中 '$1' 被声明为 'static'"
  },
  {
    "id": "variable %q#D has initializer but incomplete type",
    "pattern": "variable '(.+?)' has initializer but incomplete type",
    "replacement": "变量 '$1' 有初始化器，但它具有不完整类型"
  },
  {
    "id": "elements of array %q#D have incomplete type",
    "pattern": "elements of array '(.+?)' have incomplete type",
    "replacement": "数组 '$1' 的元素具有不完整类型"
  },
  {
    "id": "aggregate %q#D has incomplete type and cannot be defined",
    "pattern": "aggregate '(.+?)' has incomplete type and cannot be defined",
    "replacement": "聚合体 '$1' 具有不完整类型，无法被定义"
  },
  {
    "id": "%qD declared as reference but not initialized",
    "pattern": "'(.+?)' declared as reference but not initialized",
    "replacement": "'$1' 声明为引用却未被初始化"
  },
  {
    "id": "name used in a GNU-style designated initializer for an array",
    "pattern": "name used in a GNU-style designated initializer for an array",
    "replacement": "名字被用在 GNU 风格的数组指派初始化器中"
  },
  {
    "id": "name %qD used in a GNU-style designated initializer for an array",
    "pattern": "name '(.+?)' used in a GNU-style designated initializer for an array",
    "replacement": "名字 '$1' 被用在 GNU 风格的数组指派初始化器中"
  },
  {
    "id": "non-trivial designated initializers not supported",
    "pattern": "non-trivial designated initializers not supported",
    "replacement": "不支持非平凡的聚合初始化器"
  },
  {
    "id": "C99 designator %qE is not an integral constant-expression",
    "pattern": "C99 designator '(.+?)' is not an integral constant-expression",
    "replacement": "C99 指派符 '$1' 不是整数常量表达式"
  },
  {
    "id": "initializer fails to determine size of %qD",
    "pattern": "initializer fails to determine size of '(.+?)'",
    "replacement": "初始化器无法确定 '$1' 的大小"
  },
  {
    "id": "array size missing in %qD",
    "pattern": "array size missing in '(.+?)'",
    "replacement": "'$1' 中缺少数组大小"
  },
  {
    "id": "zero-size array %qD",
    "pattern": "zero-size array '(.+?)'",
    "replacement": "大小为零的数组 '$1'"
  },
  {
    "id": "storage size of %qD isn%'t known",
    "pattern": "storage size of '(.+?)' isn't known",
    "replacement": "'$1' 的存储大小未知"
  },
  {
    "id": "storage size of %qD isn%'t constant",
    "pattern": "storage size of '(.+?)' isn't constant",
    "replacement": "'$1' 的存储大小不是常量"
  },
  {
    "id": "sorry: semantics of inline variable %q#D are wrong (you%'ll wind up with multiple copies)",
    "pattern": "sorry: semantics of inline variable '(.+?)' are wrong \\(you'll wind up with multiple copies\\)",
    "replacement": "对不起：内联变量 '$1' 的语义是错的（你会得到此变量的多份复制）"
  },
  {
    "id": "sorry: semantics of inline function static data %q#D are wrong (you%'ll wind up with multiple copies)",
    "pattern": "sorry: semantics of inline function static data '(.+?)' are wrong \\(you'll wind up with multiple copies\\)",
    "replacement": "对不起：内联函数中静态数据 '$1' 的语义是错的（你会得到此变量的多份复制）"
  },
  {
    "id": "you can work around this by removing the initializer",
    "pattern": "you can work around this by removing the initializer",
    "replacement": "变通的作法是删除初始化器"
  },
  {
    "id": "uninitialized %<const %D%>",
    "pattern": "uninitialized 'const (.+?)'",
    "replacement": "未初始化的 'const $1'"
  },
  {
    "id": "uninitialized variable %qD in %<constexpr%> function",
    "pattern": "uninitialized variable '(.+?)' in 'constexpr' function",
    "replacement": "'constexpr' 函数中出现未初始化的变量 '$1'"
  },
  {
    "id": "uninitialized variable %qD in %<constexpr%> context",
    "pattern": "uninitialized variable '(.+?)' in 'constexpr' context",
    "replacement": "'constexpr' 语境中出现未初始化的变量 '$1'"
  },
  {
    "id": "%q#T has no user-provided default constructor",
    "pattern": "'(.+?)' has no user-provided default constructor",
    "replacement": "'$1' 没有用户提供的默认构造函数"
  },
  {
    "id": "constructor is not user-provided because it is explicitly defaulted in the class body",
    "pattern": "constructor is not user-provided because it is explicitly defaulted in the class body",
    "replacement": "构造函数不是用户提供的，因为它在类声明中显式指明为预置的"
  },
  {
    "id": "and the implicitly-defined constructor does not initialize %q#D",
    "pattern": "and the implicitly-defined constructor does not initialize '(.+?)'",
    "replacement": "且隐式定义的构造函数不初始化 '$1'"
  },
  {
    "id": "invalid type %qT as initializer for a vector of type %qT",
    "pattern": "invalid type '(.+?)' as initializer for a vector of type '(.+?)'",
    "replacement": "无效类型 '$1' 被用作类型为 '$2' 的向量的初始化器"
  },
  {
    "id": "initializer for %qT must be brace-enclosed",
    "pattern": "initializer for '(.+?)' must be brace-enclosed",
    "replacement": "'$1' 的初始化器必须是花括号围起的"
  },
  {
    "id": "%<[%E] =%> used in a GNU-style designated initializer for class %qT",
    "pattern": "'\\[(.*?)\\] =' used in a GNU-style designated initializer for class '(.+?)'",
    "replacement": "类 '$2' 的 GNU 风格指派初始化器中使用了 '[$1] ='"
  },
  {
    "id": "%qT has no non-static data member named %qD",
    "pattern": "'(.+?)' has no non-static data member named '(.+?)'",
    "replacement": "'$1' 没有名为 '$2' 的非静态数据成员"
  },
  {
    "id": "invalid initializer for %q#D",
    "pattern": "invalid initializer for '(.+?)'",
    "replacement": "'$1' 的初始化器无效"
  },
  {
    "id": "C99 designator %qE outside aggregate initializer",
    "pattern": "C99 designator '(.+?)' outside aggregate initializer",
    "replacement": "C99 指派符 '$1' 出现在聚合初始化器外"
  },
  {
    "id": "too many initializers for %qT",
    "pattern": "too many initializers for '(.+?)'",
    "replacement": "'$1' 的初始化器太多"
  },
  {
    "id": "braces around scalar initializer for type %qT",
    "pattern": "braces around scalar initializer for type '(.+?)'",
    "replacement": "类型 '$1' 的标量初始化器带花括号"
  },
  {
    "id": "too many braces around scalar initializer for type %qT",
    "pattern": "too many braces around scalar initializer for type '(.+?)'",
    "replacement": "类型 '$1' 的标量初始化器周围有太多花括号"
  },
  {
    "id": "missing braces around initializer for %qT",
    "pattern": "missing braces around initializer for '(.+?)'",
    "replacement": "'$1' 的初始化器两侧缺少花括号"
  },
  {
    "id": "structured binding has incomplete type %qT",
    "pattern": "structured binding has incomplete type '(.+?)'",
    "replacement": "结构化绑定具有不完整类型 '$1'"
  },
  {
    "id": "elements of array %q#T have incomplete type",
    "pattern": "elements of array '(.+?)' have incomplete type",
    "replacement": "数组 '$1' 的元素具有不完整类型"
  },
  {
    "id": "variable-sized compound literal",
    "pattern": "variable-sized compound literal",
    "replacement": "变长复合字面量"
  },
  {
    "id": "%q#D has incomplete type",
    "pattern": "'(.+?)' has incomplete type",
    "replacement": "'$1' 具有不完整类型"
  },
  {
    "id": "scalar object %qD requires one element in initializer",
    "pattern": "scalar object '(.+?)' requires one element in initializer",
    "replacement": "标量对象 '(.+?)' 的初始化器中需要一个元素"
  },
  {
    "id": "in C++98 %qD must be initialized by constructor, not by %<{...}%>",
    "pattern": "in C\\+\\+98 '(.+?)' must be initialized by constructor, not by '\\{...\\}'",
    "replacement": "在 C++98 中 '$1' 必须由构造函数初始化，而不是 '{...}' 初始化"
  },
  {
    "id": "array %qD initialized by parenthesized string literal %qE",
    "pattern": "array '(.+?)' initialized by parenthesized string literal '(.+?)'",
    "replacement": "数组 '$1' 被带括号的字符串字面量 '$2' 初始化"
  },
  {
    "id": "initializer invalid for static member with constructor",
    "pattern": "initializer invalid for static member with constructor",
    "replacement": "构造函数中静态成员的初始化器无效"
  },
  {
    "id": "non-constant in-class initialization invalid for static member %qD",
    "pattern": "non-constant in-class initialization invalid for static member '(.+?)'",
    "replacement": "对于静态成员 '$1'，非只读的类内初始化器无效"
  },
  {
    "id": "non-constant in-class initialization invalid for non-inline static member %qD",
    "pattern": "non-constant in-class initialization invalid for non-inline static member '(.+?)'",
    "replacement": "对于非内联的静态成员 '$1'，非只读的类内初始化器无效"
  },
  {
    "id": "(an out of class initialization is required)",
    "pattern": "\\(an out of class initialization is required\\)",
    "replacement": "（需要一个类外的初始化）"
  },
  {
    "id": "reference %qD is initialized with itself",
    "pattern": "reference '(.+?)' is initialized with itself",
    "replacement": "引用 '$1' 被它自己初始化"
  },
  {
    "id": "could not find variant declaration",
    "pattern": "could not find variant declaration",
    "replacement": "找不到变体声明"
  },
  {
    "id": "%<declare variant%> on constructor %qD",
    "pattern": "'declare variant' on constructor '(.+?)'",
    "replacement": "构造函数 '$1' 上的 'declare variant'"
  },
  {
    "id": "%<declare variant%> on destructor %qD",
    "pattern": "'declare variant' on destructor '(.+?)'",
    "replacement": "析构函数 '$1' 上的 'declare variant'"
  },
  {
    "id": "%<declare variant%> on defaulted %qD",
    "pattern": "'declare variant' on defaulted '(.+?)'",
    "replacement": "预置的 '$1' 上的 'declare variant'"
  },
  {
    "id": "%<declare variant%> on deleted %qD",
    "pattern": "'declare variant' on deleted '(.+?)'",
    "replacement": "删除的 '$1' 上的 'declare variant'"
  },
  {
    "id": "%<declare variant%> on virtual %qD",
    "pattern": "'declare variant' on virtual '(.+?)'",
    "replacement": "虚 '$1' 上的 'declare variant'"
  },
  {
    "id": "assignment (not initialization) in declaration",
    "pattern": "assignment \\(not initialization\\) in declaration",
    "replacement": "赋值（不是初始化）出现在声明中"
  },
  {
    "id": "ISO C++17 does not allow %<register%> storage class specifier",
    "pattern": "ISO C\\+\\+17 does not allow 'register' storage class specifier",
    "replacement": "ISO C++17 不允许 'register' 存储类说明符"
  },
  {
    "id": "%<register%> storage class specifier used",
    "pattern": "'register' storage class specifier used",
    "replacement": "使用了 'register' 存储类说明符"
  },
  {
    "id": "initializer for %<decltype(auto) %D%> has function type; did you forget the %<()%>?",
    "pattern": "initializer for 'decltype\\(auto\\) (.+?)' has function type; did you forget the '\\(\\)'?",
    "replacement": "'decltype auto $1' 的初始化器具有函数类型；你是否忘记了 '()'？"
  },
  {
    "id": "variable concept has no initializer",
    "pattern": "variable concept has no initializer",
    "replacement": "变量概念没有初始化器"
  },
  {
    "id": "shadowing previous type declaration of %q#D",
    "pattern": "shadowing previous type declaration of '(.+?)'",
    "replacement": "隐藏了早先的类型声明 '$1'"
  },
  {
    "id": "%<constinit%> can only be applied to a variable with static or thread storage duration",
    "pattern": "'constinit' can only be applied to a variable with static or thread storage duration",
    "replacement": "'constinit' 只能应用于静态或线程存储期的变量"
  },
  {
    "id": "function %q#D is initialized like a variable",
    "pattern": "function '(.+?)' is initialized like a variable",
    "replacement": "函数 '$1' 像变量一样被初始化"
  },
  {
    "id": "cannot decompose class type %qT because it has an anonymous struct member",
    "pattern": "cannot decompose class type '(.+?)' because it has an anonymous struct member",
    "replacement": "不能分解类类型 '$1'，因为它拥有一个匿名结构体成员"
  },
  {
    "id": "cannot decompose class type %qT because it has an anonymous union member",
    "pattern": "cannot decompose class type '(.+?)' because it has an anonymous union member",
    "replacement": "不能分解类类型 '$1'，因为它拥有一个匿名联合体成员"
  },
  {
    "id": "cannot decompose inaccessible member %qD of %qT",
    "pattern": "cannot decompose inaccessible member '(.+?)' of '(.+?)'",
    "replacement": "不能分解 '$2' 的不可访问成员 '$1'"
  },
  {
    "id": "cannot decompose class type %qT: both it and its base class %qT have non-static data members",
    "pattern": "cannot decompose class type '(.+?)': both it and its base class '(.+?)' have non-static data members",
    "replacement": "不能分解类类型 '$1'：它和它的基类 '$2' 都有非静态数据成员"
  },
  {
    "id": "cannot decompose class type %qT: its base classes %qT and %qT have non-static data members",
    "pattern": "cannot decompose class type '(.+?)': its base classes '(.+?)' and '(.+?)' have non-static data members",
    "replacement": "不能分解类类型 '$1'：它的基类 '$2' 和 '$3' 都有非静态数据成员"
  },
  {
    "id": "structured binding refers to incomplete type %qT",
    "pattern": "structured binding refers to incomplete type '(.+?)'",
    "replacement": "结构化绑定指示了不完整类型 '$1'"
  },
  {
    "id": "cannot decompose variable length array %qT",
    "pattern": "cannot decompose variable length array '(.+?)'",
    "replacement": "不能分解变长数组 '$1'"
  },
  {
    "id": "%u name provided for structured binding",
    "pattern": "(\\d+) names? provided for structured binding",
    "replacement": "结构化绑定提供了 $1 个名字"
  },
  {
    "id": "only %u name provided for structured binding",
    "pattern": "only (\\d+) names? provided for structured binding",
    "replacement": "结构化绑定只提供了 $1 个名字"
  },
  {
    "id": "while %qT decomposes into %wu element",
    "pattern": "while '(.+?)' decomposes into (.*?) elements?",
    "replacement": "当 '$1' 分解为 $2 个元素时"
  },
  {
    "id": "cannot decompose variable length vector %qT",
    "pattern": "cannot decompose variable length vector '(.+?)'",
    "replacement": "不能分解变长向量 '$1'"
  },
  {
    "id": "%<std::tuple_size<%T>::value%> is not an integral constant expression",
    "pattern": "'std::tuple_size<(.+?)>::value' is not an integral constant expression",
    "replacement": "'std::tuple_size<$1>::value' 不是一个整数常量表达式"
  },
  {
    "id": "%<std::tuple_element<%u, %T>::type%> is %<void%>",
    "pattern": "'std::tuple_element<(\\d+), (.+?)>::type' is 'void'",
    "replacement": "'std::tuple_element<$1, $2>::type' 是 'void'"
  },
  {
    "id": "in initialization of structured binding variable %qD",
    "pattern": "in initialization of structured binding variable '(.+?)'",
    "replacement": "在结构化绑定变量 '$1' 的初始化中"
  },
  {
    "id": "cannot decompose union type %qT",
    "pattern": "cannot decompose union type '(.+?)'",
    "replacement": "不能分解联合体类型 '$1'"
  },
  {
    "id": "cannot decompose non-array non-class type %qT",
    "pattern": "cannot decompose non-array non-class type '(.+?)'",
    "replacement": "不能分解非数组、非类类型 '$1'"
  },
  {
    "id": "cannot decompose lambda closure type %qT",
    "pattern": "cannot decompose lambda closure type '(.+?)'",
    "replacement": "不能分解地址 lambda 闭包类型 '$1'"
  },
  {
    "id": "structured binding refers to incomplete class type %qT",
    "pattern": "structured binding refers to incomplete class type '(.+?)'",
    "replacement": "结构化绑定指示了不完整类类型 '$1'"
  },
  {
    "id": "cannot decompose class type %qT without non-static data members",
    "pattern": "cannot decompose class type '(.+?)' without non-static data members",
    "replacement": "不能分解没有非静态数据成员的类类型 '$1'"
  },
  {
    "id": "non-local variable %qD declared %<__thread%> needs dynamic initialization",
    "pattern": "non-local variable '(.+?)' declared '__thread' needs dynamic initialization",
    "replacement": "声明为 '__thread' 的非局部变量 '$1' 需要动态初始化"
  },
  {
    "id": "non-local variable %qD declared %<__thread%> has a non-trivial destructor",
    "pattern": "non-local variable '(.+?)' declared '__thread' has a non-trivial destructor",
    "replacement": "声明为 '__thread' 的非局部变量拥有非平凡析构函数"
  },
  {
    "id": "C++11 %<thread_local%> allows dynamic initialization and destruction",
    "pattern": "C\\+\\+11 'thread_local' allows dynamic initialization and destruction",
    "replacement": "C++11 'thread_local' 允许动态初始化和析构"
  },
  {
    "id": "destructor for alien class %qT cannot be a member",
    "pattern": "destructor for alien class '(.+?)' cannot be a member",
    "replacement": "其它类 '$1' 的析构函数不能作为成员"
  },
  {
    "id": "constructor for alien class %qT cannot be a member",
    "pattern": "constructor for alien class '(.+?)' cannot be a member",
    "replacement": "其它类 '$1' 的构造函数不能作为成员"
  },
  {
    "id": "%qD declared as a %<virtual%> variable",
    "pattern": "'(.+?)' declared as a 'virtual' variable",
    "replacement": "'$1' 被声明为 'virtual' 变量"
  },
  {
    "id": "%<const%> and %<volatile%> function specifiers on %qD invalid in variable declaration",
    "pattern": "'const' and 'volatile' function specifiers on '(.+?)' invalid in variable declaration",
    "replacement": "'$1' 上的函数 'const' 和 'volatile' 说明符在变量声明上无效"
  },
  {
    "id": "%qD declared as a %<virtual%> parameter",
    "pattern": "'(.+?)' declared as a 'virtual' parameter",
    "replacement": "'$1' 被声明为 'virtual' 形参"
  },
  {
    "id": "%qD declared as an %<inline%> parameter",
    "pattern": "'(.+?)' declared as an 'inline' parameter",
    "replacement": "'$1' 被声明为 'inline' 形参"
  },
  {
    "id": "%<const%> and %<volatile%> function specifiers on %qD invalid in parameter declaration",
    "pattern": "'const' and 'volatile' function specifiers on '(.+?)' invalid in parameter declaration",
    "replacement": "'$1' 上的函数 'const' 和 'volatile' 说明符在形参声明上无效"
  },
  {
    "id": "%qD declared as a %<virtual%> type",
    "pattern": "'(.+?)' declared as a 'virtual' type",
    "replacement": "'$1' 被声明为 'virtual' 类型"
  },
  {
    "id": "%qD declared as an %<inline%> type",
    "pattern": "'(.+?)' declared as an 'inline' type",
    "replacement": "'$1' 被声明为 'inline' 类型"
  },
  {
    "id": "%<const%> and %<volatile%> function specifiers on %qD invalid in type declaration",
    "pattern": "'const' and 'volatile' function specifiers on '(.+?)' invalid in type declaration",
    "replacement": "'$1' 上的函数 'const' 和 'volatile' 说明符在类型声明上无效"
  },
  {
    "id": "%qD declared as a %<virtual%> field",
    "pattern": "'(.+?)' declared as a 'virtual' field",
    "replacement": "'$1' 被声明为 'virtual' 字段"
  },
  {
    "id": "%qD declared as an %<inline%> field",
    "pattern": "'(.+?)' declared as an 'inline' field",
    "replacement": "'$1' 被声明为 'inline' 字段"
  },
  {
    "id": "%<const%> and %<volatile%> function specifiers on %qD invalid in field declaration",
    "pattern": "'const' and 'volatile' function specifiers on '(.+?)' invalid in field declaration",
    "replacement": "'$1' 上的函数 'const' 和 'volatile' 说明符在字段声明上无效"
  },
  {
    "id": "%q+D declared as a friend",
    "pattern": "'(.+?)' declared as a friend",
    "replacement": "'$1' 被声明为友元"
  },
  {
    "id": "%q+D declared with an exception specification",
    "pattern": "'(.+?)' declared with an exception specification",
    "replacement": "'$1' 声明时带有异常说明"
  },
  {
    "id": "definition of %qD is not in namespace enclosing %qT",
    "pattern": "definition of '(.+?)' is not in namespace enclosing '(.+?)'",
    "replacement": "'$1' 的定义不在包含 '$2' 的命名空间中"
  },
  {
    "id": "static member function %q#D declared with type qualifiers",
    "pattern": "static member function '(.+?)' declared with type qualifiers",
    "replacement": "静态成员函数 '$1' 的声明带有类型限定符"
  },
  {
    "id": "concept %q#D declared with function parameters",
    "pattern": "concept '(.+?)' declared with function parameters",
    "replacement": "概念 '$1' 声明时带有函数形参"
  },
  {
    "id": "concept %q#D declared with a deduced return type",
    "pattern": "concept '(.+?)' declared with a deduced return type",
    "replacement": "概念 '$1' 声明时带有推导返回类型"
  },
  {
    "id": "concept %q#D with non-%<bool%> return type %qT",
    "pattern": "concept '(.+?)' with non-'bool' return type '(.+?)'",
    "replacement": "概念 '$1' 带有非 'bool' 返回类型 '$2'"
  },
  {
    "id": "concept %qD has no definition",
    "pattern": "concept '(.+?)' has no definition",
    "replacement": "概念 '$1' 没有定义"
  },
  {
    "id": "a function concept cannot be constrained",
    "pattern": "a function concept cannot be constrained",
    "replacement": "一个函数概念不能被约束"
  },
  {
    "id": "constraints on a non-templated function",
    "pattern": "constraints on a non-templated function",
    "replacement": "非模板函数上的约束"
  },
  {
    "id": "defining explicit specialization %qD in friend declaration",
    "pattern": "defining explicit specialization '(.+?)' in friend declaration",
    "replacement": "在友元声明中定义显式特例化 '$1'"
  },
  {
    "id": "invalid use of template-id %qD in declaration of primary template",
    "pattern": "invalid use of template-id '(.+?)' in declaration of primary template",
    "replacement": "在基本模板的声明中非法地使用了模板标识 '$1'"
  },
  {
    "id": "default arguments are not allowed in declaration of friend template specialization %qD",
    "pattern": "default arguments are not allowed in declaration of friend template specialization '(.+?)'",
    "replacement": "友元模板特化 '$1' 中不允许出现默认实参"
  },
  {
    "id": "%<inline%> is not allowed in declaration of friend template specialization %qD",
    "pattern": "'inline' is not allowed in declaration of friend template specialization '(.+?)'",
    "replacement": "'inline' 不允许用于友元模板特化 '$1' 的声明"
  },
  {
    "id": "friend declaration of %qD specifies default arguments and isn%'t a definition",
    "pattern": "friend declaration of '(.+?)' specifies default arguments and isn't a definition",
    "replacement": "带有默认实参的友元声明 '$1' 不是定义"
  },
  {
    "id": "cannot declare %<::main%> to be a template",
    "pattern": "cannot declare '::main' to be a template",
    "replacement": "不能将 '::main' 声明为一个模板"
  },
  {
    "id": "cannot declare %<::main%> to be inline",
    "pattern": "cannot declare '::main' to be inline",
    "replacement": "不能将 '::main' 声明为内联的"
  },
  {
    "id": "cannot declare %<::main%> to be %qs",
    "pattern": "cannot declare '::main' to be '(.+?)'",
    "replacement": "不能将 '::main' 声明为 '$1'"
  },
  {
    "id": "cannot declare %<::main%> to be static",
    "pattern": "cannot declare '::main' to be static",
    "replacement": "不能将 '::main' 声明为静态的"
  },
  {
    "id": "static member function %qD cannot have cv-qualifier",
    "pattern": "static member function '(.+?)' cannot have cv-qualifier",
    "replacement": "静态成员函数 '$1' 不能拥有 cv-限定符"
  },
  {
    "id": "non-member function %qD cannot have cv-qualifier",
    "pattern": "non-member function '(.+?)' cannot have cv-qualifier",
    "replacement": "非成员函数 '$1' 不能拥有 cv-限定符"
  },
  {
    "id": "static member function %qD cannot have ref-qualifier",
    "pattern": "static member function '(.+?)' cannot have ref-qualifier",
    "replacement": "静态成员函数 '$1' 不能拥有引用限定符"
  },
  {
    "id": "non-member function %qD cannot have ref-qualifier",
    "pattern": "non-member function '(.+?)' cannot have ref-qualifier",
    "replacement": "非成员函数 '$1' 不能拥有引用限定符"
  },
  {
    "id": "deduction guide %qD must be declared at namespace scope",
    "pattern": "deduction guide '(.+?)' must be declared at namespace scope",
    "replacement": "推导指引 '$1' 必须声明于命名空间作用域"
  },
  {
    "id": "deduction guide %qD must be declared in the same scope as %qT",
    "pattern": "deduction guide '(.+?)' must be declared in the same scope as '(.+?)'",
    "replacement": "推导指引 '$1' 必须声明在和 '$2' 相同的作用域内"
  },
  {
    "id": "deduction guide %qD must not have a function body",
    "pattern": "deduction guide '(.+?)' must not have a function body",
    "replacement": "推导指引 '$1' 不能有函数体"
  },
  {
    "id": "literal operator with C linkage",
    "pattern": "literal operator with C linkage",
    "replacement": "字面量操作符具有 C 连接"
  },
  {
    "id": "%qD has invalid argument list",
    "pattern": "'(.+?)' has invalid argument list",
    "replacement": "'$1' 带有无效实参列表"
  },
  {
    "id": "integer suffix %qs shadowed by implementation",
    "pattern": "integer suffix '(.+?)' shadowed by implementation",
    "replacement": "整数后缀 '$1' 被实现隐藏"
  },
  {
    "id": "floating-point suffix %qs shadowed by implementation",
    "pattern": "floating-point suffix '(.+?)' shadowed by implementation",
    "replacement": "浮点数后缀 '(.+?)' 被实现隐藏"
  },
  {
    "id": "literal operator suffixes not preceded by %<_%> are reserved for future standardization",
    "pattern": "literal operator suffixes not preceded by '_' are reserved for future standardization",
    "replacement": "不以 '_' 开头的字面量运算符为未来标准化所保留"
  },
  {
    "id": "%qD must be a non-member function",
    "pattern": "'(.+?)' must be a non-member function",
    "replacement": "'$1' 必须是一个非静态的成员函数"
  },
  {
    "id": "%<::main%> must return %<int%>",
    "pattern": "'::main' must return 'int'",
    "replacement": "'::main' 必须返回 'int'"
  },
  {
    "id": "definition of implicitly-declared %qD",
    "pattern": "definition of implicitly-declared '(.+?)'",
    "replacement": "隐式声明的 '$1' 的定义"
  },
  {
    "id": "definition of explicitly-defaulted %q+D",
    "pattern": "definition of explicitly-defaulted '(.+?)'",
    "replacement": "'$1' 的显式预置的声明"
  },
  {
    "id": "%q#D explicitly defaulted here",
    "pattern": "'(.+?)' explicitly defaulted here",
    "replacement": "'$1' 在此处显式预置"
  },
  {
    "id": "no %q#D member function declared in class %qT",
    "pattern": "no '(.+?)' member function declared in class '(.+?)'",
    "replacement": "类 '$2' 中未声明成员函数 '$1'"
  },
  {
    "id": "cannot declare %<::main%> to be a global variable",
    "pattern": "cannot declare '::main' to be a global variable",
    "replacement": "不能将 '::main' 声明为一个全局变量"
  },
  {
    "id": "a non-template variable cannot be %<concept%>",
    "pattern": "a non-template variable cannot be 'concept'",
    "replacement": "非模板变量不能是 'concept'"
  },
  {
    "id": "concept must be defined at namespace scope",
    "pattern": "concept must be defined at namespace scope",
    "replacement": "概念必须定义在命名空间作用域"
  },
  {
    "id": "concept must have type %<bool%>",
    "pattern": "concept must have type 'bool'",
    "replacement": "概念必须拥有 'bool' 类型"
  },
  {
    "id": "a variable concept cannot be constrained",
    "pattern": "a variable concept cannot be constrained",
    "replacement": "变量概念不能被约束"
  },
  {
    "id": "in-class initialization of static data member %q#D of incomplete type",
    "pattern": "in-class initialization of static data member '(.+?)' of incomplete type",
    "replacement": "对具有不完整类型的静态数据成员 '$1' 的类内初始化"
  },
  {
    "id": "%<constexpr%> needed for in-class initialization of static data member %q#D of non-integral type",
    "pattern": "'constexpr' needed for in-class initialization of static data member '(.+?)' of non-integral type",
    "replacement": "非整数类型的静态数据成员 '$1' 的类内初始化需要 'constexpr'"
  },
  {
    "id": "in-class initialization of static data member %q#D of non-literal type",
    "pattern": "in-class initialization of static data member '(.+?)' of non-literal type",
    "replacement": "非整数类型的静态数据成员 '$1' 的类内初始化"
  },
  {
    "id": "invalid in-class initialization of static data member of non-integral type %qT",
    "pattern": "invalid in-class initialization of static data member of non-integral type '(.+?)'",
    "replacement": "非整数类型 '$1' 的静态数据成员的类内初始化无效"
  },
  {
    "id": "ISO C++ forbids in-class initialization of non-const static member %qD",
    "pattern": "ISO C\\+\\+ forbids in-class initialization of non-const static member '(.+?)'",
    "replacement": "ISO C++ 禁止在类内初始化非只读静态成员 '$1'"
  },
  {
    "id": "ISO C++ forbids initialization of member constant %qD of non-integral type %qT",
    "pattern": "ISO C\\+\\+ forbids initialization of member constant '(.+?)' of non-integral type '(.+?)'",
    "replacement": "ISO C++ 禁止初始化成员常量 '$1'，因为它具有非整数类型 '$2'"
  },
  {
    "id": "size of array %qD has non-integral type %qT",
    "pattern": "size of array '(.+?)' has non-integral type '(.+?)'",
    "replacement": "数组 '$1' 的大小具有非整数类型 '$2'"
  },
  {
    "id": "size of array has non-integral type %qT",
    "pattern": "size of array has non-integral type '(.+?)'",
    "replacement": "数组大小具有非整数类型 '$1'"
  },
  {
    "id": "size of array %qD is not an integral constant-expression",
    "pattern": "size of array '(.+?)' is not an integral constant-expression",
    "replacement": "数组的大小 '$1' 不是整数常量表达式"
  },
  {
    "id": "size of array is not an integral constant-expression",
    "pattern": "size of array is not an integral constant-expression",
    "replacement": "数组大小不是整数常量表达式"
  },
  {
    "id": "ISO C++ forbids zero-size array %qD",
    "pattern": "ISO C\\+\\+ forbids zero-size array '(.+?)'",
    "replacement": "ISO C++ 禁止大小为零的数组 '$1'"
  },
  {
    "id": "ISO C++ forbids zero-size array",
    "pattern": "ISO C\\+\\+ forbids zero-size array",
    "replacement": "ISO C++ 禁止大小为零的数组"
  },
  {
    "id": "ISO C++ forbids variable length array %qD",
    "pattern": "ISO C\\+\\+ forbids variable length array '(.+?)'",
    "replacement": "ISO C++ 禁止变长数组 '$1'"
  },
  {
    "id": "ISO C++ forbids variable length array",
    "pattern": "ISO C\\+\\+ forbids variable length array",
    "replacement": "ISO C++ 禁止变长数组"
  },
  {
    "id": "variable length array %qD is used",
    "pattern": "variable length array '(.+?)' is used",
    "replacement": "使用了变长数组 '$1'"
  },
  {
    "id": "variable length array is used",
    "pattern": "variable length array is used",
    "replacement": "使用了变长数组"
  },
  {
    "id": "overflow in array dimension",
    "pattern": "overflow in array dimension",
    "replacement": "数组维数溢出"
  },
  {
    "id": "%qD declared as array of %qT",
    "pattern": "'(.+?)' declared as array of '(.+?)'",
    "replacement": "'$1' 被声明为 '$2' 的数组"
  },
  {
    "id": "creating array of %qT",
    "pattern": "creating array of '(.+?)'",
    "replacement": "生成 '$1' 的数组"
  },
  {
    "id": "declaration of %qD as array of void",
    "pattern": "declaration of '(.+?)' as array of void",
    "replacement": "'$1' 被声明为 void 的数组"
  },
  {
    "id": "creating array of void",
    "pattern": "creating array of void",
    "replacement": "创建 void 的数组"
  },
  {
    "id": "declaration of %qD as array of functions",
    "pattern": "declaration of '(.+?)' as array of functions",
    "replacement": "'$1' 被声明为函数的数组"
  },
  {
    "id": "creating array of functions",
    "pattern": "creating array of functions",
    "replacement": "创建函数的数组"
  },
  {
    "id": "declaration of %qD as array of references",
    "pattern": "declaration of '(.+?)' as array of references",
    "replacement": "'$1' 被声明为引用的数组"
  },
  {
    "id": "creating array of references",
    "pattern": "creating array of references",
    "replacement": "创建引用的数组"
  },
  {
    "id": "declaration of %qD as array of function members",
    "pattern": "declaration of '(.+?)' as array of function members",
    "replacement": "'$1' 被声明为函数成员的数组"
  },
  {
    "id": "creating array of function members",
    "pattern": "creating array of function members",
    "replacement": "创建函数成员的数组"
  },
  {
    "id": "declaration of %qD as multidimensional array must have bounds for all dimensions except the first",
    "pattern": "declaration of '(.+?)' as multidimensional array must have bounds for all dimensions except the first",
    "replacement": "多维数组 '$1' 的声明必须指定除第一维以外所有维的大小"
  },
  {
    "id": "multidimensional array must have bounds for all dimensions except the first",
    "pattern": "multidimensional array must have bounds for all dimensions except the first",
    "replacement": "声明多维数组必须指定除第一维以外所有维的大小"
  },
  {
    "id": "return type specification for constructor invalid",
    "pattern": "return type specification for constructor invalid",
    "replacement": "指定构造函数的返回类型无效"
  },
  {
    "id": "qualifiers are not allowed on constructor declaration",
    "pattern": "qualifiers are not allowed on constructor declaration",
    "replacement": "构造函数声明中不允许使用限定符"
  },
  {
    "id": "return type specification for destructor invalid",
    "pattern": "return type specification for destructor invalid",
    "replacement": "指定析构函数的返回类型无效"
  },
  {
    "id": "qualifiers are not allowed on destructor declaration",
    "pattern": "qualifiers are not allowed on destructor declaration",
    "replacement": "析构函数声明中不允许使用限定符"
  },
  {
    "id": "return type specified for %<operator %T%>",
    "pattern": "return type specified for 'operator (.+?)'",
    "replacement": "指定了 'operator $1' 的返回类型"
  },
  {
    "id": "qualifiers are not allowed on declaration of %<operator %T%>",
    "pattern": "qualifiers are not allowed on declaration of 'operator (.+?)'",
    "replacement": "'operator $1' 的声明中不允许使用限定符"
  },
  {
    "id": "return type specified for deduction guide",
    "pattern": "return type specified for deduction guide",
    "replacement": "指定推导指引的返回类型无效"
  },
  {
    "id": "qualifiers are not allowed on declaration of deduction guide",
    "pattern": "qualifiers are not allowed on declaration of deduction guide",
    "replacement": "推导指引的声明中不允许使用限定符"
  },
  {
    "id": "template template parameter %qT in declaration of deduction guide",
    "pattern": "template template parameter '(.+?)' in declaration of deduction guide",
    "replacement": "推导指引的声明中出现模板模板实参 '$1'"
  },
  {
    "id": "%<decl-specifier%> in declaration of deduction guide",
    "pattern": "'decl-specifier' in declaration of deduction guide",
    "replacement": "推导指引的声明中出现 'decl-specifier'"
  },
  {
    "id": "unnamed variable or field declared void",
    "pattern": "unnamed variable or field declared void",
    "replacement": "无名变量或字段声明为 void"
  },
  {
    "id": "variable or field declared void",
    "pattern": "variable or field declared void",
    "replacement": "变量或字段声明为 void"
  },
  {
    "id": "%<inline%> specifier invalid for variable %qD declared at block scope",
    "pattern": "'inline' specifier invalid for variable '(.+?)' declared at block scope",
    "replacement": "在块作用域声明的变量 '$1' 的 'inline' 说明符无效"
  },
  {
    "id": "inline variables are only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "inline variables are only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "内联变量仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "invalid use of qualified-name %<::%D%>",
    "pattern": "invalid use of qualified-name '::(.+?)'",
    "replacement": "非法地使用了限定名 '::$1'"
  },
  {
    "id": "invalid use of qualified-name %<%T::%D%>",
    "pattern": "invalid use of qualified-name '(.+?)::(.+?)'",
    "replacement": "非法地使用了限定名 '$1::$2'"
  },
  {
    "id": "%q#T is not a class or namespace",
    "pattern": "'(.+?)' is not a class or namespace",
    "replacement": "'$1' 不是类或命名空间"
  },
  {
    "id": "declaration of %qE as non-function",
    "pattern": "declaration of '(.+?)' as non-function",
    "replacement": "'$1' 声明为非函数"
  },
  {
    "id": "declaration of %qE as non-member",
    "pattern": "declaration of '(.+?)' as non-member",
    "replacement": "'$1' 声明为非成员"
  },
  {
    "id": "declarator-id missing; using reserved word %qD",
    "pattern": "declarator-id missing; using reserved word '(.+?)'",
    "replacement": "缺少声明符标识；使用了保留字 '$1'"
  },
  {
    "id": "function definition does not declare parameters",
    "pattern": "function definition does not declare parameters",
    "replacement": "函数定义未声明形参"
  },
  {
    "id": "declaration of %qD as %<typedef%>",
    "pattern": "declaration of '(.+?)' as 'typedef'",
    "replacement": "'$1' 声明为 'typedef'"
  },
  {
    "id": "declaration of %qD as parameter",
    "pattern": "declaration of '(.+?)' as parameter",
    "replacement": "'$1' 声明为形参"
  },
  {
    "id": "both %qs and %qs specified",
    "pattern": "both '(.+?)' and '(.+?)' specified",
    "replacement": "'$1' 和 '$2' 都被指明"
  },
  {
    "id": "%qs cannot appear in a typedef declaration",
    "pattern": "'(.+?)' cannot appear in a typedef declaration",
    "replacement": "'$1' 不能出现在 typedef 声明中"
  },
  {
    "id": "can use at most one of the %<constinit%> and %<constexpr%> specifiers",
    "pattern": "can use at most one of the 'constinit' and 'constexpr' specifiers",
    "replacement": "'continit' 和 'contexpr' 说明符中最多只能使用一个"
  },
  {
    "id": "two or more data types in declaration of %qs",
    "pattern": "two or more data types in declaration of '(.+?)'",
    "replacement": "'$1' 的声明指定了两个以上的数据类型"
  },
  {
    "id": "conflicting specifiers in declaration of %qs",
    "pattern": "conflicting specifiers in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中有相互冲突的说明符"
  },
  {
    "id": "ISO C++ does not support plain %<complex%> meaning %<double complex%>",
    "pattern": "ISO C\\+\\+ does not support plain 'complex' meaning 'double complex'",
    "replacement": "ISO C++ 不支持单独以 'complex' 表示 'double complex'"
  },
  {
    "id": "ISO C++ forbids declaration of %qs with no type",
    "pattern": "ISO C\\+\\+ forbids declaration of '(.+?)' with no type",
    "replacement": "ISO C++ 禁止声明无类型的 '$1'"
  },
  {
    "id": "%<__int%d%> is not supported by this target",
    "pattern": "'__int(\\d+)' is not supported by this target",
    "replacement": "'__int$1' 不被此目标支持"
  },
  {
    "id": "ISO C++ does not support %<__int%d%> for %qs",
    "pattern": "ISO C\\+\\+ does not support '__int(\\d+)' for '(.+?)'",
    "replacement": "ISO C++ 对 '$2' 不支持 '__int$1'"
  },
  {
    "id": "%<signed%> and %<unsigned%> specified together",
    "pattern": "'signed' and 'unsigned' specified together",
    "replacement": "同时指定了 'signed' 和 'unsigned'"
  },
  {
    "id": "%<long%> and %<short%> specified together",
    "pattern": "'long' and 'short' specified together",
    "replacement": "同时指定了 'long' 和 'short'"
  },
  {
    "id": "%qs specified with %qT",
    "pattern": "'(.+?)' specified with '(.+?)'",
    "replacement": "'$1' 指定了 '$2'"
  },
  {
    "id": "%qs specified with %<decltype%>",
    "pattern": "'(.+?)' specified with 'decltype'",
    "replacement": "'$1' 指定了 'decltype'"
  },
  {
    "id": "%qs specified with %<typeof%>",
    "pattern": "'(.+?)' specified with 'typeof'",
    "replacement": "'$1' 指定了 'typeof'"
  },
  {
    "id": "complex invalid for %qs",
    "pattern": "complex invalid for '(.+?)'",
    "replacement": "对 '$1' 而言无效的复数"
  },
  {
    "id": "template placeholder type %qT must be followed by a simple declarator-id",
    "pattern": "template placeholder type '(.+?)' must be followed by a simple declarator-id",
    "replacement": "模板占位符类型 '$1' 必须跟随一个简单声明符标识"
  },
  {
    "id": "member %qD cannot be declared both %<virtual%> and %<static%>",
    "pattern": "member '(.+?)' cannot be declared both 'virtual' and 'static'",
    "replacement": "成员 '$1' 不能同时被声明为 'virtual' 和 'static'"
  },
  {
    "id": "member %qD can be declared both %<virtual%> and %<constexpr%> only in %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "member '(.+?)' can be declared both 'virtual' and 'constexpr' only in '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "成员 '$1' 同时被声明为 'virtaul' 和 'constexpr' 仅在 'std=c++20' 或 'std=gnu++20' 下可用"
  },
  {
    "id": "typedef declaration invalid in parameter declaration",
    "pattern": "typedef declaration invalid in parameter declaration",
    "replacement": "形参声明中出现的 typedef 声明无效"
  },
  {
    "id": "storage class specified for template parameter %qs",
    "pattern": "storage class specified for template parameter '(.+?)'",
    "replacement": "为模板形参 '$1' 指定了存储类"
  },
  {
    "id": "storage class specified for parameter %qs",
    "pattern": "storage class specified for parameter '(.+?)'",
    "replacement": "为形参 '(.+?)' 指定了存储类"
  },
  {
    "id": "a parameter cannot be declared %qs",
    "pattern": "a parameter cannot be declared '(.+?)'",
    "replacement": "形参不能被声明为 '$1'"
  },
  {
    "id": "%<virtual%> outside class declaration",
    "pattern": "'virtual' outside class declaration",
    "replacement": "'virtual' 在类声明外使用"
  },
  {
    "id": "structured binding declaration cannot be %qs",
    "pattern": "structured binding declaration cannot be '(.+?)'",
    "replacement": "结构化绑定声明不能是 '$1'"
  },
  {
    "id": "structured binding declaration can be %qs only in %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "structured binding declaration can be '(.+?)' only in '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "结构化绑定声明可以是 '$1' 的仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "%<volatile%>-qualified structured binding is deprecated",
    "pattern": "'volatile'-qualified structured binding is deprecated",
    "replacement": "'volatile' 限定的结构化绑定被弃用"
  },
  {
    "id": "structured binding declaration cannot be C++98 %<auto%>",
    "pattern": "structured binding declaration cannot be C\\+\\+98 'auto'",
    "replacement": "结构化绑定声明不能为 C++98 'auto'"
  },
  {
    "id": "structured binding declaration cannot have type %qT",
    "pattern": "structured binding declaration cannot have type '(.+?)'",
    "replacement": "结构化绑定声明不能具有类型 '$1'"
  },
  {
    "id": "type must be cv-qualified %<auto%> or reference to cv-qualified %<auto%>",
    "pattern": "type must be cv-qualified 'auto' or reference to cv-qualified 'auto'",
    "replacement": "类型必须是 cv-限定的 'auto' 或者到 cv-限定的 'auto' 的引用"
  },
  {
    "id": "multiple storage classes in declaration of %qs",
    "pattern": "multiple storage classes in declaration of '(.+?)'",
    "replacement": "'$1' 的声明指定了多个存储类"
  },
  {
    "id": "storage class specified for %qs",
    "pattern": "storage class specified for '(.+?)'",
    "replacement": "为 '$1' 指定了存储类"
  },
  {
    "id": "nested function %qs declared %<extern%>",
    "pattern": "nested function '(.+?)' declared 'extern'",
    "replacement": "嵌套函数 '$1' 被声明为'extern'"
  },
  {
    "id": "top-level declaration of %qs specifies %<auto%>",
    "pattern": "top-level declaration of '(.+?)' specifies 'auto'",
    "replacement": "'$1' 的顶层声明指定为 'auto'"
  },
  {
    "id": "function-scope %qs implicitly auto and declared %<__thread%>",
    "pattern": "function-scope '(.+?)' implicitly auto and declared '__thread'",
    "replacement": "函数作用域的 '$1' 隐式为 auto，却被声明为 '__thread'"
  },
  {
    "id": "storage class specifiers invalid in friend function declarations",
    "pattern": "storage class specifiers invalid in friend function declarations",
    "replacement": "为友元函数声明指定了无效的存储类"
  },
  {
    "id": "attribute ignored",
    "pattern": "attribute ignored",
    "replacement": "特性被忽略"
  },
  {
    "id": "an attribute that appertains to a type-specifier is ignored",
    "pattern": "an attribute that appertains to a type-specifier is ignored",
    "replacement": "属于类型说明符的特性被忽略"
  },
  {
    "id": "unnecessary parentheses in declaration of %qs",
    "pattern": "unnecessary parentheses in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中存在不必要的括号"
  },
  {
    "id": "remove parentheses",
    "pattern": "remove parentheses",
    "replacement": "移除括号"
  },
  {
    "id": "requires-clause on return type",
    "pattern": "requires-clause on return type",
    "replacement": "返回类型中出现 requires 子句"
  },
  {
    "id": "%qs function uses %<auto%> type specifier without trailing return type",
    "pattern": "'(.+?)' function uses 'auto' type specifier without trailing return type",
    "replacement": "'$1' 函数使用了 'auto' 类型说明符却没有尾随返回类型"
  },
  {
    "id": "deduced return type only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "deduced return type only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "返回类型推导仅在 'std=c++14' 或 'std=gnu++14' 下可用"
  },
  {
    "id": "virtual function cannot have deduced return type",
    "pattern": "virtual function cannot have deduced return type",
    "replacement": "虚函数不能拥有返回类型推导"
  },
  {
    "id": "%qs function with trailing return type has %qT as its type rather than plain %<auto%>",
    "pattern": "'(.+?)' function with trailing return type has '(.+?)' as its type rather than plain 'auto'",
    "replacement": "带尾随返回类型的 '$1' 函数使用 '$2' 作为其类型，而不是单纯的 'auto'"
  },
  {
    "id": "%qs function with trailing return type has %<decltype(auto)%> as its type rather than plain %<auto%>",
    "pattern": "'(.+?)' function with trailing return type has 'decltype(auto)' as its type rather than plain 'auto'",
    "replacement": "带尾随返回类型的 '$1' 函数使用 'decltype(auto)' 作为其类型，而不是单纯的 'auto'"
  },
  {
    "id": "invalid use of %<decltype(auto)%>",
    "pattern": "invalid use of 'decltype(auto)'",
    "replacement": "非法地使用了 'decltype(auto)'"
  },
  {
    "id": "deduced class type %qD in function return type",
    "pattern": "deduced class type '(.+?)' in function return type",
    "replacement": "函数返回类型中推导出类类型 '$1'"
  },
  {
    "id": "deduction guide for %qT must have trailing return type",
    "pattern": "deduction guide for '(.+?)' must have trailing return type",
    "replacement": "'$1' 的推导指引必须有尾随返回类型"
  },
  {
    "id": "trailing return type %qT of deduction guide is not a specialization of %qT",
    "pattern": "trailing return type '(.+?)' of deduction guide is not a specialization of '(.+?)'",
    "replacement": "推导指引的尾随返回类型 '$1' 不是 '$2' 的特化"
  },
  {
    "id": "trailing return type only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "trailing return type only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "尾随返回类型仅在 '-std=c++11' 或 'std=gnu++11' 下可用"
  },
  {
    "id": "%qs function with trailing return type not declared with %<auto%> type specifier",
    "pattern": "'(.+?)' function with trailing return type not declared with 'auto' type specifier",
    "replacement": "带尾随返回类型的 '$1' 函数没有用 'auto' 作为类型说明符声明"
  },
  {
    "id": "%<volatile%>-qualified return type is deprecated",
    "pattern": "'volatile'-qualified return type is deprecated",
    "replacement": "'volatile' 限定的返回类型被弃用"
  },
  {
    "id": "%qs declared as function returning a function",
    "pattern": "'(.+?)' declared as function returning a function",
    "replacement": "'$1' 声明为返回一个函数的函数"
  },
  {
    "id": "%qs declared as function returning an array",
    "pattern": "'(.+?)' declared as function returning an array",
    "replacement": "'$1' 声明为返回一个数组的函数"
  },
  {
    "id": "%<constinit%> on function return type is not allowed",
    "pattern": "'constinit' on function return type is not allowed",
    "replacement": "函数返回类型中的 'constinit' 不被允许"
  },
  {
    "id": "%qT as type rather than plain %<decltype(auto)%>",
    "pattern": "'(.+?)' as type rather than plain 'decltype(auto)'",
    "replacement": "'$1' 作为类型而非单纯的 'decltype(auto)'"
  },
  {
    "id": "%<decltype(auto)%> cannot be cv-qualified",
    "pattern": "'decltype(auto)' cannot be cv-qualified",
    "replacement": "'decltype(auto)' 不能是 cv-限定的"
  },
  {
    "id": "destructor cannot be static member function",
    "pattern": "destructor cannot be static member function",
    "replacement": "析构函数不能是静态成员函数"
  },
  {
    "id": "constructor cannot be static member function",
    "pattern": "constructor cannot be static member function",
    "replacement": "析构函数不能是静态成员函数"
  },
  {
    "id": "destructors may not be cv-qualified",
    "pattern": "destructors may not be cv-qualified",
    "replacement": "析构函数不能是 cv-限定的"
  },
  {
    "id": "constructors may not be cv-qualified",
    "pattern": "constructors may not be cv-qualified",
    "replacement": "构造函数不能是 cv-限定的"
  },
  {
    "id": "destructors may not be ref-qualified",
    "pattern": "destructors may not be ref-qualified",
    "replacement": "析构函数不能是引用限定的"
  },
  {
    "id": "constructors may not be ref-qualified",
    "pattern": "constructors may not be ref-qualified",
    "replacement": "构造函数不能是引用限定的"
  },
  {
    "id": "constructors cannot be declared %<virtual%>",
    "pattern": "constructors cannot be declared 'virtual'",
    "replacement": "构造函数不能被声明为 'virtual'"
  },
  {
    "id": "virtual functions cannot be friends",
    "pattern": "virtual functions cannot be friends",
    "replacement": "虚函数不能是友元"
  },
  {
    "id": "friend declaration not in class definition",
    "pattern": "friend declaration not in class definition",
    "replacement": "友元声明不在类定义内"
  },
  {
    "id": "cannot define friend function %qs in a local class definition",
    "pattern": "cannot define friend function '(.+?)' in a local class definition",
    "replacement": "局部类定义中不能定义友元函数 '$1'"
  },
  {
    "id": "friend function definition %qs cannot have a name qualified with %<::%>",
    "pattern": "friend function definition '(.+?)' cannot have a name qualified with '::'",
    "replacement": "友元函数定义 '$1' 不能拥有带 '::' 的限定名"
  },
  {
    "id": "friend function definition %qs cannot have a name qualified with %<%D::%>",
    "pattern": "friend function definition '(.+?)' cannot have a name qualified with '(.+?)::'",
    "replacement": "友元函数定义 '$1' 不能拥有带 '$2::' 的限定名"
  },
  {
    "id": "a conversion function cannot have a trailing return type",
    "pattern": "a conversion function cannot have a trailing return type",
    "replacement": "转换函数不能拥有尾随返回类型"
  },
  {
    "id": "destructors may not have parameters",
    "pattern": "destructors may not have parameters",
    "replacement": "析构函数不能有形参"
  },
  {
    "id": "cannot declare pointer to %q#T",
    "pattern": "cannot declare pointer to '(.+?)'",
    "replacement": "不能声明指向 '$1' 的指针"
  },
  {
    "id": "cannot declare reference to %q#T",
    "pattern": "cannot declare reference to '(.+?)'",
    "replacement": "不能声明到 '$1' 的引用"
  },
  {
    "id": "cannot declare pointer to %q#T member",
    "pattern": "cannot declare pointer to '(.+?)' member",
    "replacement": "不能声明指向 '$1' 成员的指针"
  },
  {
    "id": "cannot declare reference to qualified function type %qT",
    "pattern": "cannot declare reference to qualified function type '(.+?)'",
    "replacement": "不能声明到限定函数类型 '$1' 的引用"
  },
  {
    "id": "cannot declare pointer to qualified function type %qT",
    "pattern": "cannot declare pointer to qualified function type '(.+?)'",
    "replacement": "不能声明指向限定函数类型 '$1' 的指针"
  },
  {
    "id": "cannot declare reference to %q#T, which is not a typedef or a template type argument",
    "pattern": "cannot declare reference to '(.+?)', which is not a typedef or a template type argument",
    "replacement": "不能声明到 '$1' 的引用，因为它不是 typedef 或者模板类型实参"
  },
  {
    "id": "template-id %qD used as a declarator",
    "pattern": "template-id '(.+?)' used as a declarator",
    "replacement": "模板标识 '$1' 用作声明"
  },
  {
    "id": "member functions are implicitly friends of their class",
    "pattern": "member functions are implicitly friends of their class",
    "replacement": "成员函数隐式地成为所属类的友元"
  },
  {
    "id": "extra qualification %<%T::%> on member %qs",
    "pattern": "extra qualification '(.+?)::' on member '(.+?)'",
    "replacement": "成员 '$2' 上有多余的限定 '$1::'"
  },
  {
    "id": "cannot define member function %<%T::%s%> within %qT",
    "pattern": "cannot define member function '(.+?)::(.*?)' within '(.+?)'",
    "replacement": "在 '$3' 中无法定义成员函数 '$1::$2'，"
  },
  {
    "id": "cannot declare member function %<%T::%s%> within %qT",
    "pattern": "cannot declare member function '(.+?)::(.*?)' within '(.+?)'",
    "replacement": "在 '$3' 中无法声明成员 '$1::$2'，"
  },
  {
    "id": "cannot declare member %<%T::%s%> within %qT",
    "pattern": "cannot declare member '(.+?)::(.*?)' within '(.+?)'",
    "replacement": "在 '$3' 中无法声明成员 '$1::$2'，"
  },
  {
    "id": "non-parameter %qs cannot be a parameter pack",
    "pattern": "non-parameter '(.+?)' cannot be a parameter pack",
    "replacement": "非形参 '$1' 不能是一个形参包"
  },
  {
    "id": "data member may not have variably modified type %qT",
    "pattern": "data member may not have variably modified type '(.+?)'",
    "replacement": "数据成员不能具有可变修改类型 '$1'"
  },
  {
    "id": "parameter may not have variably modified type %qT",
    "pattern": "parameter may not have variably modified type '(.+?)'",
    "replacement": "形参不能具有可变修改类型 '$1'"
  },
  {
    "id": "%<explicit%> outside class declaration",
    "pattern": "'explicit' outside class declaration",
    "replacement": "'explicit' 在类声明以外使用"
  },
  {
    "id": "%<explicit%> in friend declaration",
    "pattern": "'explicit' in friend declaration",
    "replacement": "'explicit' 在友元声明中使用"
  },
  {
    "id": "only declarations of constructors and conversion operators can be %<explicit%>",
    "pattern": "only declarations of constructors and conversion operators can be 'explicit'",
    "replacement": "只有构造函数和转换运算符才能被声明为 'explicit'"
  },
  {
    "id": "non-member %qs cannot be declared %<mutable%>",
    "pattern": "non-member '(.+?)' cannot be declared 'mutable'",
    "replacement": "非成员 '$1' 不能被声明为 'mutable'"
  },
  {
    "id": "non-object member %qs cannot be declared %<mutable%>",
    "pattern": "non-object member '(.+?)' cannot be declared 'mutable'",
    "replacement": "非对象成员 '$1' 不能被声明为 'mutable'"
  },
  {
    "id": "function %qs cannot be declared %<mutable%>",
    "pattern": "function '(.+?)' cannot be declared 'mutable'",
    "replacement": "函数 '$1' 不能被声明为 'mutable'"
  },
  {
    "id": "%<static%> %qs cannot be declared %<mutable%>",
    "pattern": "'static' '(.+?)' cannot be declared 'mutable'",
    "replacement": "'static' '$1' 不能被声明为 'mutable'"
  },
  {
    "id": "%<const%> %qs cannot be declared %<mutable%>",
    "pattern": "'const' '(.+?)' cannot be declared 'mutable'",
    "replacement": "'const' '$1' 不能被声明为 'mutable'"
  },
  {
    "id": "reference %qs cannot be declared %<mutable%>",
    "pattern": "reference '(.+?)' cannot be declared 'mutable'",
    "replacement": "引用 '(.+?)' 不能被声明为 'mutable'"
  },
  {
    "id": "typedef may not be a function definition",
    "pattern": "typedef may not be a function definition",
    "replacement": "typdef 不能是函数定义"
  },
  {
    "id": "typedef may not be a member function definition",
    "pattern": "typedef may not be a member function definition",
    "replacement": "typedef 不能是成员函数定义"
  },
  {
    "id": "%<auto%> not allowed in alias declaration",
    "pattern": "'auto' not allowed in alias declaration",
    "replacement": "别名声明中不允许出现 'auto'"
  },
  {
    "id": "typedef declared %<auto%>",
    "pattern": "typedef declared 'auto'",
    "replacement": "typedef 被声明为 'inline'"
  },
  {
    "id": "requires-clause on typedef",
    "pattern": "requires-clause on typedef",
    "replacement": "typedef 中出现 requires-子句"
  },
  {
    "id": "typedef name may not be a nested-name-specifier",
    "pattern": "typedef name may not be a nested-name-specifier",
    "replacement": "typedef 名不能是嵌套名说明符"
  },
  {
    "id": "ISO C++ forbids nested type %qD with same name as enclosing class",
    "pattern": "ISO C\\+\\+ forbids nested type '(.+?)' with same name as enclosing class",
    "replacement": "ISO C++ 禁止嵌套的类型 '$1' 与其所属的类重名"
  },
  {
    "id": "%<inline%> specified for friend class declaration",
    "pattern": "'inline' specified for friend class declaration",
    "replacement": "友元类声明中指定了 'inline'"
  },
  {
    "id": "template parameters cannot be friends",
    "pattern": "template parameters cannot be friends",
    "replacement": "模板形参不能是友元"
  },
  {
    "id": "friend declaration requires class-key, i.e. %<friend class %T::%D%>",
    "pattern": "friend declaration requires class-key, i.e. 'friend class (.+?)::(.+?)'",
    "replacement": "友元声明需要类关键字，即 'friend class $1::$2'"
  },
  {
    "id": "friend declaration requires class-key, i.e. %<friend %#T%>",
    "pattern": "friend declaration requires class-key, i.e. 'friend (.+?)'",
    "replacement": "友元声明需要类关键字，即 'friend $1'"
  },
  {
    "id": "trying to make class %qT a friend of global scope",
    "pattern": "trying to make class '(.+?)' a friend of global scope",
    "replacement": "试图让类 '(.+?)' 成为全局作用域的友元"
  },
  {
    "id": "invalid qualifiers on non-member function type",
    "pattern": "invalid qualifiers on non-member function type",
    "replacement": "非成员函数类型上的限定符无效"
  },
  {
    "id": "requires-clause on type-id",
    "pattern": "requires-clause on type-id",
    "replacement": "类型标识中出现 requires 子句"
  },
  {
    "id": "abstract declarator %qT used as declaration",
    "pattern": "abstract declarator '(.+?)' used as declaration",
    "replacement": "抽象声明符 '$1' 被用作声明"
  },
  {
    "id": "requires-clause on declaration of non-function type %qT",
    "pattern": "requires-clause on declaration of non-function type '(.+?)'",
    "replacement": "非函数类型 '$1' 的声明中出现 requires 子句"
  },
  {
    "id": "cannot use %<::%> in parameter declaration",
    "pattern": "cannot use '::' in parameter declaration",
    "replacement": "不能在形参声明中使用 '::'"
  },
  {
    "id": "cannot declare a parameter with %<decltype(auto)%>",
    "pattern": "cannot declare a parameter with 'decltype(auto)'",
    "replacement": "不能将形参声明为 'decltype(auto)'"
  },
  {
    "id": "class template placeholder %qE not permitted in this context",
    "pattern": "class template placeholder '(.+?)' not permitted in this context",
    "replacement": "此语境下不允许类模板占位符 '$1' "
  },
  {
    "id": "use %<auto%> for an abbreviated function template",
    "pattern": "use 'auto' for an abbreviated function template",
    "replacement": "使用 'auto' 作为简写函数模板"
  },
  {
    "id": "%<auto%> parameter not permitted in this context",
    "pattern": "'auto' parameter not permitted in this context",
    "replacement": "此语境下不允许 'auto' 形参"
  },
  {
    "id": "parameter declared %<auto%>",
    "pattern": "parameter declared 'auto'",
    "replacement": "形参声明为 'auto'"
  },
  {
    "id": "invalid use of template-name %qE without an argument list",
    "pattern": "invalid use of template-name '(.+?)' without an argument list",
    "replacement": "不带实参列表地使用模板名 '$1' 是无效的"
  },
  {
    "id": "non-static data member declared with placeholder %qT",
    "pattern": "non-static data member declared with placeholder '(.+?)'",
    "replacement": "非静态数据成员声明时带有占位符 '$1'"
  },
  {
    "id": "ISO C++ forbids flexible array member %qs",
    "pattern": "ISO C\\+\\+ forbids flexible array member '(.+?)'",
    "replacement": "ISO C++ 禁止柔性数组成员 '$1'"
  },
  {
    "id": "ISO C++ forbids flexible array members",
    "pattern": "ISO C\\+\\+ forbids flexible array members",
    "replacement": "ISO C++ 禁止柔性数组成员"
  },
  {
    "id": "invalid use of %<::%>",
    "pattern": "invalid use of '::'",
    "replacement": "非法地使用了 '::'"
  },
  {
    "id": "declaration of function %qD in invalid context",
    "pattern": "declaration of function '(.+?)' in invalid context",
    "replacement": "函数 '$1' 的声明处于无效上下文中"
  },
  {
    "id": "function %qD declared %<virtual%> inside a union",
    "pattern": "function '(.+?)' declared 'virtual' inside a union",
    "replacement": "函数 '$1' 在联合体内被声明为 'virtual'"
  },
  {
    "id": "%qD cannot be declared %<virtual%>, since it is always static",
    "pattern": "'(.+?)' cannot be declared 'virtual', since it is always static",
    "replacement": "'(.+?)' 不能被声明为 'virtual'，因为它总是静态的"
  },
  {
    "id": "expected qualified name in friend declaration for destructor %qD",
    "pattern": "expected qualified name in friend declaration for destructor '(.+?)'",
    "replacement": "在析构函数 '$1' 中的友元声明需要限定名"
  },
  {
    "id": "declaration of %qD as member of %qT",
    "pattern": "declaration of '(.+?)' as member of '(.+?)'",
    "replacement": "'$1' 声明为 '$2' 的一个成员"
  },
  {
    "id": "a destructor cannot be %qs",
    "pattern": "a destructor cannot be '(.+?)'",
    "replacement": "析构函数不能是 '$1' 的"
  },
  {
    "id": "%<constexpr%> destructors only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "'constexpr' destructors only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'constexpr' 析构函数仅在 '-std=c++20' 或 'std=gnu++20' 下可用"
  },
  {
    "id": "expected qualified name in friend declaration for constructor %qD",
    "pattern": "expected qualified name in friend declaration for constructor '(.+?)'",
    "replacement": "在构造函数 '$1' 中的友元声明需要限定名"
  },
  {
    "id": "a constructor cannot be %<concept%>",
    "pattern": "a constructor cannot be 'concept'",
    "replacement": "构造函数不能是 'concept'"
  },
  {
    "id": "a concept cannot be a member function",
    "pattern": "a concept cannot be a member function",
    "replacement": "概念不能是成员函数"
  },
  {
    "id": "%qD cannot be %qs",
    "pattern": "'(.+?)' cannot be '(.+?)'",
    "replacement": "'$1' 不能是 '$2'"
  },
  {
    "id": "specialization of variable template %qD declared as function",
    "pattern": "specialization of variable template '(.+?)' declared as function",
    "replacement": "变量模板 '$1' 的特化被声明为函数"
  },
  {
    "id": "variable template declared here",
    "pattern": "variable template declared here",
    "replacement": "变量模板在此声明"
  },
  {
    "id": "field %qD has incomplete type %qT",
    "pattern": "field '(.+?)' has incomplete type '(.+?)'",
    "replacement": "字段 '$1' 具有不完整类型 '$2'"
  },
  {
    "id": "name %qT has incomplete type",
    "pattern": "name '(.+?)' has incomplete type",
    "replacement": "名字 '$1' 具有不完整类型"
  },
  {
    "id": "%qE is neither function nor member function; cannot be declared friend",
    "pattern": "'(.+?)' is neither function nor member function; cannot be declared friend",
    "replacement": "'$1' 既不是函数也不是成员函数；不能被声明为友元"
  },
  {
    "id": "unnamed field is neither function nor member function; cannot be declared friend",
    "pattern": "unnamed field is neither function nor member function; cannot be declared friend",
    "replacement": "无名字段既不是函数也不是成员函数；不能被声明为友元"
  },
  {
    "id": "static data member %qE declared %qs",
    "pattern": "static data member '(.+?)' declared '(.+?)'",
    "replacement": "静态数据成员 '$1' 被声明为 '$2'"
  },
  {
    "id": "%<constexpr%> static data member %qD must have an initializer",
    "pattern": "'constexpr' static data member '(.+?)' must have an initializer",
    "replacement": "'constexpr' 静态数据成员 '$1' 必须拥有一个初始化器"
  },
  {
    "id": "non-static data member %qE declared %qs",
    "pattern": "non-static data member '(.+?)' declared '(.+?)'",
    "replacement": "非静态数据成员 '$1' 被声明为 '$2'"
  },
  {
    "id": "storage class %<auto%> invalid for function %qs",
    "pattern": "storage class 'auto' invalid for function '(.+?)'",
    "replacement": "函数 '$1' 的存储类 'auto' 无效"
  },
  {
    "id": "storage class %<register%> invalid for function %qs",
    "pattern": "storage class 'register' invalid for function '(.+?)'",
    "replacement": "函数 '$1' 的存储类 'register' 无效"
  },
  {
    "id": "storage class %<__thread%> invalid for function %qs",
    "pattern": "storage class '__thread' invalid for function '(.+?)'",
    "replacement": "函数 '$1' 的存储类 '__thread' 无效"
  },
  {
    "id": "storage class %<thread_local%> invalid for function %qs",
    "pattern": "storage class 'thread_local' invalid for function '(.+?)'",
    "replacement": "函数 '$1' 的存储类 'thread_local' 无效"
  },
  {
    "id": "virt-specifiers in %qs not allowed outside a class definition",
    "pattern": "virt-specifiers in '(.+?)' not allowed outside a class definition",
    "replacement": "'$1' 中的虚说明符不允许出现在类外定义内"
  },
  {
    "id": "%<static%> specifier invalid for function %qs declared out of global scope",
    "pattern": "'static' specifier invalid for function '(.+?)' declared out of global scope",
    "replacement": "在全局作用域外为函数 '$1' 指定 'static' 说明符无效"
  },
  {
    "id": "%<inline%> specifier invalid for function %qs declared out of global scope",
    "pattern": "'inline' specifier invalid for function '(.+?)' declared out of global scope",
    "replacement": "在全局作用域外为函数 '$1' 指定 'inline' 说明符无效"
  },
  {
    "id": "virtual non-class function %qs",
    "pattern": "virtual non-class function '(.+?)'",
    "replacement": "虚的非类函数 '$1'"
  },
  {
    "id": "%qs defined in a non-class scope",
    "pattern": "'(.+?)' defined in a non-class scope",
    "replacement": "'$1' 定义在在非类作用域中"
  },
  {
    "id": "%qs declared in a non-class scope",
    "pattern": "'(.+?)' declared in a non-class scope",
    "replacement": "'(.+?)' 定义在在非类作用域中"
  },
  {
    "id": "cannot declare member function %qD to have static linkage",
    "pattern": "cannot declare member function '(.+?)' to have static linkage",
    "replacement": "不能将成员函数 '$1' 声明为具有静态连接"
  },
  {
    "id": "cannot declare static function inside another function",
    "pattern": "cannot declare static function inside another function",
    "replacement": "不能在另一个函数中声明静态函数"
  },
  {
    "id": "%<static%> may not be used when defining (as opposed to declaring) a static data member",
    "pattern": "'static' may not be used when defining (as opposed to declaring) a static data member",
    "replacement": "与声明不同，定义静态数据成员时不能使用 'static'"
  },
  {
    "id": "static member %qD declared %<register%>",
    "pattern": "static member '(.+?)' declared 'register'",
    "replacement": "静态成员 '$1' 被声明为 'register'"
  },
  {
    "id": "cannot explicitly declare member %q#D to have extern linkage",
    "pattern": "cannot explicitly declare member '(.+?)' to have extern linkage",
    "replacement": "不能显式地将成员 '$1' 声明为具有外部连接"
  },
  {
    "id": "declaration of %<constexpr%> variable %qD is not a definition",
    "pattern": "declaration of 'constexpr' variable '(.+?)' is not a definition",
    "replacement": "'constexpr' 变量 '$1' 的声明不是定义"
  },
  {
    "id": "a variable cannot be declared %<consteval%>",
    "pattern": "a variable cannot be declared 'consteval'",
    "replacement": "变量不能被声明为 'consteval'"
  },
  {
    "id": "declaration of %q#D has no initializer",
    "pattern": "declaration of '(.+?)' has no initializer",
    "replacement": "'$1' 的声明缺少初始化器"
  },
  {
    "id": "%qs initialized and declared %<extern%>",
    "pattern": "'(.+?)' initialized and declared 'extern'",
    "replacement": "'$1' 已初始化，且被声明为 'extern'"
  },
  {
    "id": "%qs has both %<extern%> and initializer",
    "pattern": "'(.+?)' has both 'extern' and initializer",
    "replacement": "'$1' 既有 'extern' 又有初始化器"
  },
  {
    "id": "default argument %qE uses %qD",
    "pattern": "default argument '(.+?)' uses '(.+?)'",
    "replacement": "默认实参 '$1' 使用了 '$2'"
  },
  {
    "id": "default argument %qE uses local variable %qD",
    "pattern": "default argument '(.+?)' uses local variable '(.+?)'",
    "replacement": "默认实参 '$1' 使用了局部变量 '$2'"
  },
  {
    "id": "invalid use of cv-qualified type %qT in parameter declaration",
    "pattern": "invalid use of cv-qualified type '(.+?)' in parameter declaration",
    "replacement": "形参声明中非法地使用了 cv-限定的类型"
  },
  {
    "id": "invalid use of type %<void%> in parameter declaration",
    "pattern": "invalid use of type 'void' in parameter declaration",
    "replacement": "模板声明中非法地使用了 'void' 类型"
  },
  {
    "id": "%<volatile%>-qualified parameter is deprecated",
    "pattern": "'volatile'-qualified parameter is deprecated",
    "replacement": "'volatile' 限定的形参被弃用"
  },
  {
    "id": "parameter %qD invalidly declared method type",
    "pattern": "parameter '(.+?)' invalidly declared method type",
    "replacement": "形参 '$1' 被非法地声明为具有方法类型"
  },
  {
    "id": "parameter %qD includes pointer to array of unknown bound %qT",
    "pattern": "parameter '(.+?)' includes pointer to array of unknown bound '(.+?)'",
    "replacement": "形参 '$1' 包含了指向未知边界数组 '$2' 的指针"
  },
  {
    "id": "parameter %qD includes reference to array of unknown bound %qT",
    "pattern": "parameter '(.+?)' includes reference to array of unknown bound '(.+?)'",
    "replacement": "形参 '$2' 包含了到未知边界数组 '$2' 的引用"
  },
  {
    "id": "invalid constructor; you probably meant %<%T (const %T&)%>",
    "pattern": "invalid constructor; you probably meant '(.+?) (const (.+?)&)'",
    "replacement": "无效的构造函数：你的意思可能是 '$1 (const $2&)'"
  },
  {
    "id": "%qD may not be declared within a namespace",
    "pattern": "'(.+?)' may not be declared within a namespace",
    "replacement": "'$1' 不能在命名空间内声明"
  },
  {
    "id": "%qD may not be declared as static",
    "pattern": "'(.+?)' may not be declared as static",
    "replacement": "'$1' 不能被声明为静态的"
  },
  {
    "id": "%qD must be a non-static member function",
    "pattern": "'(.+?)' must be a non-static member function",
    "replacement": "'$1' 必须是一个非静态的成员函数"
  },
  {
    "id": "%qD must be either a non-static member function or a non-member function",
    "pattern": "'(.+?)' must be either a non-static member function or a non-member function",
    "replacement": "'$1' 必须是一个非静态成员函数或非成员函数"
  },
  {
    "id": "%qD must have an argument of class or enumerated type",
    "pattern": "'(.+?)' must have an argument of class or enumerated type",
    "replacement": "'$1' 必须拥有类类型或枚举类型的实参"
  },
  {
    "id": "ISO C++ prohibits overloading %<operator ?:%>",
    "pattern": "ISO C\\+\\+ prohibits overloading 'operator ?:'",
    "replacement": "ISO C++ 不允许重载 'operator ?:'"
  },
  {
    "id": "%qD must not have variable number of arguments",
    "pattern": "'(.+?)' must not have variable number of arguments",
    "replacement": "'$1'不能带可变数量的实参"
  },
  {
    "id": "%qD must have either zero or one argument",
    "pattern": "'(.+?)' must have either zero or one argument",
    "replacement": "'$1' 必须带 0 或 1 个实参"
  },
  {
    "id": "%qD must have either one or two arguments",
    "pattern": "'(.+?)' must have either one or two arguments",
    "replacement": "'$1' 必须带 1 或 2 个实参"
  },
  {
    "id": "postfix %qD must have %<int%> as its argument",
    "pattern": "postfix '(.+?)' must have 'int' as its argument",
    "replacement": "后缀 '$1' 必须使用 'int' 作为它的实参"
  },
  {
    "id": "postfix %qD must have %<int%> as its second argument",
    "pattern": "postfix '(.+?)' must have 'int' as its second argument",
    "replacement": "后缀 '$1' 必须使用 'int' 作为它的第二个实参"
  },
  {
    "id": "%qD must have no arguments",
    "pattern": "'(.+?)' must have no arguments",
    "replacement": "'$1' 必须不带实参"
  },
  {
    "id": "%qD must have exactly one argument",
    "pattern": "'(.+?)' must have exactly one argument",
    "replacement": "'$1' 必须只带 1 个实参"
  },
  {
    "id": "%qD must have exactly two arguments",
    "pattern": "'(.+?)' must have exactly two arguments",
    "replacement": "'$1' 必须只带 2 个实参"
  },
  {
    "id": "%qD cannot have default arguments",
    "pattern": "'(.+?)' cannot have default arguments",
    "replacement": "'$1' 不能有默认实参"
  },
  {
    "id": "converting %qT to %<void%> will never use a type conversion operator",
    "pattern": "converting '(.+?)' to 'void' will never use a type conversion operator",
    "replacement": "从 '$1' 转换到 'void' 永远不会用到类型转换运算符"
  },
  {
    "id": "converting %qT to a reference to the same type will never use a type conversion operator",
    "pattern": "converting '(.+?)' to a reference to the same type will never use a type conversion operator",
    "replacement": "从 '$1' 转换到到相同类型的引用永远不会用到类型转换运算符"
  },
  {
    "id": "converting %qT to the same type will never use a type conversion operator",
    "pattern": "converting '(.+?)' to the same type will never use a type conversion operator",
    "replacement": "从 '$1' 转换到相同类型永远不会用到类型转换运算符"
  },
  {
    "id": "converting %qT to a reference to a base class %qT will never use a type conversion operator",
    "pattern": "converting '(.+?)' to a reference to a base class '(.+?)' will never use a type conversion operator",
    "replacement": "从 '$1' 转换到到基类 '$2' 的引用永远不会用到类型转换运算符"
  },
  {
    "id": "converting %qT to a base class %qT will never use a type conversion operator",
    "pattern": "converting '(.+?)' to a base class '(.+?)' will never use a type conversion operator",
    "replacement": "从 '$1' 转换到基类 '$2' 永远不会用到类型转换运算符"
  },
  {
    "id": "user-defined %qD always evaluates both arguments",
    "pattern": "user-defined '(.+?)' always evaluates both arguments",
    "replacement": "用户定义的 '$1' 总是计算所有两个实参"
  },
  {
    "id": "prefix %qD should return %qT",
    "pattern": "prefix '(.+?)' should return '(.+?)'",
    "replacement": "前缀 '$1' 应当返回 '$2'"
  },
  {
    "id": "postfix %qD should return %qT",
    "pattern": "postfix '(.+?)' should return '(.+?)'",
    "replacement": "后缀 '$1' 应当返回 '$2'"
  },
  {
    "id": "%qD should return by value",
    "pattern": "'(.+?)' should return by value",
    "replacement": "'$1' 应当以值的形式返回（而非引用的形式）"
  },
  {
    "id": "using template type parameter %qT after %qs",
    "pattern": "using template type parameter '(.+?)' after '(.+?)'",
    "replacement": "在 '$2' 后使用类型模板形参 '$1'"
  },
  {
    "id": "using alias template specialization %qT after %qs",
    "pattern": "using alias template specialization '(.+?)' after '(.+?)'",
    "replacement": "在 '$2' 后使用别名模板特化 '$1'"
  },
  {
    "id": "using typedef-name %qD after %qs",
    "pattern": "using typedef-name '(.+?)' after '(.+?)'",
    "replacement": "在 '$1' 后使用 typedef 名 '$1'"
  },
  {
    "id": "%qD has a previous declaration here",
    "pattern": "'(.+?)' has a previous declaration here",
    "replacement": "'$1' 之前在此声明"
  },
  {
    "id": "%qT referred to as %qs",
    "pattern": "'(.+?)' referred to as '(.+?)'",
    "replacement": "'$1' 作为 '$2' 使用"
  },
  {
    "id": "%qT referred to as enum",
    "pattern": "'(.+?)' referred to as enum",
    "replacement": "'$1' 作为枚举使用"
  },
  {
    "id": "template argument required for %<%s %T%>",
    "pattern": "template argument required for '(.*?) (.+?)'",
    "replacement": "'$1 $2' 需要模板实参"
  },
  {
    "id": "reference to %qD is ambiguous",
    "pattern": "reference to '(.+?)' is ambiguous",
    "replacement": "对 '$1' 的引用有歧义"
  },
  {
    "id": "%qD has the same name as the class in which it is declared",
    "pattern": "'(.+?)' has the same name as the class in which it is declared",
    "replacement": "'$1' 与其声明所在的类有相同的名字"
  },
  {
    "id": "%qT is not a template",
    "pattern": "'(.+?)' is not a template",
    "replacement": "'$1' 不是一个模板"
  },
  {
    "id": "perhaps you want to explicitly add %<%T::%>",
    "pattern": "perhaps you want to explicitly add '(.+?)::'",
    "replacement": "或许你想显式地添加 '$1::'"
  },
  {
    "id": "use of enum %q#D without previous declaration",
    "pattern": "use of enum '(.+?)' without previous declaration",
    "replacement": "使用枚举 '$1' 前没有给出声明"
  },
  {
    "id": "redeclaration of %qT as a non-template",
    "pattern": "redeclaration of '(.+?)' as a non-template",
    "replacement": "'$1' 重声明为非模板"
  },
  {
    "id": "cannot declare %qD in a different module",
    "pattern": "cannot declare '(.+?)' in a different module",
    "replacement": "不能在其他模块中声明 '$1'"
  },
  {
    "id": "derived union %qT invalid",
    "pattern": "derived union '(.+?)' invalid",
    "replacement": "派生联合体 '$1' 无效"
  },
  {
    "id": "%qT defined with multiple direct bases",
    "pattern": "'(.+?)' defined with multiple direct bases",
    "replacement": "'$1' 在多个直接基类中定义"
  },
  {
    "id": "%qT defined with direct virtual base",
    "pattern": "'(.+?)' defined with direct virtual base",
    "replacement": "'$1' 在多个直接虚基类中定义"
  },
  {
    "id": "base type %qT fails to be a struct or class type",
    "pattern": "base type '(.+?)' fails to be a struct or class type",
    "replacement": "基类型 '$1' 不是结构体或类类型"
  },
  {
    "id": "recursive type %qT undefined",
    "pattern": "recursive type '(.+?)' undefined",
    "replacement": "递归的类型 '$1' 未定义"
  },
  {
    "id": "duplicate base type %qT invalid",
    "pattern": "duplicate base type '(.+?)' invalid",
    "replacement": "重复的基类型 '$1' 无效"
  },
  {
    "id": "scoped/unscoped mismatch in enum %q#T",
    "pattern": "scoped/unscoped mismatch in enum '(.+?)'",
    "replacement": "枚举 '$1' 中有/无作用域不匹配"
  },
  {
    "id": "previous definition here",
    "pattern": "previous definition here",
    "replacement": "之前在此处定义"
  },
  {
    "id": "underlying type mismatch in enum %q#T",
    "pattern": "underlying type mismatch in enum '(.+?)'",
    "replacement": "枚举 '$1' 的底层类型不匹配"
  },
  {
    "id": "different underlying type in enum %q#T",
    "pattern": "different underlying type in enum '(.+?)'",
    "replacement": "枚举 '$1' 的底层类型不同"
  },
  {
    "id": "cannot define %qD in different module",
    "pattern": "cannot define '(.+?)' in different module",
    "replacement": "不能在不同模块中定义 '$1'"
  },
  {
    "id": "underlying type %qT of %qT must be an integral type",
    "pattern": "underlying type '(.+?)' of '(.+?)' must be an integral type",
    "replacement": "'$1' 的底层类型 '$2' 必须是整数类型"
  },
  {
    "id": "no integral type can represent all of the enumerator values for %qT",
    "pattern": "no integral type can represent all of the enumerator values for '(.+?)'",
    "replacement": "没有一个整数类型可以表示 '$1' 的所有枚举值"
  },
  {
    "id": "enumerator value for %qD must have integral or unscoped enumeration type",
    "pattern": "enumerator value for '(.+?)' must have integral or unscoped enumeration type",
    "replacement": "'$1' 的枚举值必须是整数或无作用域的枚举类型"
  },
  {
    "id": "enumerator value for %qD is not an integer constant",
    "pattern": "enumerator value for '(.+?)' is not an integer constant",
    "replacement": "'$1' 的枚举值不是整数常量"
  },
  {
    "id": "incremented enumerator value is too large for %<unsigned long%>",
    "pattern": "incremented enumerator value is too large for 'unsigned long'",
    "replacement": "自增枚举项的值对 'unsigned long' 类型而言太大"
  },
  {
    "id": "incremented enumerator value is too large for %<long%>",
    "pattern": "incremented enumerator value is too large for 'long'",
    "replacement": "自增枚举项的值对 'long' 类型而言太大"
  },
  {
    "id": "overflow in enumeration values at %qD",
    "pattern": "overflow in enumeration values at '(.+?)'",
    "replacement": "'$1' 中的枚举值溢出"
  },
  {
    "id": "enumerator value %qE is outside the range of underlying type %qT",
    "pattern": "enumerator value '(.+?)' is outside the range of underlying type '(.+?)'",
    "replacement": "枚举项值 '$1' 超过了其底层类型 '$2' 的范围"
  },
  {
    "id": "multiple definition of %q#T",
    "pattern": "multiple definition of '(.+?)'",
    "replacement": "'$1' 的多次定义"
  },
  {
    "id": "return type %q#T is incomplete",
    "pattern": "return type '(.+?)' is incomplete",
    "replacement": "返回类型 '$1' 是不完整类型"
  },
  {
    "id": "%<operator=%> should return a reference to %<*this%>",
    "pattern": "'operator=' should return a reference to '\\*this'",
    "replacement": "'operator=' 应当返回一个到 '\\*this' 的引用"
  },
  {
    "id": "no return statements in function returning %qT",
    "pattern": "no return statements in function returning '(.+?)'",
    "replacement": "在返回 '$1' 的函数中没有 return 语句"
  },
  {
    "id": "only plain %<auto%> return type can be deduced to %<void%>",
    "pattern": "only plain 'auto' return type can be deduced to 'void'",
    "replacement": "仅有单纯的 'auto' 返回类型可能被推导为 'void'"
  },
  {
    "id": "no return statement in %<constexpr%> function returning non-void",
    "pattern": "no return statement in 'constexpr' function returning non-void",
    "replacement": "不返回 void 的 'constexpr' 函数中没有 return 语句"
  },
  {
    "id": "%qD is already defined in class %qT",
    "pattern": "'(.+?)' is already defined in class '(.+?)'",
    "replacement": "'$1' 已在类 '$2' 中定义过"
  },
  {
    "id": "use of %qD before deduction of %<auto%>",
    "pattern": "use of '(.+?)' before deduction of 'auto'",
    "replacement": "在 'auto' 的推导前使用 '$1'"
  },
  {
    "id": "name missing for member function",
    "pattern": "name missing for member function",
    "replacement": "成员函数没有名字"
  },
  {
    "id": "ambiguous conversion for array subscript",
    "pattern": "ambiguous conversion for array subscript",
    "replacement": "对数组下标有歧义的转换"
  },
  {
    "id": "invalid types %<%T[%T]%> for array subscript",
    "pattern": "invalid types '(.+?)[(.+?)]' for array subscript",
    "replacement": "类型 '$1[$2]' 作为数组下标无效"
  },
  {
    "id": "deleting array %q#E",
    "pattern": "deleting array '(.+?)'",
    "replacement": "delete 数组 '$1' 中"
  },
  {
    "id": "type %q#T argument given to %<delete%>, expected pointer",
    "pattern": "type '(.+?)' argument given to 'delete', expected pointer",
    "replacement": "类型为 '$1' 的实参被传递给 'delete' ，期望应为一个指针"
  },
  {
    "id": "cannot delete a function.  Only pointer-to-objects are valid arguments to %<delete%>",
    "pattern": "cannot delete a function.  Only pointer-to-objects are valid arguments to 'delete'",
    "replacement": "不能 delete 一个函数。只有指向对象的指针才是 'delete' 的有效实参"
  },
  {
    "id": "deleting %qT is undefined",
    "pattern": "deleting '(.+?)' is undefined",
    "replacement": "delete '$1' 是未定义的"
  },
  {
    "id": "template declaration of %q#D",
    "pattern": "template declaration of '(.+?)'",
    "replacement": "'$1' 的模板声明"
  },
  {
    "id": "template parameter lists provided don%'t match the template parameters of %qD",
    "pattern": "template parameter lists provided don't match the template parameters of '(.+?)'",
    "replacement": "提供的模板形参列表与 '(.+?)' 的模板形参不符"
  },
  {
    "id": "destructor %qD declared as member template",
    "pattern": "destructor '(.+?)' declared as member template",
    "replacement": "析构函数 '$1' 被声明为一个成员模板"
  },
  {
    "id": "no declaration matches %q#D",
    "pattern": "no declaration matches '(.+?)'",
    "replacement": "没有声明匹配 '$1'"
  },
  {
    "id": "no conversion operators declared",
    "pattern": "no conversion operators declared",
    "replacement": "没有声明转换运算符"
  },
  {
    "id": "no functions named %qD",
    "pattern": "no functions named '(.+?)'",
    "replacement": "没有函数名为 '$1'"
  },
  {
    "id": "%#qT defined here",
    "pattern": "'(.+?)' defined here",
    "replacement": "'$1' 在此定义"
  },
  {
    "id": "local class %q#T shall not have static data member %q#D",
    "pattern": "local class '(.+?)' shall not have static data member '(.+?)'",
    "replacement": "局部类 '$1' 不应当拥有静态数据成员 '$2'"
  },
  {
    "id": "static data member %qD in unnamed class",
    "pattern": "static data member '(.+?)' in unnamed class",
    "replacement": "无名类中出现静态数据成员 '$1'"
  },
  {
    "id": "unnamed class defined here",
    "pattern": "unnamed class defined here",
    "replacement": "无名类在此定义"
  },
  {
    "id": "explicit template argument list not allowed",
    "pattern": "explicit template argument list not allowed",
    "replacement": "不允许显式模板实参列表"
  },
  {
    "id": "%qD is already defined in %qT",
    "pattern": "'(.+?)' is already defined in '(.+?)'",
    "replacement": "'$1' 已在 '$2' 中定义过"
  },
  {
    "id": "invalid initializer for member function %qD",
    "pattern": "invalid initializer for member function '(.+?)'",
    "replacement": "成员函数 '$1' 的初始化器无效"
  },
  {
    "id": "initializer specified for friend function %qD",
    "pattern": "initializer specified for friend function '(.+?)'",
    "replacement": "为友元函数 '$1' 指定了初始化器"
  },
  {
    "id": "initializer specified for static member function %qD",
    "pattern": "initializer specified for static member function '(.+?)'",
    "replacement": "为静态成员函数 '$1' 指定了初始化器"
  },
  {
    "id": "%<asm%> specifiers are not permitted on non-static data members",
    "pattern": "'asm' specifiers are not permitted on non-static data members",
    "replacement": "'asm' 说明符不允许用于非静态数据成员"
  },
  {
    "id": "cannot declare %qD to be a bit-field type",
    "pattern": "cannot declare '(.+?)' to be a bit-field type",
    "replacement": "不能将 '(.+?)' 声明为位域类型"
  },
  {
    "id": "cannot declare bit-field %qD with function type",
    "pattern": "cannot declare bit-field '(.+?)' with function type",
    "replacement": "不能将位域 '$1' 声明为函数类型"
  },
  {
    "id": "cannot declare bit-field %qD with %<warn_if_not_aligned%> type",
    "pattern": "cannot declare bit-field '(.+?)' with 'warn_if_not_aligned' type",
    "replacement": "不能将位域 '$1' 声明为 'warn_if_not_aligned' 类型"
  },
  {
    "id": "%qD is already defined in the class %qT",
    "pattern": "'(.+?)' is already defined in the class '(.+?)'",
    "replacement": "'$1' 已在类 '$2' 中定义过"
  },
  {
    "id": "static member %qD cannot be a bit-field",
    "pattern": "static member '(.+?)' cannot be a bit-field",
    "replacement": "静态成员 '$1' 不能是位域"
  },
  {
    "id": "width of bit-field %qD has non-integral type %qT",
    "pattern": "width of bit-field '(.+?)' has non-integral type '(.+?)'",
    "replacement": "位域 '$1' 的宽度具有非整数类型 '$2'"
  },
  {
    "id": "incomplete type %qT is not mappable",
    "pattern": "incomplete type '(.+?)' is not mappable",
    "replacement": "不完整类型 '$1' 不是可映射的"
  },
  {
    "id": "type %qT with virtual members is not mappable",
    "pattern": "type '(.+?)' with virtual members is not mappable",
    "replacement": "带有虚成员的类型 '$1' 不是可映射的"
  },
  {
    "id": "static field %qD is not mappable",
    "pattern": "static field '(.+?)' is not mappable",
    "replacement": "静态字段 '$1' 不是可映射的"
  },
  {
    "id": "%q+D static data member inside of declare target directive",
    "pattern": "'(.+?)' static data member inside of declare target directive",
    "replacement": "'$1' 静态数据成员出现在目标指令声明内"
  },
  {
    "id": "anonymous struct not inside named type",
    "pattern": "anonymous struct not inside named type",
    "replacement": "匿名结构体不在具名类型内"
  },
  {
    "id": "%q#D invalid; an anonymous union can only have non-static data members",
    "pattern": "'(.+?)' invalid; an anonymous union can only have non-static data members",
    "replacement": "'$1' 无效；匿名联合体只能拥有非静态数据成员"
  },
  {
    "id": "private member %q#D in anonymous union",
    "pattern": "private member '(.+?)' in anonymous union",
    "replacement": "匿名联合体中出现私有成员 '$1'"
  },
  {
    "id": "protected member %q#D in anonymous union",
    "pattern": "protected member '(.+?)' in anonymous union",
    "replacement": "匿名联合体中出现保护成员 '$1'"
  },
  {
    "id": "namespace-scope anonymous aggregates must be static",
    "pattern": "namespace-scope anonymous aggregates must be static",
    "replacement": "命名空间作用域的匿名聚合体必须是静态的"
  },
  {
    "id": "anonymous union with no members",
    "pattern": "anonymous union with no members",
    "replacement": "匿名联合体没有成员"
  },
  {
    "id": "%<operator new%> must return type %qT",
    "pattern": "'operator new' must return type '(.+?)'",
    "replacement": "'operator new' 必须返回 '$1' 类型"
  },
  {
    "id": "the first parameter of %<operator new%> cannot have a default argument",
    "pattern": "the first parameter of 'operator new' cannot have a default argument",
    "replacement": "'operator new' 的第一个形参不能有默认实参"
  },
  {
    "id": "%<operator new%> takes type %<size_t%> (%qT) as first parameter",
    "pattern": "'operator new' takes type 'size_t' \\('(.+?)'\\) as first parameter",
    "replacement": "'operator new' 的第一个形参类型为 'size_t' ('$1')"
  },
  {
    "id": "%<operator delete%> must return type %qT",
    "pattern": "'operator delete' must return type '(.+?)'",
    "replacement": "'operator delete' 必须返回 '$1' 类型"
  },
  {
    "id": "destroying %<operator delete%> must be a member function",
    "pattern": "destroying 'operator delete' must be a member function",
    "replacement": "销毁形式 'operator delete' 必须是成员函数"
  },
  {
    "id": "%<operator delete[]%> cannot be a destroying delete",
    "pattern": "'operator delete\\[\\]' cannot be a destroying delete",
    "replacement": "'operator delete[]' 不能是销毁形式 delete"
  },
  {
    "id": "destroying %<operator delete%> must be a usual deallocation function",
    "pattern": "destroying 'operator delete' must be a usual deallocation function",
    "replacement": "销毁形式 'operator delete' 必须是一个常规释放函数"
  },
  {
    "id": "%<operator delete%> takes type %qT as first parameter",
    "pattern": "'operator delete' takes type '(.+?)' as first parameter",
    "replacement": "'operator delete' 的首个形参类型为 '$1'"
  },
  {
    "id": "%qT has a field %qD whose type has no linkage",
    "pattern": "'(.+?)' has a field '(.+?)' whose type has no linkage",
    "replacement": "'$1' 有一个字段 '$2' 的类型是无连接的"
  },
  {
    "id": "%qT has a field %qD whose type depends on the type %qT which has no linkage",
    "pattern": "'(.+?)' has a field '(.+?)' whose type depends on the type '(.+?)' which has no linkage",
    "replacement": "'$1' 有一个字段 '$2' 的类型依赖于无连接的 '$3' 类型"
  },
  {
    "id": "%qT has a field %qD whose type uses the anonymous namespace",
    "pattern": "'(.+?)' has a field '(.+?)' whose type uses the anonymous namespace",
    "replacement": "'$1' 有一个字段 '$2' 的类型使用匿名命名空间"
  },
  {
    "id": "%qT declared with greater visibility than the type of its field %qD",
    "pattern": "'(.+?)' declared with greater visibility than the type of its field '(.+?)'",
    "replacement": "'$1' 被声明为比其字段 '$2' 的类型有更高的可见性"
  },
  {
    "id": "%qT has a base %qT whose type has no linkage",
    "pattern": "'(.+?)' has a base '(.+?)' whose type has no linkage",
    "replacement": "'$1' 有一个基类 '$2' 的类型是无连接的"
  },
  {
    "id": "%qT has a base %qT whose type depends on the type %qT which has no linkage",
    "pattern": "'(.+?)' has a base '(.+?)' whose type depends on the type '(.+?)' which has no linkage",
    "replacement": "'$1' 有一个基类 '$2' 的类型依赖于无连接的 '$3' 类型"
  },
  {
    "id": "%qT has a base %qT whose type uses the anonymous namespace",
    "pattern": "'(.+?)' has a base '(.+?)' whose type uses the anonymous namespace",
    "replacement": "'$1' 有一个基类 '$2' 的类型使用匿名命名空间"
  },
  {
    "id": "%qT declared with greater visibility than its base %qT",
    "pattern": "'(.+?)' declared with greater visibility than its base '(.+?)'",
    "replacement": "'$1' 被声明为比其基类 '$2' 的类型有更高的可见性"
  },
  {
    "id": "%q#D, declared using unnamed type, is used but never defined",
    "pattern": "'(.+?)', declared using unnamed type, is used but never defined",
    "replacement": "'$1' 声明为具有匿名类型，但在使用前未被定义"
  },
  {
    "id": "unnamed type with no linkage used to declare variable %q#D with linkage",
    "pattern": "unnamed type with no linkage used to declare variable '(.+?)' with linkage",
    "replacement": "无连接的匿名类型用于声明有连接的变量 '$1'"
  },
  {
    "id": "unnamed type with no linkage used to declare function %q#D with linkage",
    "pattern": "unnamed type with no linkage used to declare function '(.+?)' with linkage",
    "replacement": "无连接的匿名类型用于声明有连接的函数 '$1'"
  },
  {
    "id": "%q#D does not refer to the unqualified type, so it is not used for linkage",
    "pattern": "'(.+?)' does not refer to the unqualified type, so it is not used for linkage",
    "replacement": "'$1' 不指示非限定类型，所以它不被用作连接"
  },
  {
    "id": "%q#D, declared using local type %qT, is used but never defined",
    "pattern": "'(.+?)', declared using local type '(.+?)', is used but never defined",
    "replacement": "'$1' 声明为具有局部类型 '$2'，但在使用前未被定义"
  },
  {
    "id": "type %qT with no linkage used to declare variable %q#D with linkage",
    "pattern": "type '(.+?)' with no linkage used to declare variable '(.+?)' with linkage",
    "replacement": "无连接的 '$1' 类型用于声明有连接的变量 '$2'"
  },
  {
    "id": "type %qT with no linkage used to declare function %q#D with linkage",
    "pattern": "type '(.+?)' with no linkage used to declare function '(.+?)' with linkage",
    "replacement": "无连接的 '$1' 类型用于声明有连接的函数 '$2'"
  },
  {
    "id": "mangling of %q#D as %qE conflicts with a previous mangle",
    "pattern": "mangling of '(.+?)' as '(.+?)' conflicts with a previous mangle",
    "replacement": "'$1' 重整为 '$2' 与之前的重整出现冲突"
  },
  {
    "id": "previous mangling %q#D",
    "pattern": "previous mangling '(.+?)'",
    "replacement": "之前的重整 '$1'"
  },
  {
    "id": "a later %<-fabi-version=%> (or =0) avoids this error with a change in mangling",
    "pattern": "a later '-fabi-version=' (or =0) avoids this error with a change in mangling",
    "replacement": "一个后续的 '-fabi-version=4' (或 =0) 可以避免重整改变的错误"
  },
  {
    "id": "the program should also define %qD",
    "pattern": "the program should also define '(.+?)'",
    "replacement": "此程序还应当定义 '$1'"
  },
  {
    "id": "inline function %qD used but never defined",
    "pattern": "inline function '(.+?)' used but never defined",
    "replacement": "使用了内联函数 '$1' 但从未定义过"
  },
  {
    "id": "default argument missing for parameter %P of %q#D",
    "pattern": "default argument missing for parameter (.*?) of '(.+?)'",
    "replacement": "'$2' 的第 $1 个形参缺少默认实参"
  },
  {
    "id": "...following parameter %P which has a default argument",
    "pattern": "...following parameter (.*?) which has a default argument",
    "replacement": "...余下的第 $1 个形参拥有默认实参"
  },
  {
    "id": "implicitly-declared %qD is deprecated",
    "pattern": "implicitly-declared '(.+?)' is deprecated",
    "replacement": "隐式声明的 '$1' 被弃用"
  },
  {
    "id": "because %qT has user-provided %qD",
    "pattern": "because '(.+?)' has user-provided '(.+?)'",
    "replacement": "因为 '$1' 拥有用户定义的 '$2'"
  },
  {
    "id": "converting lambda that uses %<...%> to function pointer",
    "pattern": "converting lambda that uses '\\.\\.\\.' to function pointer",
    "replacement": "将使用了 '...' 的 lambda 转换为函数指针"
  },
  {
    "id": "use of deleted function %qD",
    "pattern": "use of deleted function '(.+?)'",
    "replacement": "使用了被删除的函数 '$1'"
  },
  {
    "id": "use of function %qD with unsatisfied constraints",
    "pattern": "use of function '(.+?)' with unsatisfied constraints",
    "replacement": "对函数 '$1' 的使用不满足约束"
  },
  {
    "id": "use of built-in parameter pack %qD outside of a template",
    "pattern": "use of built-in parameter pack '(.+?)' outside of a template",
    "replacement": "在模板外使用内建的形参包 '$1'"
  },
  {
    "id": "(no argument)",
    "pattern": "\\(no argument\\)",
    "replacement": "（没有实参）"
  },
  {
    "id": "extended initializer lists only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "extended initializer lists only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "扩展初始化器列表仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "explicit conversion operators only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "explicit conversion operators only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "显式转换运算符仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "variadic templates only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "variadic templates only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "变参模板仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "lambda expressions only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "lambda expressions only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "lambda 表达式仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "C++11 auto only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "C\\+\\+11 auto only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "C++11 auto 仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "scoped enums only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "scoped enums only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "有作用域的枚举仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "defaulted and deleted functions only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "defaulted and deleted functions only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "预置的和被删除的函数仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "inline namespaces only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "inline namespaces only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "内联命名空间仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "override controls (override/final) only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "override controls (override/final) only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "覆盖控制（override/final）仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "non-static data member initializers only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "non-static data member initializers only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "非静态数据成员初始化器仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "user-defined literals only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "user-defined literals only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "用户定义字面量仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "delegating constructors only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "delegating constructors only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "委托构造函数仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "inheriting constructors only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "inheriting constructors only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "继承构造函数仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "c++11 attributes only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "c\\+\\+11 attributes only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "c++11 特性仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "ref-qualifiers only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "ref-qualifiers only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "引用限定符仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "incomplete type %qT used in nested name specifier",
    "pattern": "incomplete type '(.+?)' used in nested name specifier",
    "replacement": "嵌套名指定中使用了不完整类型 '$1'"
  },
  {
    "id": "reference to %<%T::%D%> is ambiguous",
    "pattern": "reference to '(.+?)::(.+?)' is ambiguous",
    "replacement": "对 '$1::$2' 的引用有歧义"
  },
  {
    "id": "%qD is not a member of %qT; did you mean %qs?",
    "pattern": "'(.+?)' is not a member of '(.+?)'; did you mean '(.+?)'\\?",
    "replacement": "'$1' 没有名为 '$2' 的成员；你的意思是 '$3' 吗？"
  },
  {
    "id": "%qD is not a member of %qT",
    "pattern": "'(.+?)' is not a member of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的成员"
  },
  {
    "id": "%<::%D%> has not been declared; did you mean %qs?",
    "pattern": "'::(.+?)' has not been declared; did you mean '(.+?)'\\?",
    "replacement": "'::$1' 未被声明；你的意思是 '$2' 吗？"
  },
  {
    "id": "%<::%D%> has not been declared",
    "pattern": "'::(.+?)' has not been declared",
    "replacement": "'::$1' 未被声明"
  },
  {
    "id": "exception handling disabled, use %<-fexceptions%> to enable",
    "pattern": "exception handling disabled, use '-fexceptions' to enable",
    "replacement": "异常处理已被禁用，使用 '-fexceptions' 启用"
  },
  {
    "id": "throwing NULL, which has integral, not pointer type",
    "pattern": "throwing NULL, which has integral, not pointer type",
    "replacement": "抛出 NULL，它是整数类型而不是指针类型"
  },
  {
    "id": "  in thrown expression",
    "pattern": "  in thrown expression",
    "replacement": "  在抛出的表达式中"
  },
  {
    "id": "cannot declare %<catch%> parameter to be of rvalue reference type %qT",
    "pattern": "cannot declare 'catch' parameter to be of rvalue reference type '(.+?)'",
    "replacement": "不能将 'catch' 形参声明为右值引用类型 '$1'"
  },
  {
    "id": "cannot throw expression of type %qT because it involves types of variable size",
    "pattern": "cannot throw expression of type '(.+?)' because it involves types of variable size",
    "replacement": "不能抛出 '$1' 类型的表达式，因为它引入了大小可变的类型"
  },
  {
    "id": "cannot catch type %qT because it involves types of variable size",
    "pattern": "cannot catch type '(.+?)' because it involves types of variable size",
    "replacement": "无法捕捉类型 '$1'，因为它引入了大小可变的类型"
  },
  {
    "id": "exception of type %qT will be caught by earlier handler",
    "pattern": "exception of type '(.+?)' will be caught by earlier handler",
    "replacement": "类型为 '$1' 的异常将会被较早的处理代码捕捉"
  },
  {
    "id": "for type %qT",
    "pattern": "for type '(.+?)'",
    "replacement": "为类型 '$1'"
  },
  {
    "id": "%<...%> handler must be the last handler for its try block",
    "pattern": "'\\.\\.\\.' handler must be the last handler for its try block",
    "replacement": "'...' 处理代码必须是其 try 块中的最后一个处理代码"
  },
  {
    "id": "noexcept-expression evaluates to %<false%> because of a call to %qD",
    "pattern": "noexcept-expression evaluates to 'false' because of a call to '(.+?)'",
    "replacement": "noexcept 表达式求值为 'false'，因为调用了 '$1'"
  },
  {
    "id": "but %qD does not throw; perhaps it should be declared %<noexcept%>",
    "pattern": "but '(.+?)' does not throw; perhaps it should be declared 'noexcept'",
    "replacement": "但是 '$1' 不会抛出；或许它应该被声明 'noexcept'"
  },
  {
    "id": "using value of simple assignment with %<volatile%>-qualified left operand is deprecated",
    "pattern": "using value of simple assignment with 'volatile'-qualified left operand is deprecated",
    "replacement": "使用带 'volatile' 限定左操作数的简单赋值表达式的值被弃用"
  },
  {
    "id": "%qD is already a friend of class %qT",
    "pattern": "'(.+?)' is already a friend of class '(.+?)'",
    "replacement": "'$1' 已经是类 '$2' 的友元"
  },
  {
    "id": "invalid type %qT declared %<friend%>",
    "pattern": "invalid type '(.+?)' declared 'friend'",
    "replacement": "无效的类型 '$1' 被声明为'friend'"
  },
  {
    "id": "partial specialization %qT declared %<friend%>",
    "pattern": "partial specialization '(.+?)' declared 'friend'",
    "replacement": "偏特化模板 '$1' 声明为 'friend'"
  },
  {
    "id": "perhaps you need explicit template arguments in your nested-name-specifier",
    "pattern": "perhaps you need explicit template arguments in your nested-name-specifier",
    "replacement": "或许你需要在你的嵌套名说明符中显式指定模板实参"
  },
  {
    "id": "class %qT is implicitly friends with itself",
    "pattern": "class '(.+?)' is implicitly friends with itself",
    "replacement": "类 '$1' 隐式地成为其自身的友元"
  },
  {
    "id": "%qT is not a member of %qT",
    "pattern": "'(.+?)' is not a member of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的成员"
  },
  {
    "id": "%qT is not a member class template of %qT",
    "pattern": "'(.+?)' is not a member class template of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的成员类模板"
  },
  {
    "id": "%qT is not a nested class of %qT",
    "pattern": "'(.+?)' is not a nested class of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的嵌套类"
  },
  {
    "id": "template parameter type %qT declared %<friend%>",
    "pattern": "template parameter type '(.+?)' declared 'friend'",
    "replacement": "模板形参类型 '$1' 声明为 'friend'"
  },
  {
    "id": "%q#T is not a template",
    "pattern": "'(.+?)' is not a template",
    "replacement": "'$1' 不是一个模板"
  },
  {
    "id": "%qD is already a friend of %qT",
    "pattern": "'(.+?)' is already a friend of '(.+?)'",
    "replacement": "'$1' 已经是 '$2' 的友元"
  },
  {
    "id": "friend declaration %qD may not have virt-specifiers",
    "pattern": "friend declaration '(.+?)' may not have virt-specifiers",
    "replacement": "友元 '(.+?)' 的重声明不能有虚说明符"
  },
  {
    "id": "member %qD declared as friend before type %qT defined",
    "pattern": "member '(.+?)' declared as friend before type '(.+?)' defined",
    "replacement": "成员 '$1' 在类型 '$2' 被定义之前声明为友元"
  },
  {
    "id": "friend declaration %q#D declares a non-template function",
    "pattern": "friend declaration '(.+?)' declares a non-template function",
    "replacement": "友元声明 '$1' 声明了一个非模板函数"
  },
  {
    "id": "(if this is not what you intended, make sure the function template has already been declared and add %<<>%> after the function name here)",
    "pattern": "\\(if this is not what you intended, make sure the function template has already been declared and add '<>' after the function name here\\)",
    "replacement": "（如果这不是你的本意，请确定此函数模板已经被声明过，并在这里的函数名后面添加 '<>'）"
  },
  {
    "id": "value-initialization of incomplete type %qT",
    "pattern": "value-initialization of incomplete type '(.+?)'",
    "replacement": "不完整类型 '$1' 的值初始化"
  },
  {
    "id": "cannot value-initialize array of unknown bound %qT",
    "pattern": "cannot value-initialize array of unknown bound '(.+?)'",
    "replacement": "不能值初始化未知边界数组 '$1'"
  },
  {
    "id": "value-initialization of function type %qT",
    "pattern": "value-initialization of function type '(.+?)'",
    "replacement": "函数类型 '$1' 的值初始化"
  },
  {
    "id": "value-initialization of reference type %qT",
    "pattern": "value-initialization of reference type '(.+?)'",
    "replacement": "引用类型 '$1' 的值初始化"
  },
  {
    "id": "recursive instantiation of default member initializer for %qD",
    "pattern": "recursive instantiation of default member initializer for '(.+?)'",
    "replacement": "递归地实例化 '$1' 的默认成员初始化器"
  },
  {
    "id": "default member initializer for %qD required before the end of its enclosing class",
    "pattern": "default member initializer for '(.+?)' required before the end of its enclosing class",
    "replacement": "'$1' 的默认成员初始化器需要出现在其所属的类的后面"
  },
  {
    "id": "initializer for flexible array member %q#D",
    "pattern": "initializer for flexible array member '(.+?)'",
    "replacement": "柔型数组成员 '$1' 的初始化器"
  },
  {
    "id": "initializing %qD from %qE does not extend the lifetime of the underlying array",
    "pattern": "initializing '(.+?)' from '(.+?)' does not extend the lifetime of the underlying array",
    "replacement": "从 '$2' 初始化 '$1' 并不延长底层数组的生存期"
  },
  {
    "id": "%qD should be initialized in the member initialization list",
    "pattern": "'(.+?)' should be initialized in the member initialization list",
    "replacement": "'$1' 应该在成员初始化列表中被初始化"
  },
  {
    "id": "%qD is initialized with itself",
    "pattern": "'(.+?)' is initialized with itself",
    "replacement": "'$1' 被它自己初始化"
  },
  {
    "id": "invalid initializer for array member %q#D",
    "pattern": "invalid initializer for array member '(.+?)'",
    "replacement": "数组成员 '$1' 的初始化器无效"
  },
  {
    "id": "uninitialized const member in %q#T",
    "pattern": "uninitialized const member in '(.+?)'",
    "replacement": "'$1' 中存在未初始化的只读成员"
  },
  {
    "id": "%q#D should be initialized",
    "pattern": "'(.+?)' should be initialized",
    "replacement": "'$1' 应当被初始化"
  },
  {
    "id": "uninitialized reference member in %q#T",
    "pattern": "uninitialized reference member in '(.+?)'",
    "replacement": "'$1' 中存在未初始化的引用成员"
  },
  {
    "id": "%qD will be initialized after",
    "pattern": "'(.+?)' will be initialized after",
    "replacement": "'$1' 的初始化应发生在此后："
  },
  {
    "id": "base %qT will be initialized after",
    "pattern": "base '(.+?)' will be initialized after",
    "replacement": "基类 '$1' 的初始化应发生在此后："
  },
  {
    "id": "  base %qT",
    "pattern": "  base '(.+?)'",
    "replacement": "  基类'(.+?)'"
  },
  {
    "id": "  when initialized here",
    "pattern": "  when initialized here",
    "replacement": "  在此处被初始化时"
  },
  {
    "id": "multiple initializations given for %qD",
    "pattern": "multiple initializations given for '(.+?)'",
    "replacement": "为 '$1' 给定了多个初始化"
  },
  {
    "id": "multiple initializations given for base %qT",
    "pattern": "multiple initializations given for base '(.+?)'",
    "replacement": "为基类 '$1' 给定了多个初始化"
  },
  {
    "id": "initializations for multiple members of %qT",
    "pattern": "initializations for multiple members of '(.+?)'",
    "replacement": "初始化 '$1' 的多个成员"
  },
  {
    "id": "base class %q#T should be explicitly initialized in the copy constructor",
    "pattern": "base class '(.+?)' should be explicitly initialized in the copy constructor",
    "replacement": "基类 '$1' 应该在复制构造函数中显式地初始化"
  },
  {
    "id": "class %qT does not have any field named %qD",
    "pattern": "class '(.+?)' does not have any field named '(.+?)'",
    "replacement": "类 '$1' 没有名为 '$2' 的字段"
  },
  {
    "id": "%q#D is a static data member; it can only be initialized at its definition",
    "pattern": "'(.+?)' is a static data member; it can only be initialized at its definition",
    "replacement": "'$1' 是一个静态数据成员；它只能在定义时被初始化"
  },
  {
    "id": "%q#D is not a non-static data member of %qT",
    "pattern": "'(.+?)' is not a non-static data member of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的非静态数据成员"
  },
  {
    "id": "unnamed initializer for %qT, which has no base classes",
    "pattern": "unnamed initializer for '(.+?)', which has no base classes",
    "replacement": "没有基类的 '$1' 的无名初始化器"
  },
  {
    "id": "unnamed initializer for %qT, which uses multiple inheritance",
    "pattern": "unnamed initializer for '(.+?)', which uses multiple inheritance",
    "replacement": "使用了多重继承的 '$1' 的无名初始化器"
  },
  {
    "id": "%qD is both a direct base and an indirect virtual base",
    "pattern": "'(.+?)' is both a direct base and an indirect virtual base",
    "replacement": "'$1' 既是一个直接基类又是一个间接虚基类"
  },
  {
    "id": "type %qT is not a direct or virtual base of %qT",
    "pattern": "type '(.+?)' is not a direct or virtual base of '(.+?)'",
    "replacement": "类型 '$1' 不是 '$2' 的直接或虚基类"
  },
  {
    "id": "type %qT is not a direct base of %qT",
    "pattern": "type '(.+?)' is not a direct base of '(.+?)'",
    "replacement": "类型 '$1' 不是 '$2' 的直接基类"
  },
  {
    "id": "array must be initialized with a brace-enclosed initializer",
    "pattern": "array must be initialized with a brace-enclosed initializer",
    "replacement": "数组必须被一个由花括号围起的初始化器初始化"
  },
  {
    "id": "%qT is not a class type",
    "pattern": "'(.+?)' is not a class type",
    "replacement": "'$1' 不是一个类"
  },
  {
    "id": "incomplete type %qT does not have member %qD",
    "pattern": "incomplete type '(.+?)' does not have member '(.+?)'",
    "replacement": "不完整类型 '$1' 没有成员 '$2'"
  },
  {
    "id": "invalid pointer to bit-field %qD",
    "pattern": "invalid pointer to bit-field '(.+?)'",
    "replacement": "指向位域 '$1' 的指针无效"
  },
  {
    "id": "invalid use of non-static member function %qD",
    "pattern": "invalid use of non-static member function '(.+?)'",
    "replacement": "非法地使用了非静态成员函数 '$1'"
  },
  {
    "id": "invalid use of non-static data member %qD",
    "pattern": "invalid use of non-static data member '(.+?)'",
    "replacement": "非法地使用了非静态数据成员 '$1'"
  },
  {
    "id": "uninitialized reference member in %q#T using %<new%> without new-initializer",
    "pattern": "uninitialized reference member in '(.+?)' using 'new' without new-initializer",
    "replacement": "'$1' 中未初始化的引用成员使用 new 但没有 new 初始化器"
  },
  {
    "id": "uninitialized reference member in base %q#T of %q#T using %<new%> without new-initializer",
    "pattern": "uninitialized reference member in base '(.+?)' of '(.+?)' using 'new' without new-initializer",
    "replacement": "'$2' 的基类 '$1' 中未初始化的引用成员使用 new 但没有 new 初始化器"
  },
  {
    "id": "uninitialized reference member in base %q#T of %q#T",
    "pattern": "uninitialized reference member in base '(.+?)' of '(.+?)'",
    "replacement": "'$2' 的基类 '$1' 中未初始化的引用成员"
  },
  {
    "id": "uninitialized const member in %q#T using %<new%> without new-initializer",
    "pattern": "uninitialized const member in '(.+?)' using 'new' without new-initializer",
    "replacement": "'$1' 中未初始化的只读成员使用 new 但没有 new 初始化器"
  },
  {
    "id": "uninitialized const member in base %q#T of %q#T using %<new%> without new-initializer",
    "pattern": "uninitialized const member in base '(.+?)' of '(.+?)' using 'new' without new-initializer",
    "replacement": "'$2' 的基类 '$1' 中未初始化的只读成员使用 new 但没有 new 初始化器"
  },
  {
    "id": "uninitialized const member in base %q#T of %q#T",
    "pattern": "uninitialized const member in base '(.+?)' of '(.+?)'",
    "replacement": "'$2' 的基类 '$1' 中未初始化的只读成员"
  },
  {
    "id": "placement new constructing an object of type %<%T [%wu]%> and size %qwu in a region of type %qT and size %qwi",
    "pattern": "placement new constructing an object of type '(.+?) \\[(.*?)\\]' and size '(.+?)' in a region of type '(.+?)' and size '(.+?)'",
    "replacement": "在类型为 '$4'、大小为 '$5' 的区域上，布置 new 构造了类型为 '$1 [$2]'、大小为 '$3' 的对象"
  },
  {
    "id": "placement new constructing an object of type %<%T [%wu]%> and size %qwu in a region of type %qT and size at most %qwu",
    "pattern": "placement new constructing an object of type '(.+?) [(.*?)]' and size '(.+?)' in a region of type '(.+?)' and size at most '(.+?)'",
    "replacement": "在类型为 '$4'、大小最多为 '$5' 的区域上，布置 new 构造了类型为 '$1 [$2]'、大小为 '$3' 的对象"
  },
  {
    "id": "placement new constructing an array of objects of type %qT and size %qwu in a region of type %qT and size %qwi",
    "pattern": "placement new constructing an array of objects of type '(.+?)' and size '(.+?)' in a region of type '(.+?)' and size '(.+?)'",
    "replacement": "在类型为 '$4'、大小为 '$5' 的区域上，布置 new 构造了类型为 '$1'、大小为 '$3' 的对象的数组"
  },
  {
    "id": "placement new constructing an array of objects of type %qT and size %qwu in a region of type %qT and size at most %qwu",
    "pattern": "placement new constructing an array of objects of type '(.+?)' and size '(.+?)' in a region of type '(.+?)' and size at most '(.+?)'",
    "replacement": "在类型为 '$4'、大小最多为 '$5' 的区域上，布置 new 构造了类型为 '$1'、大小为 '$3' 的对象的数组"
  },
  {
    "id": "placement new constructing an object of type %qT and size %qwu in a region of type %qT and size %qwi",
    "pattern": "placement new constructing an object of type '(.+?)' and size '(.+?)' in a region of type '(.+?)' and size '(.+?)'",
    "replacement": "在类型为 '$4'、大小为 '$5' 的区域上，布置 new 构造了类型为 '$1'、大小为 '$3' 的对象"
  },
  {
    "id": "placement new constructing an object of type %qT and size %qwu in a region of type %qT and size at most %qwu",
    "pattern": "placement new constructing an object of type '(.+?)' and size '(.+?)' in a region of type '(.+?)' and size at most '(.+?)'",
    "replacement": "在类型为 '$4'、大小最多为 '$5' 的区域上，布置 new 构造了类型为 '$1'、大小为 '$3' 的对象"
  },
  {
    "id": "at offset %wi from %qD declared here",
    "pattern": "at offset (.*?) from '(.+?)' declared here",
    "replacement": "在 '$2' 的 $1 偏置处于此声明"
  },
  {
    "id": "at offset [%wi, %wi] from %qD declared here",
    "pattern": "at offset \\[(.*?), (.*?)\\] from '(.+?)' declared here",
    "replacement": "在 '$3' 的 [$1, $2] 偏置处于此声明"
  },
  {
    "id": "integer overflow in array size",
    "pattern": "integer overflow in array size",
    "replacement": "数组大小中整数溢出"
  },
  {
    "id": "array size in new-expression must be constant",
    "pattern": "array size in new-expression must be constant",
    "replacement": "new 表达式中的数组大小必须为常量"
  },
  {
    "id": "variably modified type not allowed in new-expression",
    "pattern": "variably modified type not allowed in new-expression",
    "replacement": "new 表达式中不允许可变修改类型"
  },
  {
    "id": "non-constant array new length must be specified directly, not by %<typedef%>",
    "pattern": "non-constant array new length must be specified directly, not by 'typedef'",
    "replacement": "非常量数组形式 new 的长度必须直接指明，而非通过 'typedef'"
  },
  {
    "id": "non-constant array new length must be specified without parentheses around the type-id",
    "pattern": "non-constant array new length must be specified without parentheses around the type-id",
    "replacement": "非常量数组形式 new 的长度必须直接指明，且类型标识没有括号围起"
  },
  {
    "id": "invalid type %<void%> for %<new%>",
    "pattern": "invalid type 'void' for 'new'",
    "replacement": "对 new 而言类型 'void' 无效"
  },
  {
    "id": "%<new%> of %<initializer_list%> does not extend the lifetime of the underlying array",
    "pattern": "'new' of 'initializer_list' does not extend the lifetime of the underlying array",
    "replacement": "'initializer_list' 的 'new' 并不延长底层数组的生命期"
  },
  {
    "id": "uninitialized const in %<new%> of %q#T",
    "pattern": "uninitialized const in 'new' of '(.+?)'",
    "replacement": "'$1' 的 'new' 中出现未初始化的 const"
  },
  {
    "id": "no suitable %qD found in class %qT",
    "pattern": "no suitable '(.+?)' found in class '(.+?)'",
    "replacement": "在类 '$2' 中找不到合适的 '$1'"
  },
  {
    "id": "request for member %qD is ambiguous",
    "pattern": "request for member '(.+?)' is ambiguous",
    "replacement": "对成员 '$1' 的请求有歧义"
  },
  {
    "id": "%<new%> of type %qT with extended alignment %d",
    "pattern": "'new' of type '(.+?)' with extended alignment (\\d+)",
    "replacement": "类型 '$1' 的 'new' 带有额外对齐 $2"
  },
  {
    "id": "uses %qD, which does not have an alignment parameter",
    "pattern": "uses '(.+?)', which does not have an alignment parameter",
    "replacement": "使用 '$1'，其没有对齐实参"
  },
  {
    "id": "use %<-faligned-new%> to enable C++17 over-aligned new support",
    "pattern": "use '-faligned-new' to enable C\\+\\+17 over-aligned new support",
    "replacement": "使用 '-faligned-new' 来启用 C++17 中的过对齐 new 支持"
  },
  {
    "id": "parenthesized initializer in array new",
    "pattern": "parenthesized initializer in array new",
    "replacement": "数组形式 new 中出现括号初始化器"
  },
  {
    "id": "size in array new must have integral type",
    "pattern": "size in array new must have integral type",
    "replacement": "数组形式 new 中的大小必须为整数类型"
  },
  {
    "id": "new cannot be applied to a reference type",
    "pattern": "new cannot be applied to a reference type",
    "replacement": "new 不能应用于引用类型"
  },
  {
    "id": "new cannot be applied to a function type",
    "pattern": "new cannot be applied to a function type",
    "replacement": "new 不能应用于函数类型"
  },
  {
    "id": "possible problem detected in invocation of operator %<delete []%>",
    "pattern": "possible problem detected in invocation of operator 'delete \\[\\]'",
    "replacement": "检测到调用 'delete []' 运算符中可能出现的问题"
  },
  {
    "id": "neither the destructor nor the class-specific operator %<delete []%> will be called, even if they are declared when the class is defined",
    "pattern": "neither the destructor nor the class-specific operator 'delete \\[\\]' will be called, even if they are declared when the class is defined",
    "replacement": "析构函数和类特定的 'delete []' 运算符均不会被调用，即使它们在类定义时已经声明"
  },
  {
    "id": "initializer ends prematurely",
    "pattern": "initializer ends prematurely",
    "replacement": "初始化器过早地结束"
  },
  {
    "id": "unknown array size in delete",
    "pattern": "unknown array size in delete",
    "replacement": "delete 时数组大小未知"
  },
  {
    "id": "possible problem detected in invocation of %<operator delete%>",
    "pattern": "possible problem detected in invocation of 'operator delete'",
    "replacement": "检测到调用 'operator delete' 时可能出现的问题"
  },
  {
    "id": "neither the destructor nor the class-specific %<operator delete%> will be called, even if they are declared when the class is defined",
    "pattern": "neither the destructor nor the class-specific 'operator delete' will be called, even if they are declared when the class is defined",
    "replacement": "析构函数和类特定的 'operator delete' 均不会被调用，即使它们在类定义时已经声明"
  },
  {
    "id": "deleting object of abstract class type %qT which has non-virtual destructor will cause undefined behavior",
    "pattern": "deleting object of abstract class type '(.+?)' which has non-virtual destructor will cause undefined behavior",
    "replacement": "delete 拥有非平凡析构函数的抽象类类型 '$1' 的对象将造成未定义行为"
  },
  {
    "id": "deleting object of polymorphic class type %qT which has non-virtual destructor might cause undefined behavior",
    "pattern": "deleting object of polymorphic class type '(.+?)' which has non-virtual destructor might cause undefined behavior",
    "replacement": "delete 拥有非平凡析构函数的多态类类型 '$1' 的对象将造成未定义行为"
  },
  {
    "id": "type to vector delete is neither pointer or array type",
    "pattern": "type to vector delete is neither pointer or array type",
    "replacement": "向量 delete 的实参类型既非指针也非数组"
  },
  {
    "id": "array of runtime bound cannot be captured by copy, only by reference",
    "pattern": "array of runtime bound cannot be captured by copy, only by reference",
    "replacement": "数组的运行时边界既不能通过复制捕获，也不能通过引用捕获"
  },
  {
    "id": "capture of variably-modified type %qT that is not an N3639 array of runtime bound",
    "pattern": "capture of variably-modified type '(.+?)' that is not an N3639 array of runtime bound",
    "replacement": "对可变修改类型 '$1' 的捕获不是 N3639 数组运行时边界"
  },
  {
    "id": "because the array element type %qT has variable size",
    "pattern": "because the array element type '(.+?)' has variable size",
    "replacement": "因为数组元素类型 '$1' 拥有可变大小"
  },
  {
    "id": "cannot capture %qE by reference",
    "pattern": "cannot capture '(.+?)' by reference",
    "replacement": "无法通过引用捕获 '$1'"
  },
  {
    "id": "capture by copy of incomplete type %qT",
    "pattern": "capture by copy of incomplete type '(.+?)'",
    "replacement": "复制捕获了不完整类型 '$1'"
  },
  {
    "id": "trying to capture %qD in instantiation of generic lambda",
    "pattern": "trying to capture '(.+?)' in instantiation of generic lambda",
    "replacement": "试图在泛型 lambda 的实例化中捕获 '$1'"
  },
  {
    "id": "implicit capture of %qE via %<[=]%> is deprecated in C++20",
    "pattern": "implicit capture of '(.+?)' via '\\[=\\]' is deprecated in C\\+\\+20",
    "replacement": "通过 '[=]' 隐式捕获 '$1' 在 C++20 中被弃用"
  },
  {
    "id": "add explicit %<this%> or %<*this%> capture",
    "pattern": "add explicit 'this' or '*this' capture",
    "replacement": "添加显式的 'this' 或 '*this' 捕获"
  },
  {
    "id": "%<this%> was not captured for this lambda function",
    "pattern": "'this' was not captured for this lambda function",
    "replacement": "lambda 函数中未捕获 'this'"
  },
  {
    "id": "invalid %<#pragma %s%>",
    "pattern": "invalid '#pragma (.*?)'",
    "replacement": "无效的 '#pragma $1'"
  },
  {
    "id": "%<#pragma vtable%> no longer supported",
    "pattern": "'#pragma vtable' no longer supported",
    "replacement": "'#pragma vtable' 不再受支持"
  },
  {
    "id": "%<#pragma implementation%> for %qs appears after file is included",
    "pattern": "'#pragma implementation' for '(.+?)' appears after file is included",
    "replacement": "文件在 '$1' 的 '#pragma implementation' 出现前已被包含"
  },
  {
    "id": "%qD not defined",
    "pattern": "'(.+?)' not defined",
    "replacement": "'$1' 未定义"
  },
  {
    "id": "%qD was not declared in this scope; did you mean %qs?",
    "pattern": "'(.+?)' was not declared in this scope; did you mean '(.+?)'\\?",
    "replacement": "'$1' 未在此作用域中声明；你的意思是 '$2' 吗？"
  },
  {
    "id": "%qD was not declared in this scope",
    "pattern": "'(.+?)' was not declared in this scope",
    "replacement": "'$1' 未在此作用域中声明"
  },
  {
    "id": "there are no arguments to %qD that depend on a template parameter, so a declaration of %qD must be available",
    "pattern": "there are no arguments to '(.+?)' that depend on a template parameter, so a declaration of '(.+?)' must be available",
    "replacement": "'$1' 的实参都不依赖于模板形参，所以 '$2' 的声明必须可用"
  },
  {
    "id": "(if you use %<-fpermissive%>, G++ will accept your code, but allowing the use of an undeclared name is deprecated)",
    "pattern": "\\(if you use '-fpermissive', G\\+\\+ will accept your code, but allowing the use of an undeclared name is deprecated\\)",
    "replacement": "（如果您使用'-fpermissive'，G++ 会接受您的代码，但是允许使用未定义名称是已弃用的）"
  },
  {
    "id": "mangling %<typeof%>, use %<decltype%> instead",
    "pattern": "mangling 'typeof', use 'decltype' instead",
    "replacement": "重整 'typeof'，请用 'decltype' 代替"
  },
  {
    "id": "mangling %<__underlying_type%>",
    "pattern": "mangling '__underlying_type'",
    "replacement": "重整 '__underlying_type'"
  },
  {
    "id": "mangling unknown fixed point type",
    "pattern": "mangling unknown fixed point type",
    "replacement": "重整未知定点类型"
  },
  {
    "id": "use of built-in trait %qE in function signature; use library traits instead",
    "pattern": "use of built-in trait '(.+?)' in function signature; use library traits instead",
    "replacement": "在函数签名中使用内建特征 '$1'；使用库特征代替"
  },
  {
    "id": "mangling %C",
    "pattern": "mangling",
    "replacement": "重整"
  },
  {
    "id": "omitted middle operand to %<?:%> operand cannot be mangled",
    "pattern": "omitted middle operand to '?:' operand cannot be mangled",
    "replacement": "省略的 '?:' 中间操作数不能被重整"
  },
  {
    "id": "mangled name for %qD will change in C++17 because the exception specification is part of a function type",
    "pattern": "mangled name for '(.+?)' will change in C\\+\\+17 because the exception specification is part of a function type",
    "replacement": "'$1' 的重整名字会在 C++17 中改变，因为异常说明将是函数类型的一部分"
  },
  {
    "id": "the mangled name of %qD changed between %<%s=%d%> (%qD) and %<%s=%d%> (%qD)",
    "pattern": "the mangled name of '(.+?)' changed between '(.*?)=(\\d+)' \\('(.+?)'\\) and '(.*?)=(\\d+)' \\('(.+?)'\\)",
    "replacement": " '$2=$3' ('$4') 和 '$5=$6' ('$7') 之间，'$1' 的重整名字发生改变"
  },
  {
    "id": "the mangled name of a thunk for %qD changes between %<-fabi-version=%d%> and %<-fabi-version=%d%>",
    "pattern": "the mangled name of a thunk for '(.+?)' changes between '-fabi-version=(\\d+)' and '-fabi-version=(\\d+)'",
    "replacement": "'-fabi-version=$2' 和 '-fabi-version=$3' 之间，'$1' 的一个 thunk 的重整名字发生改变"
  },
  {
    "id": "the mangled name of %qD changes between %<-fabi-version=%d%> and %<-fabi-version=%d%>",
    "pattern": "the mangled name of '(.+?)' changes between '-fabi-version=(\\d+)' and '-fabi-version=(\\d+)'",
    "replacement": "'-fabi-version=$2' 和 '-fabi-version=$3' 之间，'$1' 的重整名字发生改变"
  },
  {
    "id": "the mangled name of the initialization guard variable for %qD changes between %<-fabi-version=%d%> and %<-fabi-version=%d%>",
    "pattern": "the mangled name of the initialization guard variable for '(.+?)' changes between '-fabi-version=(\\d+)' and '-fabi-version=(\\d+)'",
    "replacement": "'-fabi-version=$2' 和 '-fabi-version=$3' 之间，'$1' 的初始管控变量的重整名字发生改变"
  },
  {
    "id": "non-static const member %q#D, cannot use default assignment operator",
    "pattern": "non-static const member '(.+?)', cannot use default assignment operator",
    "replacement": "非静态的只读成员 '$1'，不能使用预置的赋值运算符"
  },
  {
    "id": "non-static reference member %q#D, cannot use default assignment operator",
    "pattern": "non-static reference member '(.+?)', cannot use default assignment operator",
    "replacement": "非静态的引用成员 '$1'，不能使用预置的赋值运算符"
  },
  {
    "id": "%qD is not a static data member",
    "pattern": "'(.+?)' is not a static data member",
    "replacement": "'$1' 不是静态数据成员"
  },
  {
    "id": "determining value of %qs",
    "pattern": "determining value of '(.+?)'",
    "replacement": "确定 '$1' 的值"
  },
  {
    "id": "forming type of %qs",
    "pattern": "forming type of '(.+?)'",
    "replacement": "形成 '$1' 的类型"
  },
  {
    "id": "defaulted %qD only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "defaulted '(.+?)' only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "预置的 '$1' 仅在 '-std=c++20' 或 'std=gnu++20' 下可用"
  },
  {
    "id": "defaulted %qD must return %<bool%>",
    "pattern": "defaulted '(.+?)' must return 'bool'",
    "replacement": "预置的 '$1' 必须返回 'bool'"
  },
  {
    "id": "defaulted %qD must be %<const%>",
    "pattern": "defaulted '(.+?)' must be 'const'",
    "replacement": "预置的 '$1' 必须为 'const'"
  },
  {
    "id": "defaulted %qD must not have %<&&%> ref-qualifier",
    "pattern": "defaulted '(.+?)' must not have '&&' ref-qualifier",
    "replacement": "预置的 '$1' 不能有 '&&' 引用限定符"
  },
  {
    "id": "defaulted %qD is not a friend of %qT",
    "pattern": "defaulted '(.+?)' is not a friend of '(.+?)'",
    "replacement": "预置的 '$1' 不是 '$2' 的友元"
  },
  {
    "id": "defaulted member %qD must have parameter type %<const %T&%>",
    "pattern": "defaulted member '(.+?)' must have parameter type 'const (.+?)&'",
    "replacement": "预置成员 '$1' 的形参类型必须为 'const $2&'"
  },
  {
    "id": "defaulted %qD must have parameters of either type %<const %T&%> or %qT",
    "pattern": "defaulted '(.+?)' must have parameters of either type 'const (.+?)&' or '(.+?)'",
    "replacement": "预置的 '$1' 的形参类型必须为 'const $2&' 或 '$2'"
  },
  {
    "id": "defaulted %qD must have parameters of either type %<const %T&%> or %qT, not both",
    "pattern": "defaulted '(.+?)' must have parameters of either type 'const (.+?)&' or '(.+?)', not both",
    "replacement": "预置的 '$1' 的形参类型要么是 'const $2&'，要么是 '$2'，不能同时是"
  },
  {
    "id": "cannot default compare union %qT",
    "pattern": "cannot default compare union '(.+?)'",
    "replacement": "不能预置联合体 '$1' 的比较"
  },
  {
    "id": "cannot default compare reference member %qD",
    "pattern": "cannot default compare reference member '(.+?)'",
    "replacement": "不能预置引用成员 '$1' 的比较"
  },
  {
    "id": "cannot default compare anonymous union member",
    "pattern": "cannot default compare anonymous union member",
    "replacement": "不能预置匿名联合体成员的比较"
  },
  {
    "id": "cannot default compare flexible array member",
    "pattern": "cannot default compare flexible array member",
    "replacement": "不能预置柔性数组成员的比较"
  },
  {
    "id": "changing the return type from %qs to a comparison category type will allow the comparison to use %qs and %qs",
    "pattern": "changing the return type from '(.+?)' to a comparison category type will allow the comparison to use '(.+?)' and '(.+?)'",
    "replacement": "从 '$1' 的返回类型到比较类别类型的转换会允许使用 '$2' 和 '$3' 的转换"
  },
  {
    "id": "three-way comparison of %qD has type %qT, not a comparison category type",
    "pattern": "three-way comparison of '(.+?)' has type '(.+?)', not a comparison category type",
    "replacement": "'$1' 的三路比较拥有类型 '$2'，它不是一个比较类别类型"
  },
  {
    "id": "three-way comparison of %qD has type %qT, which does not convert to %qT",
    "pattern": "three-way comparison of '(.+?)' has type '(.+?)', which does not convert to '(.+?)'",
    "replacement": "'$1' 的三路比较拥有类型 '$2'，而后者不能转换到 '$3'"
  },
  {
    "id": "synthesized method %qD first required here",
    "pattern": "synthesized method '(.+?)' first required here",
    "replacement": "同步方法 '$1' 第一次在此处需要"
  },
  {
    "id": "union member %q+D with non-trivial %qD",
    "pattern": "union member '(.+?)' with non-trivial '(.+?)'",
    "replacement": "联合体成员 '$1' 具有非平凡的 '$2'"
  },
  {
    "id": "defaulted destructor calls non-%<constexpr%> %qD",
    "pattern": "defaulted destructor calls non-'constexpr' '(.+?)'",
    "replacement": "预置的析构函数调用了非 'constexpr' '$1'"
  },
  {
    "id": "defaulted constructor calls non-%<constexpr%> %qD",
    "pattern": "defaulted constructor calls non-'constexpr' '(.+?)'",
    "replacement": "预置的构造函数调用了非 'constexpr' '$1'"
  },
  {
    "id": "initializer for %q#D is invalid",
    "pattern": "initializer for '(.+?)' is invalid",
    "replacement": "'$1' 的初始化器无效"
  },
  {
    "id": "defaulted default constructor does not initialize %q#D",
    "pattern": "defaulted default constructor does not initialize '(.+?)'",
    "replacement": "预置的默认构造函数并不初始化 '$1'"
  },
  {
    "id": "copying non-static data member %q#D of rvalue reference type",
    "pattern": "copying non-static data member '(.+?)' of rvalue reference type",
    "replacement": "复制具有右值引用类型的非静态数据成员 '$1'"
  },
  {
    "id": "defaulted default constructor does not initialize any non-static data member",
    "pattern": "defaulted default constructor does not initialize any non-static data member",
    "replacement": "预置的默认构造函数并不初始化任何非静态数据成员"
  },
  {
    "id": "defaulted move assignment for %qT calls a non-trivial move assignment operator for virtual base %qT",
    "pattern": "defaulted move assignment for '(.+?)' calls a non-trivial move assignment operator for virtual base '(.+?)'",
    "replacement": "'$1' 预置的移动赋值调用了虚基类 '$2' 的非平凡移动赋值运算符"
  },
  {
    "id": "a lambda closure type has a deleted default constructor",
    "pattern": "a lambda closure type has a deleted default constructor",
    "replacement": "lambda 闭包类型的默认构造函数被删除"
  },
  {
    "id": "a lambda closure type has a deleted copy assignment operator",
    "pattern": "a lambda closure type has a deleted copy assignment operator",
    "replacement": "lambda 闭包类型的复制赋值运算符被删除"
  },
  {
    "id": "%q#D is implicitly declared as deleted because %qT declares a move constructor or move assignment operator",
    "pattern": "'(.+?)' is implicitly declared as deleted because '(.+?)' declares a move constructor or move assignment operator",
    "replacement": "'$1' 隐式声明为被删除的，因为 '$2' 声明了移动构造函数或移动赋值运算符"
  },
  {
    "id": "%q#D inherits from multiple base subobjects",
    "pattern": "'(.+?)' inherits from multiple base subobjects",
    "replacement": "'$1' 从多个基类子对象中继承"
  },
  {
    "id": "%q#D is implicitly deleted because the default definition would be ill-formed:",
    "pattern": "'(.+?)' is implicitly deleted because the default definition would be ill-formed:",
    "replacement": "'$1' 被隐式删除，因为其预置定义不是良构的："
  },
  {
    "id": "%q#F is implicitly deleted because its exception-specification does not match the implicit exception-specification %qX",
    "pattern": "'(.+?)' is implicitly deleted because its exception-specification does not match the implicit exception-specification '(.+?)'",
    "replacement": "'$1' 被隐式删除，因为其异常说明与隐式异常说明 '$2' 不匹配"
  },
  {
    "id": "defaulted declaration %q+D does not match the expected signature",
    "pattern": "defaulted declaration '(.+?)' does not match the expected signature",
    "replacement": "预置的声明 '$1' 不匹配异常签名"
  },
  {
    "id": "expected signature: %qD",
    "pattern": "expected signature: '(.+?)'",
    "replacement": "期望的签名：'$1'"
  },
  {
    "id": "explicitly defaulted function %q+D cannot be declared %qs because the implicit declaration is not %qs:",
    "pattern": "explicitly defaulted function '(.+?)' cannot be declared '(.+?)' because the implicit declaration is not '(.+?)':",
    "replacement": "显式预置的函数 '$1' 不能声明为 '$2'，因为其隐式声明不是 '$3'："
  },
  {
    "id": "a template cannot be defaulted",
    "pattern": "a template cannot be defaulted",
    "replacement": "模板不能被预置"
  },
  {
    "id": "%qD cannot be defaulted",
    "pattern": "'(.+?)' cannot be defaulted",
    "replacement": "'$1' 不能被预置"
  },
  {
    "id": "defaulted function %q+D with default argument",
    "pattern": "defaulted function %q+D with default argument",
    "replacement": "预置的函数 '$1' 拥有默认实参"
  },
  {
    "id": "redeclaration of %q#D with different template parameters",
    "pattern": "redeclaration of '(.+?)' with different template parameters",
    "replacement": "'$1' 的重声明带有不同的模板形参"
  },
  {
    "id": "%q#D conflicts with a previous declaration",
    "pattern": "'(.+?)' conflicts with a previous declaration",
    "replacement": "'$1' 与之前的声明冲突"
  },
  {
    "id": "%q#D hides constructor for %q#D",
    "pattern": "'(.+?)' hides constructor for '(.+?)'",
    "replacement": "'$1' 隐藏了 '$2' 的构造函数"
  },
  {
    "id": "conflicting C language linkage declaration %q#D",
    "pattern": "conflicting C language linkage declaration '(.+?)'",
    "replacement": "冲突的 C 语言连接声明 '$1'"
  },
  {
    "id": "due to different exception specifications",
    "pattern": "due to different exception specifications",
    "replacement": "因为异常说明不一致"
  },
  {
    "id": "lambda parameter %qD previously declared as a capture",
    "pattern": "lambda parameter '(.+?)' previously declared as a capture",
    "replacement": "lambda 形参 '$1' 之前声明为捕获"
  },
  {
    "id": "declaration of %q#D shadows a parameter",
    "pattern": "declaration of '(.+?)' shadows a parameter",
    "replacement": "'$1' 的声明隐藏了一个形参"
  },
  {
    "id": "declaration of %qD shadows a member of %qT",
    "pattern": "declaration of '(.+?)' shadows a member of '(.+?)'",
    "replacement": "'$1' 的声明隐藏了 '$2' 的一个成员"
  },
  {
    "id": "friend declaration %qD in local class without prior local declaration",
    "pattern": "friend declaration '(.+?)' in local class without prior local declaration",
    "replacement": "局部类中的友元声明 '$1' 没有先前的局部声明"
  },
  {
    "id": "%q#D does not have external linkage",
    "pattern": "'(.+?)' does not have external linkage",
    "replacement": "'$1' 没有外部连接"
  },
  {
    "id": "%q#D declared here",
    "pattern": "'(.+?)' declared here",
    "replacement": "'$1' 在此声明"
  },
  {
    "id": "%<%T%s%D%> names destructor",
    "pattern": "'(.+?)' names destructor",
    "replacement": "'$1' 指名了析构函数"
  },
  {
    "id": "using-declaration for non-member at class scope",
    "pattern": "using-declaration for non-member at class scope",
    "replacement": "类作用域中出现非成员的 using 声明"
  },
  {
    "id": "%<using%> with enumeration scope %q#T only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "'using' with enumeration scope '(.+?)' only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "枚举作用域 '$1' 的 'using' 仅在 '-std=c++20' 或 'std=gnu++20' 下可用"
  },
  {
    "id": "%qT is not a class, namespace, or enumeration",
    "pattern": "'(.+?)' is not a class, namespace, or enumeration",
    "replacement": "'$1' 不是一个类、命名空间或枚举"
  },
  {
    "id": "non-member using-declaration names constructor of %qT",
    "pattern": "non-member using-declaration names constructor of '(.+?)'",
    "replacement": "非成员的 using 声明指名了 '$1' 的构造函数"
  },
  {
    "id": "using-declaration for member at non-class scope",
    "pattern": "using-declaration for member at non-class scope",
    "replacement": "非类作用域中出现成员的 using 声明"
  },
  {
    "id": "%qT is not a direct base of %qT",
    "pattern": "'(.+?)' is not a direct base of '(.+?)'",
    "replacement": "类型 '$1' 不是 '$2' 的直接基类"
  },
  {
    "id": "did you mean %<using enum %T::%D%>?",
    "pattern": "did you mean 'using enum (.+?)::(.+?)'\\?",
    "replacement": "你的意思是 'using enum $1::$2' 吗？"
  },
  {
    "id": "%qD has not been declared in %qD",
    "pattern": "'(.+?)' has not been declared in '(.+?)'",
    "replacement": "'$1' 未在 '$2' 中声明"
  },
  {
    "id": "using-declaration may not name namespace %qD",
    "pattern": "using-declaration may not name namespace '(.+?)'",
    "replacement": "using 声明不能指名命名空间 '$1'"
  },
  {
    "id": "%<%T::%D%> names constructor in %qT",
    "pattern": "'(.+?)::(.+?)' names constructor in '(.+?)'",
    "replacement": "'$1::$2' 指名了 '$3' 中的构造函数"
  },
  {
    "id": "declaration of %qD not in a namespace surrounding %qD",
    "pattern": "declaration of '(.+?)' not in a namespace surrounding '(.+?)'",
    "replacement": "'$1' 的声明不在包含 '$2' 的命名空间中"
  },
  {
    "id": "explicit qualification in declaration of %qD",
    "pattern": "explicit qualification in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中有显式的限定"
  },
  {
    "id": "%qD should have been declared inside %qD",
    "pattern": "'(.+?)' should have been declared inside '(.+?)'",
    "replacement": "'$1' 应当已在 '$2' 内声明"
  },
  {
    "id": "%qD has not been declared within %qD",
    "pattern": "'(.+?)' has not been declared within '(.+?)'",
    "replacement": "'$1' 未在 '$2' 内声明"
  },
  {
    "id": "only here as a %<friend%>",
    "pattern": "only here as a 'friend'",
    "replacement": "尽在此处作为 'friend'"
  },
  {
    "id": "%qD attribute requires a single NTBS argument",
    "pattern": "'(.+?)' attribute requires a single NTBS argument",
    "replacement": "'$1' 特性需要单个 NTBS 实参"
  },
  {
    "id": "%qD attribute is meaningless since members of the anonymous namespace get local symbols",
    "pattern": "'(.+?)' attribute is meaningless since members of the anonymous namespace get local symbols",
    "replacement": "'$1' 特性无意义，因为匿名命名空间的成员拥有局部符号"
  },
  {
    "id": "ignoring %qD attribute on anonymous namespace",
    "pattern": "ignoring '(.+?)' attribute on anonymous namespace",
    "replacement": "忽略匿名命名空间上的 '$1' 特性"
  },
  {
    "id": "ignoring %qD attribute on non-inline namespace",
    "pattern": "ignoring '(.+?)' attribute on non-inline namespace",
    "replacement": "忽略非内联匿名空间上的 '$1' 特性"
  },
  {
    "id": "%qD attribute directive ignored",
    "pattern": "'(.+?)' attribute directive ignored",
    "replacement": "'$1' 特性指令已忽略"
  },
  {
    "id": "maximum limit of %d namespaces searched for %qE",
    "pattern": "maximum limit of (\\d+) namespaces searched for '(.+?)'",
    "replacement": "为 '$2' 搜索了 $1 个命名空间，已达最大限制"
  },
  {
    "id": "suggested alternative:",
    "pattern": "suggested alternatives?:",
    "replacement": "建议的替代："
  },
  {
    "id": "%<std::%s%> is defined in header %qs; did you forget to %<#include %s%>?",
    "pattern": "'std::(.*?)' is defined in header '(.+?)'; did you forget to '#include (.*?)'?",
    "replacement": "'std::$1' 定义于头 '$2'；你是否忘记了 '#include $2'？"
  },
  {
    "id": "%<std::%s%> is only available from %s onwards",
    "pattern": "'std::(.*?)' is only available from (.*?) onwards",
    "replacement": "'std::$1' 仅在 '$2' 后可用"
  },
  {
    "id": "the macro %qs had not yet been defined",
    "pattern": "the macro '(.+?)' had not yet been defined",
    "replacement": "宏 '$1' 尚未定义"
  },
  {
    "id": "it was later defined here",
    "pattern": "it was later defined here",
    "replacement": "它在之后此处定义"
  },
  {
    "id": "declaration of %<std::initializer_list%> does not match %<#include <initializer_list>%>, isn%'t a template",
    "pattern": "declaration of 'std::initializer_list' does not match '#include <initializer_list>', isn't a template",
    "replacement": "'std::initializer_list' 的声明与 '#include <initializer_list>' 不匹配，它不是模板"
  },
  {
    "id": "%<strong%> using directive no longer supported",
    "pattern": "'strong' using directive no longer supported",
    "replacement": "'strong' using 指令不再受支持"
  },
  {
    "id": "you can use an inline namespace instead",
    "pattern": "you can use an inline namespace instead",
    "replacement": "你可以使用内联命名空间代替"
  },
  {
    "id": "cannot nest more than %d namespaces",
    "pattern": "cannot nest more than (\\d+) namespaces",
    "replacement": "不能嵌套多于 $1 个命名空间"
  },
  {
    "id": "%<namespace %E%> is ambiguous",
    "pattern": "'namespace (.+?)' is ambiguous",
    "replacement": "'namespace $1' 有歧义"
  },
  {
    "id": "namespace alias %qD not allowed here, assuming %qD",
    "pattern": "namespace alias '(.+?)' not allowed here, assuming '(.+?)'",
    "replacement": "此处不允许命名空间别名 '$1'，假定为 '$2'"
  },
  {
    "id": "inline namespace must be specified at initial definition",
    "pattern": "inline namespace must be specified at initial definition",
    "replacement": "内联命名空间必须在初始定义中指明"
  },
  {
    "id": "%qD defined here",
    "pattern": "'(.+?)' defined here",
    "replacement": "'$1' 在此定义"
  },
  {
    "id": "%s namespace %qD conflicts with reachable definition",
    "pattern": "(.*?) namespace '(.+?)' conflicts with reachable definition",
    "replacement": "'$1' 命名空间 '$2' 与可达的定义冲突"
  },
  {
    "id": "reachable %s definition here",
    "pattern": "reachable (.*?) definition here",
    "replacement": "可达的 '$1' 定义在此"
  },
  {
    "id": "XXX entering %<pop_everything ()%>",
    "pattern": "XXX entering 'pop_everything ()'",
    "replacement": "XXX 进入 'pop_everything ()'"
  },
  {
    "id": "XXX leaving %<pop_everything ()%>",
    "pattern": "XXX leaving 'pop_everything ()'",
    "replacement": "XXX 离开 'pop_everything ()'"
  },
  {
    "id": "making multiple clones of %qD",
    "pattern": "making multiple clones of '(.+?)'",
    "replacement": "做了 '(.+?)' 的多次克隆"
  },
  {
    "id": "identifier %qE is a keyword in C++11",
    "pattern": "identifier '(.+?)' is a keyword in C\\+\\+11",
    "replacement": "标识符 '(.+?)' 是 C++11 中的关键字"
  },
  {
    "id": "identifier %qE is a keyword in C++20",
    "pattern": "identifier '(.+?)' is a keyword in C\\+\\+20",
    "replacement": "标识符 '(.+?)' 是 C++20 中的关键字"
  },
  {
    "id": "%<LEXER_DEBUGGING_ENABLED_P%> is not set to true",
    "pattern": "'LEXER_DEBUGGING_ENABLED_P' is not set to true",
    "replacement": "'LEXER_DEBUGGING_ENABLED_P' 未设置为真"
  },
  {
    "id": "%<#pragma omp declare %s%> not immediately followed by function declaration or definition",
    "pattern": "'#pragma omp declare (.*?)' not immediately followed by function declaration or definition",
    "replacement": "'#pragma omp declare $1' 不允许立即跟随在函数声明或定义后"
  },
  {
    "id": "%<#pragma%> is not allowed here",
    "pattern": "'#pragma' is not allowed here",
    "replacement": "此处不允许使用 '#pragma'"
  },
  {
    "id": "%<%E::%E%> has not been declared",
    "pattern": "'(.+?)::(.+?)' has not been declared",
    "replacement": "'$1::$2' 尚未声明"
  },
  {
    "id": "%<::%E%> has not been declared",
    "pattern": "'::(.+?)' has not been declared",
    "replacement": "'::$1' 尚未声明"
  },
  {
    "id": "request for member %qE in non-class type %qT",
    "pattern": "request for member '(.+?)' in non-class type '(.+?)'",
    "replacement": "在非类类型 '$2' 中请求成员 '$1'"
  },
  {
    "id": "%<%E::%E%> is not a type",
    "pattern": "'(.+?)::(.+?)' is not a type",
    "replacement": "'$1::$2' 不是类型"
  },
  {
    "id": "%<%E::%E%> is not a class or namespace",
    "pattern": "'(.+?)::(.+?)' is not a class or namespace",
    "replacement": "'$1::$2' 不是类或命名空间"
  },
  {
    "id": "%<%E::%E%> is not a class, namespace, or enumeration",
    "pattern": "'(.+?)::(.+?)' is not a class, namespace, or enumeration",
    "replacement": "'$1::$2'不是类、命名空间或枚举"
  },
  {
    "id": "%<::%E%> is not a type",
    "pattern": "'::(.+?)' is not a type",
    "replacement": "'::$1' 不是类型"
  },
  {
    "id": "%<::%E%> is not a class or namespace",
    "pattern": "'::(.+?)' is not a class or namespace",
    "replacement": "'::$1' 不是类或命名空间"
  },
  {
    "id": "%<::%E%> is not a class, namespace, or enumeration",
    "pattern": "'::(.+?)' is not a class, namespace, or enumeration",
    "replacement": "'::$1' 不是类、命名空间或枚举"
  },
  {
    "id": "%qE is not a type",
    "pattern": "'(.+?)' is not a type",
    "replacement": "'$1' 不是类型"
  },
  {
    "id": "%qE is not a class or namespace",
    "pattern": "'(.+?)' is not a class or namespace",
    "replacement": "'$1' 不是类或命名空间"
  },
  {
    "id": "%qE is not a class, namespace, or enumeration",
    "pattern": "'(.+?)' is not a class, namespace, or enumeration",
    "replacement": "'$1' 不是类、命名空间或枚举"
  },
  {
    "id": "new types may not be defined in a return type",
    "pattern": "new types may not be defined in a return type",
    "replacement": "不能在返回类型中定义新类型"
  },
  {
    "id": "(perhaps a semicolon is missing after the definition of %qT)",
    "pattern": "\\(perhaps a semicolon is missing after the definition of '(.+?)'\\)",
    "replacement": "（或许 '$1' 的定义末尾缺少了一个分号）"
  },
  {
    "id": "%qE is not a class template",
    "pattern": "'(.+?)' is not a class template",
    "replacement": "'$1' 不是类模板"
  },
  {
    "id": "%qE is not a template",
    "pattern": "'(.+?)' is not a template",
    "replacement": "'$1' 不是模板"
  },
  {
    "id": "invalid template-id",
    "pattern": "invalid template-id",
    "replacement": "模板标识无效"
  },
  {
    "id": "ISO C++ forbids using a floating-point literal in a constant-expression",
    "pattern": "ISO C\\+\\+ forbids using a floating-point literal in a constant-expression",
    "replacement": "ISO C++ 禁止在常量表达式中使用浮点字面量"
  },
  {
    "id": "a cast to a type other than an integral or enumeration type cannot appear in a constant-expression",
    "pattern": "a cast to a type other than an integral or enumeration type cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现到非整数或枚举类型的类型转换"
  },
  {
    "id": "%<typeid%> operator cannot appear in a constant-expression",
    "pattern": "'typeid' operator cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现 'typeid' 运算符"
  },
  {
    "id": "non-constant compound literals cannot appear in a constant-expression",
    "pattern": "non-constant compound literals cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现非只读的复合字面量"
  },
  {
    "id": "a function call cannot appear in a constant-expression",
    "pattern": "a function call cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现函数调用"
  },
  {
    "id": "an increment cannot appear in a constant-expression",
    "pattern": "an increment cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现自增"
  },
  {
    "id": "an decrement cannot appear in a constant-expression",
    "pattern": "an decrement cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现自减"
  },
  {
    "id": "an array reference cannot appear in a constant-expression",
    "pattern": "an array reference cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现到数组的引用"
  },
  {
    "id": "the address of a label cannot appear in a constant-expression",
    "pattern": "the address of a label cannot appear in a constant-expression",
    "replacement": "乘凉表达式中不能出现标号的地址"
  },
  {
    "id": "calls to overloaded operators cannot appear in a constant-expression",
    "pattern": "calls to overloaded operators cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现对重载运算符的调用"
  },
  {
    "id": "an assignment cannot appear in a constant-expression",
    "pattern": "an assignment cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现赋值"
  },
  {
    "id": "a comma operator cannot appear in a constant-expression",
    "pattern": "a comma operator cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现逗号运算符"
  },
  {
    "id": "a call to a constructor cannot appear in a constant-expression",
    "pattern": "a call to a constructor cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现构造函数调用"
  },
  {
    "id": "a transaction expression cannot appear in a constant-expression",
    "pattern": "a transaction expression cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现事务表达式"
  },
  {
    "id": "%qs cannot appear in a constant-expression",
    "pattern": "'(.+?)' cannot appear in a constant-expression",
    "replacement": "常量表达式中不能出现 '$1'"
  },
  {
    "id": "class template argument deduction is only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "class template argument deduction is only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "类模板实参推导仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "invalid use of destructor %qD as a type",
    "pattern": "invalid use of destructor '(.+?)' as a type",
    "replacement": "非法地将析构函数 '$1' 用作类型"
  },
  {
    "id": "invalid combination of multiple type-specifiers",
    "pattern": "invalid combination of multiple type-specifiers",
    "replacement": "类型说明符的组合无效"
  },
  {
    "id": "%qE does not name a type; did you mean %qs?",
    "pattern": "'(.+?)' does not name a type; did you mean '(.+?)'\\?",
    "replacement": "'$1' 不是一个类型名；你的意思是 '$2' 吗？"
  },
  {
    "id": "%qE does not name a type",
    "pattern": "'(.+?)' does not name a type",
    "replacement": "'$1' 不是一个类型名"
  },
  {
    "id": "C++11 %<constexpr%> only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "C\\+\\+11 'constexpr' only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "C++11 'constexpr' 仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "C++11 %<noexcept%> only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "C\\+\\+11 'noexcept' only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "C++11 'noexcept' 仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "%qE is not recognized as a module control-line",
    "pattern": "'(.+?)' is not recognized as a module control-line",
    "replacement": "'$1' 是一个无法识别的模块控制行"
  },
  {
    "id": "C++20 %qE only available with %<-fmodules-ts%>",
    "pattern": "C\\+\\+20 '(.+?)' only available with '-fmodules-ts'",
    "replacement": "C++20 '$1' 仅在 '-fmodules-ts' 下可用"
  },
  {
    "id": "C++20 %qE only available with %<-fmodules-ts%>, which is not yet enabled with %<-std=c++20%>",
    "pattern": "C\\+\\+20 '(.+?)' only available with '-fmodules-ts', which is not yet enabled with '-std=c\\+\\+20'",
    "replacement": "C++20 '$1' 仅在 '-fmodules-ts' 下可用，它还没有在 'std=c++20' 下启用"
  },
  {
    "id": "C++11 %<thread_local%> only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "C\\+\\+11 'thread_local' only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "C++11 'thread_local' 仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "C++20 %<constinit%> only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "C\\+\\+20 'constinit' only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "C++20 'constinit' 仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "%<concept%> only available with %<-std=c++20%> or %<-fconcepts%>",
    "pattern": "'concept' only available with '-std=c\\+\\+20' or '-fconcepts'",
    "replacement": "'concept' 仅在 '-std=c++20' 或 '-fconcepts' 下可用"
  },
  {
    "id": "%<requires%> only available with %<-std=c++20%> or %<-fconcepts%>",
    "pattern": "'requires' only available with '-std=c\\+\\+20' or '-fconcepts'",
    "replacement": "'requires' 仅在 '-std=c++20' 或 '-fconcepts' 下可用"
  },
  {
    "id": "(perhaps %<typename %T::%E%> was intended)",
    "pattern": "\\(perhaps 'typename (.+?)::(.+?)' was intended\\)",
    "replacement": "（也许您本意是想用 'typename $1::$2'）"
  },
  {
    "id": "%qE in namespace %qE does not name a template type; did you mean %qs?",
    "pattern": "'$1' in namespace '$2' does not name a template type; did you mean '$3'\\?",
    "replacement": "'$2' 命名空间中的 '$1' 并不是模板类型名；你的意思是 '$3' 吗？"
  },
  {
    "id": "%qE in namespace %qE does not name a template type",
    "pattern": "'(.+?)' in namespace '(.+?)' does not name a template type",
    "replacement": "'$2' 命名空间中的 '$1' 并不是模板类型名"
  },
  {
    "id": "%qE in namespace %qE does not name a type; did you mean %qs?",
    "pattern": "'(.+?)' in namespace '(.+?)' does not name a type; did you mean '(.+?)'\\?",
    "replacement": "'$2' 命名空间中的 '$1' 并不是类型名；你的意思是 '$3' 吗？"
  },
  {
    "id": "%qE in namespace %qE does not name a type",
    "pattern": "'(.+?)' in namespace '(.+?)' does not name a type",
    "replacement": "'$2' 命名空间中的 '$1' 并不是类型名"
  },
  {
    "id": "%<%T::%E%> names the constructor, not the type",
    "pattern": "'(.+?)::(.+?)' names the constructor, not the type",
    "replacement": "'$1::$2' 是构造函数名，而不是类型名"
  },
  {
    "id": "and %qT has no template constructors",
    "pattern": "and '(.+?)' has no template constructors",
    "replacement": "且 '$1' 没有模板构造函数"
  },
  {
    "id": "need %<typename%> before %<%T::%D::%E%> because %<%T::%D%> is a dependent scope",
    "pattern": "need 'typename' before '(.+?)::(.+?)::(.+?)' because '(.+?)::(.+?)' is a dependent scope",
    "replacement": "'$1::$2::$3' 之前需要 'typename'，因为 '$4::$5' 是一个待决作用域"
  },
  {
    "id": "need %<typename%> before %<%T::%E%> because %qT is a dependent scope",
    "pattern": "need 'typename' before '(.+?)::(.+?)' because '(.+?)' is a dependent scope",
    "replacement": "'$1::$2' 之前需要 'typename'，因为 '$3' 是一个待决作用域"
  },
  {
    "id": "%qE in %q#T does not name a template type",
    "pattern": "'(.+?)' in '(.+?)' does not name a template type",
    "replacement": "'$2' 中的 '$1' 不是模板名"
  },
  {
    "id": "%qE in %q#T does not name a type",
    "pattern": "'(.+?)' in '(.+?)' does not name a type",
    "replacement": "'$2' 中的 '$1' 不是类型名"
  },
  {
    "id": "expected string-literal",
    "pattern": "expected string-literal",
    "replacement": "期望字符串字面量"
  },
  {
    "id": "inconsistent user-defined literal suffixes %qD and %qD in string literal",
    "pattern": "inconsistent user-defined literal suffixes '(.+?)' and '(.+?)' in string literal",
    "replacement": "字符串字面量中出现不一致的用户定义字面量后缀 '$1' 和 '$2'"
  },
  {
    "id": "unable to find character literal operator %qD with %qT argument",
    "pattern": "unable to find character literal operator '(.+?)' with '(.+?)' argument",
    "replacement": "找不到带 '$2' 实参的字面量操作符 '$1'"
  },
  {
    "id": "integer literal exceeds range of %qT type",
    "pattern": "integer literal exceeds range of '(.+?)' type",
    "replacement": "整数字面量超过 '$1' 类型的范围"
  },
  {
    "id": "floating literal exceeds range of %qT type",
    "pattern": "floating literal exceeds range of '(.+?)' type",
    "replacement": "浮点字面量超过 '$1' 类型的范围"
  },
  {
    "id": "floating literal truncated to zero",
    "pattern": "floating literal truncated to zero",
    "replacement": "浮点字面量向零截断"
  },
  {
    "id": "failed to translate literal to execution character set %qT",
    "pattern": "failed to translate literal to execution character set '(.+?)'",
    "replacement": "在执行字符集 '$1' 上无法翻译字面量"
  },
  {
    "id": "unable to find numeric literal operator %qD",
    "pattern": "unable to find numeric literal operator '(.+?)'",
    "replacement": "找不到数值字面量运算符 '$1'"
  },
  {
    "id": "add %<using namespace std::complex_literals%> (from %<<complex>%>) to enable the C++14 user-defined literal suffixes",
    "pattern": "add 'using namespace std::complex_literals' (from '<complex>') to enable the C\\+\\+14 user-defined literal suffixes",
    "replacement": "添加 'using namespace std::complex_literals'（来自 '<complex>'）来启用 C++14 用户定义字面量后缀"
  },
  {
    "id": "or use %<j%> instead of %<i%> for the GNU built-in suffix",
    "pattern": "or use 'j' instead of 'i' for the GNU built-in suffix",
    "replacement": "或者使用 GNU 内建后缀 'j' 来代替 'i'"
  },
  {
    "id": "use %<-fext-numeric-literals%> to enable more built-in suffixes",
    "pattern": "use '-fext-numeric-literals' to enable more built-in suffixes",
    "replacement": "使用 'fext-numeric-literals' 来启用更多内建后缀"
  },
  {
    "id": "unable to find string literal operator %qD with %qT, %qT arguments",
    "pattern": "unable to find string literal operator '(.+?)' with '(.+?)', '(.+?)' arguments",
    "replacement": "无法找到带有 '$2'，'$3' 实参的字符串字面量运算符 '$1' "
  },
  {
    "id": "global module fragment contents must be from preprocessor inclusion",
    "pattern": "global module fragment contents must be from preprocessor inclusion",
    "replacement": "全局模块片段内容必须来自预处理器包括"
  },
  {
    "id": "expected declaration",
    "pattern": "expected declaration",
    "replacement": "期望声明"
  },
  {
    "id": "expected binary operator",
    "pattern": "expected binary operator",
    "replacement": "期望二元运算符"
  },
  {
    "id": "expected ...",
    "pattern": "expected \\.\\.\\.",
    "replacement": "期望 ..."
  },
  {
    "id": "binary expression in operand of fold-expression",
    "pattern": "binary expression in operand of fold-expression",
    "replacement": "折叠表达式的操作数中出现二元表达式"
  },
  {
    "id": "conditional expression in operand of fold-expression",
    "pattern": "conditional expression in operand of fold-expression",
    "replacement": "折叠表达式的操作数中出现条件表达式"
  },
  {
    "id": "mismatched operator in fold-expression",
    "pattern": "mismatched operator in fold-expression",
    "replacement": "折叠表达式运算符不匹配"
  },
  {
    "id": "fixed-point types not supported in C++",
    "pattern": "fixed-point types not supported in C\\+\\+",
    "replacement": "C++ 不支持定点类型"
  },
  {
    "id": "ISO C++ forbids braced-groups within expressions",
    "pattern": "ISO C\\+\\+ forbids braced-groups within expressions",
    "replacement": "ISO C++ 禁止在表达式中使用花括号组"
  },
  {
    "id": "statement-expressions are not allowed outside functions nor in template-argument lists",
    "pattern": "statement-expressions are not allowed outside functions nor in template-argument lists",
    "replacement": "不允许在函数外或模板实参列表中出现语句表达式"
  },
  {
    "id": "fold-expressions only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "fold-expressions only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "折叠表达式仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "expected primary-expression",
    "pattern": "expected primary-expression",
    "replacement": "期望基本表达式"
  },
  {
    "id": "%<this%> may not be used in this context",
    "pattern": "'this' may not be used in this context",
    "replacement": "'this' 不能用在此语境中"
  },
  {
    "id": "a template declaration cannot appear at block scope",
    "pattern": "a template declaration cannot appear at block scope",
    "replacement": "模板声明不能出现在块作用域中"
  },
  {
    "id": "expected id-expression",
    "pattern": "expected id-expression",
    "replacement": "期望标识表达式"
  },
  {
    "id": "scope %qT before %<~%> is not a class-name",
    "pattern": "scope '(.+?)' before '~' is not a class-name",
    "replacement": "'~' 前的作用域 '$1' 不是类名"
  },
  {
    "id": "%<template%> keyword not permitted in destructor name",
    "pattern": "'template' keyword not permitted in destructor name",
    "replacement": "析构函数名字中不允许出现 'template' 关键字"
  },
  {
    "id": "%<~auto%> only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "'~auto' only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "'~auto' 仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "template-id not allowed for destructor",
    "pattern": "template-id not allowed for destructor",
    "replacement": "模板标识不能用于析构函数"
  },
  {
    "id": "declaration of %<~%T%> as member of %qT",
    "pattern": "declaration of '~(.+?)' as member of '(.+?)'",
    "replacement": "声明 '~$1' 作为 '$2' 的成员"
  },
  {
    "id": "typedef-name %qD used as destructor declarator",
    "pattern": "typedef-name '(.+?)' used as destructor declarator",
    "replacement": "typedef 名 '$1' 被用于析构函数声明符"
  },
  {
    "id": "expected unqualified-id",
    "pattern": "expected unqualified-id",
    "replacement": "期望无限定标识"
  },
  {
    "id": "%qD is not a template",
    "pattern": "'(.+?)' is not a template",
    "replacement": "'$1' 不是模板"
  },
  {
    "id": "found %<:%> in nested-name-specifier, expected %<::%>",
    "pattern": "found ':' in nested-name-specifier, expected '::'",
    "replacement": "嵌套名说明符中发现 ':'，期望 '::'"
  },
  {
    "id": "%<decltype%> evaluates to %qT, which is not a class or enumeration type",
    "pattern": "'decltype' evaluates to '(.+?)', which is not a class or enumeration type",
    "replacement": "'decltype' 求值为 '$1'，它不是类或枚举类型"
  },
  {
    "id": "concept-id %qD in nested-name-specifier",
    "pattern": "concept-id '(.+?)' in nested-name-specifier",
    "replacement": "嵌套名说明符中出现概念标识 '$1'"
  },
  {
    "id": "function template-id %qD in nested-name-specifier",
    "pattern": "function template-id '(.+?)' in nested-name-specifier",
    "replacement": "嵌套名说明符中出现函数模板标识 '$1'"
  },
  {
    "id": "variable template-id %qD in nested-name-specifier",
    "pattern": "variable template-id '(.+?)' in nested-name-specifier",
    "replacement": "嵌套名说明符中出现变量模板标识 '$1'"
  },
  {
    "id": "expected nested-name-specifier",
    "pattern": "expected nested-name-specifier",
    "replacement": "期望嵌套名说明符"
  },
  {
    "id": "types may not be defined in casts",
    "pattern": "types may not be defined in casts",
    "replacement": "不能在类型转换中定义类型"
  },
  {
    "id": "types may not be defined in a %<typeid%> expression",
    "pattern": "types may not be defined in a 'typeid' expression",
    "replacement": "不能在 'typeid' 表达式中定义类型"
  },
  {
    "id": "wrong number of arguments to %<__builtin_addressof%>",
    "pattern": "wrong number of arguments to '__builtin_addressof'",
    "replacement": "传递给 '__builtin_addressof' 的实参个数错误"
  },
  {
    "id": "wrong number of arguments to %<__builtin_launder%>",
    "pattern": "wrong number of arguments to '__builtin_launder'",
    "replacement": "传递给 '__builtin_addressof' 的实参个数错误"
  },
  {
    "id": "ISO C++ forbids compound-literals",
    "pattern": "ISO C\\+\\+ forbids compound-literals",
    "replacement": "ISO C++ 禁止复合字面量"
  },
  {
    "id": "two consecutive %<[%> shall only introduce an attribute",
    "pattern": "two consecutive '\\[' shall only introduce an attribute",
    "replacement": "两个相邻的 '[' 只应引入特性"
  },
  {
    "id": "invalid use of %qD",
    "pattern": "invalid use of '(.+?)'",
    "replacement": "非法地使用了 '$1'"
  },
  {
    "id": "%<%D::%D%> is not a class member",
    "pattern": "'(.+?)::(.+?)' is not a class member",
    "replacement": "'$1::$2' 不是类成员"
  },
  {
    "id": "non-scalar type",
    "pattern": "non-scalar type",
    "replacement": "非标量类型"
  },
  {
    "id": "ISO C++ does not allow %<alignof%> with a non-type",
    "pattern": "ISO C\\+\\+ does not allow 'alignof' with a non-type",
    "replacement": "ISO C++ 不允许对非类型使用'alignof'"
  },
  {
    "id": "types may not be defined in %<noexcept%> expressions",
    "pattern": "types may not be defined in 'noexcept' expressions",
    "replacement": "不能在 'noexcept' 表达式中定义类型"
  },
  {
    "id": "types may not be defined in %qs expressions",
    "pattern": "types may not be defined in '(.+?)' expressions",
    "replacement": "不能在 '$1' 表达式中定义类型"
  },
  {
    "id": "%<__builtin_has_attribute%> with dependent argument not supported yet",
    "pattern": "'__builtin_has_attribute' with dependent argument not supported yet",
    "replacement": "带待决实参的 '__builtin_has_attribute' 尚未支持"
  },
  {
    "id": "types may not be defined in a new-expression",
    "pattern": "types may not be defined in a new-expression",
    "replacement": "new 表达式中不能定义类型"
  },
  {
    "id": "array bound forbidden after parenthesized type-id",
    "pattern": "array bound forbidden after parenthesized type-id",
    "replacement": "括号围起的类型标识后不能出现数组边界"
  },
  {
    "id": "try removing the parentheses around the type-id",
    "pattern": "try removing the parentheses around the type-id",
    "replacement": "尝试删除类型标识两侧的括号"
  },
  {
    "id": "initialization of new-expression for type %<auto%> requires exactly one element",
    "pattern": "initialization of new-expression for type 'auto' requires exactly one element",
    "replacement": "'auto' 类型的 new 表达式的初始化仅需要一个元素"
  },
  {
    "id": "expected expression-list or type-id",
    "pattern": "expected expression-list or type-id",
    "replacement": "期望表达式列表或类型标识"
  },
  {
    "id": "types may not be defined in a new-type-id",
    "pattern": "types may not be defined in a new-type-id",
    "replacement": "不能在 new-type-id 中定义类型"
  },
  {
    "id": "expression in new-declarator must have integral or enumeration type",
    "pattern": "expression in new-declarator must have integral or enumeration type",
    "replacement": "new 声明符中的表达式必须拥有整数或枚举类型"
  },
  {
    "id": "use of old-style cast to %q#T",
    "pattern": "use of old-style cast to '(.+?)'",
    "replacement": "使用到 '$1' 的旧式类型转换"
  },
  {
    "id": "%<>>%> operator is treated as two right angle brackets in C++11",
    "pattern": "'>>' operator is treated as two right angle brackets in C\\+\\+11",
    "replacement": "'>>' 运算符在 C++11 中被认为是两个右尖括号"
  },
  {
    "id": "suggest parentheses around %<>>%> expression",
    "pattern": "suggest parentheses around '>>' expression",
    "replacement": "建议在 '>>' 表达式两侧加上括号"
  },
  {
    "id": "ISO C++ does not allow %<?:%> with omitted middle operand",
    "pattern": "ISO C\\+\\+ does not allow '?:' with omitted middle operand",
    "replacement": "ISO C++ 不允许省略 '?:' 的中间操作数"
  },
  {
    "id": "top-level comma expression in array subscript is deprecated",
    "pattern": "top-level comma expression in array subscript is deprecated",
    "replacement": "数组下标中的顶层逗号表达式被弃用"
  },
  {
    "id": "types may not be defined within %<__builtin_offsetof%>",
    "pattern": "types may not be defined within '__builtin_offsetof'",
    "replacement": "'__builtin_offsetof' 中不能定义类型"
  },
  {
    "id": "lambda-expression in template parameter type",
    "pattern": "lambda-expression in template parameter type",
    "replacement": "模板形参类型中出现 lambda 表达式"
  },
  {
    "id": "lambda-expression in unevaluated context only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "lambda-expression in unevaluated context only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "不求值语境下的 lambda 表达式仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "lambda-expression in template-argument only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "lambda-expression in template-argument only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "模板实参中的 lambda 表达式仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "non-local lambda expression cannot have a capture-default",
    "pattern": "non-local lambda expression cannot have a capture-default",
    "replacement": "非局部 lambda 表达式不能拥有默认捕获"
  },
  {
    "id": "expected end of capture-list",
    "pattern": "expected end of capture-list",
    "replacement": "期望捕获列表的结尾"
  },
  {
    "id": "explicit by-copy capture of %<this%> redundant with by-copy capture default",
    "pattern": "explicit by-copy capture of 'this' redundant with by-copy capture default",
    "replacement": "当采用默认复制捕获时，显式的 'this' 复制捕获是多余的"
  },
  {
    "id": "already captured %qD in lambda expression",
    "pattern": "already captured '(.+?)' in lambda expression",
    "replacement": "lambda 表达式中已经捕获 '$1'"
  },
  {
    "id": "%<*this%> capture only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "'\\*this' capture only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "'*this' 捕获仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "%<this%> cannot be captured by reference",
    "pattern": "'this' cannot be captured by reference",
    "replacement": "'this' 无法通过引用捕获"
  },
  {
    "id": "pack init-capture only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "pack init-capture only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "带初始化的包捕获仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "%<&%> should come before %<...%>",
    "pattern": "'&' should come before '\\.\\.\\.'",
    "replacement": "'&' 应当出现在 '...' 后"
  },
  {
    "id": "lambda capture initializers only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "lambda capture initializers only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "带初始化器的 lambda 捕获仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "empty initializer for lambda init-capture",
    "pattern": "empty initializer for lambda init-capture",
    "replacement": "lambda 带初始化的捕获中出现空初始化器"
  },
  {
    "id": "capture of non-variable %qE",
    "pattern": "capture of non-variable '(.+?)'",
    "replacement": "捕获了非变量 '$1'"
  },
  {
    "id": "capture of variable %qD with non-automatic storage duration",
    "pattern": "capture of variable '(.+?)' with non-automatic storage duration",
    "replacement": "捕获的变量 '$1' 带有非自动存储期"
  },
  {
    "id": "too many %<...%> in lambda capture",
    "pattern": "too many '\\.\\.\\.' in lambda capture",
    "replacement": "lambda 捕获中出现太多的 '...'"
  },
  {
    "id": "explicit by-copy capture of %qD redundant with by-copy capture default",
    "pattern": "explicit by-copy capture of '(.+?)' redundant with by-copy capture default",
    "replacement": "当采用默认复制捕获时，显式的 '$1' 复制捕获是多余的"
  },
  {
    "id": "explicit by-reference capture of %qD redundant with by-reference capture default",
    "pattern": "explicit by-reference capture of '(.+?)' redundant with by-reference capture default",
    "replacement": "当采用默认引用捕获时，显式的 '$1' 引用捕获是多余的"
  },
  {
    "id": "lambda templates are only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "lambda templates are only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "lambda 模板仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "lambda templates are only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "lambda templates are only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "lambda 模板仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "default argument specified for lambda parameter",
    "pattern": "default argument specified for lambda parameter",
    "replacement": "为 lambda 形参指定了默认实参"
  },
  {
    "id": "parameter declaration before lambda declaration specifiers only optional with %<-std=c++2b%> or %<-std=gnu++2b%>",
    "pattern": "parameter declaration before lambda declaration specifiers only optional with '-std=c\\+\\+2b' or '-std=gnu\\+\\+2b'",
    "replacement": "省略 lambda 声明说明符后的形参声明仅在 '-std=c++2b' 或 '-std=gnu++2b' 下可用"
  },
  {
    "id": "duplicate %<mutable%>",
    "pattern": "duplicate 'mutable'",
    "replacement": "重复的 'mutable'"
  },
  {
    "id": "parameter declaration before lambda transaction qualifier only optional with %<-std=c++2b%> or %<-std=gnu++2b%>",
    "pattern": "parameter declaration before lambda transaction qualifier only optional with '-std=c\\+\\+2b' or '-std=gnu\\+\\+2b'",
    "replacement": "省略 lambda 事务限定符后的形参声明仅在 '-std=c++2b' 或 '-std=gnu++2b' 下可用"
  },
  {
    "id": "parameter declaration before lambda exception specification only optional with %<-std=c++2b%> or %<-std=gnu++2b%>",
    "pattern": "parameter declaration before lambda exception specification only optional with '-std=c\\+\\+2b' or '-std=gnu\\+\\+2b'",
    "replacement": "省略 lambda 异常说明后的形参声明仅在 '-std=c++2b' 或 '-std=gnu++2b' 下可用"
  },
  {
    "id": "parameter declaration before lambda trailing return type only optional with %<-std=c++2b%> or %<-std=gnu++2b%>",
    "pattern": "parameter declaration before lambda trailing return type only optional with '-std=c\\+\\+2b' or '-std=gnu\\+\\+2b'",
    "replacement": "省略 lambda 尾随返回类型后的形参声明仅在 '-std=c++2b' 或 '-std=gnu++2b' 下可用"
  },
  {
    "id": "%<constexpr%> lambda only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "'constexpr' lambda only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "'constexpr' lambda 仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "attributes at the beginning of statement are ignored",
    "pattern": "attributes at the beginning of statement are ignored",
    "replacement": "语句起始的特性被忽略"
  },
  {
    "id": "expected labeled-statement",
    "pattern": "expected labeled-statement",
    "replacement": "期望带标号的语句"
  },
  {
    "id": "case label %qE not within a switch statement",
    "pattern": "case label '(.+?)' not within a switch statement",
    "replacement": "case 标号 '$1' 未出现在 switch 语句中"
  },
  {
    "id": "need %<typename%> before %qE because %qT is a dependent scope",
    "pattern": "need 'typename' before '(.+?)' because '(.+?)' is a dependent scope",
    "replacement": "'$1' 之前需要 'typename'，因为 '$2' 是一个待决作用域"
  },
  {
    "id": "compound-statement in %<constexpr%> function",
    "pattern": "compound-statement in 'constexpr' function",
    "replacement": "'constexpr' 函数中出现复合语句"
  },
  {
    "id": "%<if constexpr%> only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "'if constexpr' only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "'if constexpr' 仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "init-statement in selection statements only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "init-statement in selection statements only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "选择语句中的初始化语句仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "expected selection-statement",
    "pattern": "expected selection-statement",
    "replacement": "期望选择语句"
  },
  {
    "id": "condition declares an array",
    "pattern": "condition declares an array",
    "replacement": "条件声明了一个数组"
  },
  {
    "id": "condition declares a function",
    "pattern": "condition declares a function",
    "replacement": "条件声明为一个函数"
  },
  {
    "id": "types may not be defined in conditions",
    "pattern": "types may not be defined in conditions",
    "replacement": "不能在条件中定义类型"
  },
  {
    "id": "expected initializer",
    "pattern": "expected initializer",
    "replacement": "期望初始化器"
  },
  {
    "id": "loop variable %qD of type %qT binds to a temporary constructed from type %qT",
    "pattern": "loop variable '(.+?)' of type '(.+?)' binds to a temporary constructed from type '(.+?)'",
    "replacement": "'$2' 类型的循环变量 '$1' 绑定到 '$3' 类型的临时构造"
  },
  {
    "id": "use non-reference type %qT to make the copy explicit or %qT to prevent copying",
    "pattern": "use non-reference type '(.+?)' to make the copy explicit or '(.+?)' to prevent copying",
    "replacement": "使用非引用类型 '$1' 来显式地复制，或者使用 '$1' 来避免复制"
  },
  {
    "id": "loop variable %qD creates a copy from type %qT",
    "pattern": "loop variable '(.+?)' creates a copy from type '(.+?)'",
    "replacement": "循环变量 '$1' 创建了类型 '$1' 的复制"
  },
  {
    "id": "use reference type to prevent copying",
    "pattern": "use reference type to prevent copying",
    "replacement": "使用引用类型来避免复制"
  },
  {
    "id": "range-based %<for%> expression of type %qT has incomplete type",
    "pattern": "range-based 'for' expression of type '(.+?)' has incomplete type",
    "replacement": "基于范围的 'for' 表达式的类型 '$1' 是不完整类型"
  },
  {
    "id": "inconsistent begin/end types in range-based %<for%> statement: %qT and %qT",
    "pattern": "inconsistent begin/end types in range-based 'for' statement: '(.+?)' and '(.+?)'",
    "replacement": "基于范围的 'for' 语句中，begin/end 类型不一致：'$1' 和 '$2'"
  },
  {
    "id": "expected iteration-statement",
    "pattern": "expected iteration-statement",
    "replacement": "期望迭代语句"
  },
  {
    "id": "range-based %<for%> loops with initializer only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "range-based 'for' loops with initializer only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "带初始化器的基于范围的 'for' 循环仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "range-based %<for%> loops only available with %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "range-based 'for' loops only available with '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "基于范围的 'for' 循环仅在 '-std=c++11' 或 '-std=gnu++11' 下可用"
  },
  {
    "id": "%<goto%> in %<constexpr%> function",
    "pattern": "'goto' in 'constexpr' function",
    "replacement": "'goto' 到 'constexpr' 函数"
  },
  {
    "id": "ISO C++ forbids computed gotos",
    "pattern": "ISO C\\+\\+ forbids computed gotos",
    "replacement": "ISO C++ 禁止经计算的 goto"
  },
  {
    "id": "expected jump-statement",
    "pattern": "expected jump-statement",
    "replacement": "期望跳转语句"
  },
  {
    "id": "expected module-name",
    "pattern": "expected module-name",
    "replacement": "期望模块名"
  },
  {
    "id": "module-declaration not permitted in header-unit",
    "pattern": "module-declaration not permitted in header-unit",
    "replacement": "头单元中不允许模块声明"
  },
  {
    "id": "private module fragment only permitted in purview of module interface or partition",
    "pattern": "private module fragment only permitted in purview of module interface or partition",
    "replacement": "私有模块片段仅在模块接口或模块分区的范围内允许"
  },
  {
    "id": "private module fragment",
    "pattern": "private module fragment",
    "replacement": "私有模块片段"
  },
  {
    "id": "module-declaration only permitted as first declaration, or ending a global module fragment",
    "pattern": "module-declaration only permitted as first declaration, or ending a global module fragment",
    "replacement": "模块声明仅允许作为第一个声明或全局模块片段的结尾"
  },
  {
    "id": "post-module-declaration imports must be contiguous",
    "pattern": "post-module-declaration imports must be contiguous",
    "replacement": "模块后声明的导入必须是连续的"
  },
  {
    "id": "perhaps insert a line break, or other disambiguation, to prevent this being considered a module control-line",
    "pattern": "perhaps insert a line break, or other disambiguation, to prevent this being considered a module control-line",
    "replacement": "或许插入换行或其它消歧义操作来防止将其考虑为模块控制行"
  },
  {
    "id": "import-declaration must be at global scope",
    "pattern": "import-declaration must be at global scope",
    "replacement": "导入生命必须出现在全局作用域"
  },
  {
    "id": "import cannot appear directly in a linkage-specification",
    "pattern": "import cannot appear directly in a linkage-specification",
    "replacement": "导入不能直接带有连接说明"
  },
  {
    "id": "post-module-declaration imports must not be include-translated",
    "pattern": "post-module-declaration imports must not be include-translated",
    "replacement": "模块后声明的导入必须不来自 include"
  },
  {
    "id": "post-module-declaration imports must not be from header inclusion",
    "pattern": "post-module-declaration imports must not be from header inclusion",
    "replacement": "模块后声明的导入不能来自头文件包含"
  },
  {
    "id": "%qE may only occur after a module interface declaration",
    "pattern": "'(.+?)' may only occur after a module interface declaration",
    "replacement": "'$1' 只能在模块接口声明后发生"
  },
  {
    "id": "%qE may only occur once in an export declaration",
    "pattern": "'(.+?)' may only occur once in an export declaration",
    "replacement": "'$1' 在导出声明中只能发生一次"
  },
  {
    "id": "%<export%> not part of following module-directive",
    "pattern": "'export' not part of following module-directive",
    "replacement": "'export' 不是后续模块指令的一部分"
  },
  {
    "id": "attributes are not permitted in this position",
    "pattern": "attributes are not permitted in this position",
    "replacement": "此位置不允许特性"
  },
  {
    "id": "attributes may be inserted here",
    "pattern": "attributes may be inserted here",
    "replacement": "特性可以在此处插入"
  },
  {
    "id": "extra %<;%>",
    "pattern": "extra ';'",
    "replacement": "多余的 ';'"
  },
  {
    "id": "%<__label__%> not at the beginning of a block",
    "pattern": "'__label__' not at the beginning of a block",
    "replacement": "'__label__' 未出现在块起始"
  },
  {
    "id": "non-variable %qD in declaration with more than one declarator with placeholder type",
    "pattern": "non-variable '(.+?)' in declaration with more than one declarator with placeholder type",
    "replacement": "声明中的非变量 '$1' 出现多于一次带占位符类型的声明符"
  },
  {
    "id": "inconsistent deduction for %qT: %qT and then %qT",
    "pattern": "inconsistent deduction for '(.+?)': '(.+?)' and then '(.+?)'",
    "replacement": "对 '$1' 不一致的推导：先是 '$2'，然后是 '$3'"
  },
  {
    "id": "mixing declarations and function-definitions is forbidden",
    "pattern": "mixing declarations and function-definitions is forbidden",
    "replacement": "不能混合声明和函数定义"
  },
  {
    "id": "types may not be defined in a for-range-declaration",
    "pattern": "types may not be defined in a for-range-declaration",
    "replacement": "for range 声明中不能定义类型"
  },
  {
    "id": "initializer in range-based %<for%> loop",
    "pattern": "initializer in range-based 'for' loop",
    "replacement": "基于范围的 for 循环中出现初始化器"
  },
  {
    "id": "multiple declarations in range-based %<for%> loop",
    "pattern": "multiple declarations in range-based 'for' loop",
    "replacement": "基于范围的 for 循环中出现多个声明"
  },
  {
    "id": "structured bindings only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "structured bindings only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "结构化绑定仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "empty structured binding declaration",
    "pattern": "empty structured binding declaration",
    "replacement": "空的结构化绑定声明"
  },
  {
    "id": "invalid initializer for structured binding declaration",
    "pattern": "invalid initializer for structured binding declaration",
    "replacement": "结构化绑定声明的初始化器无效"
  },
  {
    "id": "%<friend%> used outside of class",
    "pattern": "'friend' used outside of class",
    "replacement": "'friend' 用在类外"
  },
  {
    "id": "the %<bool%> keyword is not allowed in a C++20 concept definition",
    "pattern": "the 'bool' keyword is not allowed in a C\\+\\+20 concept definition",
    "replacement": "C++20 概念定义中不允许使用 'bool' 关键字"
  },
  {
    "id": "C++20 concept definition syntax is %<concept <name> = <expr>%>",
    "pattern": "C\\+\\+20 concept definition syntax is 'concept <name> = <expr>'",
    "replacement": "C++20 概念的语法是 'concept <name> = <expr>'"
  },
  {
    "id": "%<auto%> changes meaning in C++11; please remove it",
    "pattern": "'auto' changes meaning in C\\+\\+11; please remove it",
    "replacement": "'auto' 的含义在 C++11 中改变；请考虑删除它"
  },
  {
    "id": "%<decl-specifier%> invalid in condition",
    "pattern": "'decl-specifier' invalid in condition",
    "replacement": "条件中的 'decl-specifier' 无效"
  },
  {
    "id": "%qD invalid in lambda",
    "pattern": "'(.+?)' invalid in lambda",
    "replacement": "lambda 中的 '$1' 无效"
  },
  {
    "id": "type-specifier invalid in lambda",
    "pattern": "type-specifier invalid in lambda",
    "replacement": "lambda  中的类型说明符无效"
  },
  {
    "id": "class definition may not be declared a friend",
    "pattern": "class definition may not be declared a friend",
    "replacement": "类定义不能被声明为友元"
  },
  {
    "id": "templates may not be %<virtual%>",
    "pattern": "templates may not be 'virtual'",
    "replacement": "模板不能是 'virtual' 的"
  },
  {
    "id": "types may not be defined in explicit-specifier",
    "pattern": "types may not be defined in explicit-specifier",
    "replacement": "不能在 explicit 说明符中出现类型名"
  },
  {
    "id": "%<explicit(bool)%> only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "'explicit\\(bool\\)' only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'explicit(bool)' 仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "invalid linkage-specification",
    "pattern": "invalid linkage-specification",
    "replacement": "无效的连接说明符"
  },
  {
    "id": "%<static_assert%> without a message only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "'static_assert' without a message only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "不带消息的 'static_assert' 仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "%<decltype(auto)%> type specifier only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "'decltype\\(auto\\)' type specifier only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "'decltype(auto)' 类型说明符仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "types may not be defined in %<decltype%> expressions",
    "pattern": "types may not be defined in 'decltype' expressions",
    "replacement": "不能在 'decltype' 表达式中定义类型"
  },
  {
    "id": "types may not be defined in a conversion-type-id",
    "pattern": "types may not be defined in a conversion-type-id",
    "replacement": "不能在 convertion-type-id 中定义类型"
  },
  {
    "id": "invalid use of %<auto%> in conversion operator",
    "pattern": "invalid use of 'auto' in conversion operator",
    "replacement": "在转换运算符中非法地使用 'auto'"
  },
  {
    "id": "use of %<auto%> in member template conversion operator can never be deduced",
    "pattern": "use of 'auto' in member template conversion operator can never be deduced",
    "replacement": "以 'auto' 作为模板成员转换运算符将无法被推导"
  },
  {
    "id": "only constructors take member initializers",
    "pattern": "only constructors take member initializers",
    "replacement": "只有构造函数才能使用成员初始化器"
  },
  {
    "id": "cannot expand initializer for member %qD",
    "pattern": "cannot expand initializer for member '(.+?)'",
    "replacement": "无法展开成员 '$1' 的初始化器"
  },
  {
    "id": "mem-initializer for %qD follows constructor delegation",
    "pattern": "mem-initializer for '(.+?)' follows constructor delegation",
    "replacement": "'$1' 的内存初始化器跟在构造函数委托后"
  },
  {
    "id": "constructor delegation follows mem-initializer for %qD",
    "pattern": "constructor delegation follows mem-initializer for '(.+?)'",
    "replacement": "构造函数委托跟在 '$1' 的内存初始化器后"
  },
  {
    "id": "anachronistic old-style base class initializer",
    "pattern": "anachronistic old-style base class initializer",
    "replacement": "过时的旧式基类初始化器"
  },
  {
    "id": "keyword %<typename%> not allowed in this context (a qualified member initializer is implicitly a type)",
    "pattern": "keyword 'typename' not allowed in this context \\(a qualified member initializer is implicitly a type\\)",
    "replacement": "关键字 'typename' 不允许出现在此语境下（带限定的成员初始化器隐式地是一个类型）"
  },
  {
    "id": "unexpected keyword; remove space between quotes and suffix identifier",
    "pattern": "unexpected keyword; remove space between quotes and suffix identifier",
    "replacement": "意外的关键字；移除引号和后缀标识符之间的空格"
  },
  {
    "id": "expected suffix identifier",
    "pattern": "expected suffix identifier",
    "replacement": "期望后缀标识符"
  },
  {
    "id": "expected empty string after %<operator%> keyword",
    "pattern": "expected empty string after 'operator' keyword",
    "replacement": "'operator' 关键字后期望空字符串"
  },
  {
    "id": "invalid encoding prefix in literal operator",
    "pattern": "invalid encoding prefix in literal operator",
    "replacement": "字面量运算符前缀编码无效"
  },
  {
    "id": "expected operator",
    "pattern": "expected operator",
    "replacement": "期望运算符"
  },
  {
    "id": "keyword %<export%> not implemented, and will be ignored",
    "pattern": "keyword 'export' not implemented, and will be ignored",
    "replacement": "关键字 'export' 未实现，将被忽略"
  },
  {
    "id": "keyword %<export%> is deprecated, and is ignored",
    "pattern": "keyword 'export' is deprecated, and is ignored",
    "replacement": "关键字 'export' 被弃用，将被忽略"
  },
  {
    "id": "keyword %<export%> is enabled with %<-fmodules-ts%>",
    "pattern": "keyword 'export' is enabled with '-fmodules-ts'",
    "replacement": "关键字 'export' 在 '-fmodules-ts' 下启用"
  },
  {
    "id": "invalid constrained type parameter",
    "pattern": "invalid constrained type parameter",
    "replacement": "约束的类型形参无效"
  },
  {
    "id": "cv-qualified type parameter",
    "pattern": "cv-qualified type parameter",
    "replacement": "cv-限定的类型形参"
  },
  {
    "id": "invalid use of %<auto%> in default template argument",
    "pattern": "invalid use of 'auto' in default template argument",
    "replacement": "默认模板实参中非法地使用了 'auto'"
  },
  {
    "id": "template parameter pack %qD cannot have a default argument",
    "pattern": "template parameter pack '(.+?)' cannot have a default argument",
    "replacement": "模板形参包 '$1' 不能有默认实参"
  },
  {
    "id": "template parameter packs cannot have default arguments",
    "pattern": "template parameter packs cannot have default arguments",
    "replacement": "模板形参包不能有默认实参"
  },
  {
    "id": "expected template-id",
    "pattern": "expected template-id",
    "replacement": "期望模板标识"
  },
  {
    "id": "%<<::%> cannot begin a template-argument list",
    "pattern": "'<::' cannot begin a template-argument list",
    "replacement": "不能以 '<::' 开始一个模板实参列表"
  },
  {
    "id": "%<<:%> is an alternate spelling for %<[%>. Insert whitespace between %<<%> and %<::%>",
    "pattern": "'<:' is an alternate spelling for '\\['. Insert whitespace between '<' and '::'",
    "replacement": "'<:' 是 '[' 的代用记号。请在'<'和'::'间加上空格"
  },
  {
    "id": "(if you use %<-fpermissive%> or %<-std=c++11%>, or %<-std=gnu++11%> G++ will accept your code)",
    "pattern": "\\(if you use '-fpermissive' or '-std=c\\+\\+11', or '-std=gnu\\+\\+11' G\\+\\+ will accept your code\\)",
    "replacement": "（如果你使用 '-fpermissive' 或 '-std=c++11' 或 'std=gnu++11'，G++ 会接受你的代码）"
  },
  {
    "id": "invalid template-argument-list",
    "pattern": "invalid template-argument-list",
    "replacement": "模板实参列表无效"
  },
  {
    "id": "function name as the left hand operand of %<<%> is ill-formed in C++20; wrap the function name in %<()%>",
    "pattern": "function name as the left hand operand of '<' is ill-formed in C\\+\\+20; wrap the function name in '\\(\\)'",
    "replacement": "C++20 中，函数名作为 '<' 的左侧操作数是非良构的；请用 () 围起函数名"
  },
  {
    "id": "expected %<(%> after template-argument-list",
    "pattern": "expected '\\(' after template-argument-list",
    "replacement": "模板实参列表后期望 '('"
  },
  {
    "id": "parse error in template argument list",
    "pattern": "parse error in template argument list",
    "replacement": "分析模板实参列表时错误"
  },
  {
    "id": "expected template-name",
    "pattern": "expected template-name",
    "replacement": "期望模板名"
  },
  {
    "id": "non-template %qD used as template",
    "pattern": "non-template '(.+?)' used as template",
    "replacement": "非模板 '$1' 用作模板"
  },
  {
    "id": "use %<%T::template %D%> to indicate that it is a template",
    "pattern": "use '(.+?)::template (.+?)' to indicate that it is a template",
    "replacement": "使用 '$1::template $2' 来指示这是一个模板"
  },
  {
    "id": "expected parameter pack before %<...%>",
    "pattern": "expected parameter pack before '\\.\\.\\.'",
    "replacement": "'...' 前期望形参包"
  },
  {
    "id": "expected template-argument",
    "pattern": "expected template-argument",
    "replacement": "期望模板实参"
  },
  {
    "id": "invalid non-type template argument",
    "pattern": "invalid non-type template argument",
    "replacement": "非类型模板实参无效"
  },
  {
    "id": "explicit instantiation shall not use %<inline%> specifier",
    "pattern": "explicit instantiation shall not use 'inline' specifier",
    "replacement": "显式实例化不能使用 'inline' 说明符"
  },
  {
    "id": "explicit instantiation shall not use %<constexpr%> specifier",
    "pattern": "explicit instantiation shall not use 'constexpr' specifier",
    "replacement": "显式实例化不能使用 'constexpr' 说明符"
  },
  {
    "id": "explicit instantiation shall not use %<consteval%> specifier",
    "pattern": "explicit instantiation shall not use 'consteval' specifier",
    "replacement": "显式实例化不能使用 'consteval' 说明符"
  },
  {
    "id": "template specialization with C linkage",
    "pattern": "template specialization with C linkage",
    "replacement": "模板特化具有 C 连接"
  },
  {
    "id": "expected type specifier",
    "pattern": "expected type specifier",
    "replacement": "期望类型说明符"
  },
  {
    "id": "use of %<auto%> in lambda parameter declaration only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "use of 'auto' in lambda parameter declaration only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "lambda 形参声明中使用 'auto' 仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "use of %<auto%> in parameter declaration only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "use of 'auto' in parameter declaration only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "形参声明中使用 'auto' 仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "use of %<auto%> in parameter declaration only available with %<-fconcepts-ts%>",
    "pattern": "use of 'auto' in parameter declaration only available with '-fconcepts-ts'",
    "replacement": "形参声明中使用 'auto' 仅在 '-fconcepts-ts' 下可用"
  },
  {
    "id": "expected template-id for type",
    "pattern": "expected template-id for type",
    "replacement": "期望类型模板标识"
  },
  {
    "id": "expected type-name",
    "pattern": "expected type-name",
    "replacement": "期望类型名"
  },
  {
    "id": "%qE does not constrain a type",
    "pattern": "'(.+?)' does not constrain a type",
    "replacement": "'$1' 不约束一个类型"
  },
  {
    "id": "concept defined here",
    "pattern": "concept defined here",
    "replacement": "概念在此定义"
  },
  {
    "id": "expected %<auto%> or %<decltype(auto)%> after %qE",
    "pattern": "expected 'auto' or 'decltype(auto)' after '(.+?)'",
    "replacement": "'$1' 后期望 'auto' 或 'decltype(auto)'"
  },
  {
    "id": "unexpected placeholder in constrained result type",
    "pattern": "unexpected placeholder in constrained result type",
    "replacement": "约束结果类型中出现意外的占位符"
  },
  {
    "id": "elaborated-type-specifier for a scoped enum must not use the %qD keyword",
    "pattern": "elaborated-type-specifier for a scoped enum must not use the '(.+?)' keyword",
    "replacement": "有作用域的枚举的详述类型说明符不能使用 '$1' 关键字"
  },
  {
    "id": "%<template%> must follow a nested-name-specifier",
    "pattern": "'template' must follow a nested-name-specifier",
    "replacement": "'template' 必须跟在嵌套名说明符后"
  },
  {
    "id": "declaration %qD does not declare anything",
    "pattern": "declaration '(.+?)' does not declare anything",
    "replacement": "声明 '$1' 没有声明任何东西"
  },
  {
    "id": "attributes ignored on uninstantiated type",
    "pattern": "attributes ignored on uninstantiated type",
    "replacement": "特性在未实例化类型上被忽略"
  },
  {
    "id": "attributes ignored on template instantiation",
    "pattern": "attributes ignored on template instantiation",
    "replacement": "特性在模板实例化上被忽略"
  },
  {
    "id": "attributes ignored on elaborated-type-specifier that is not a forward declaration",
    "pattern": "attributes ignored on elaborated-type-specifier that is not a forward declaration",
    "replacement": "特性在非前置声明的详述类型说明符中被忽略"
  },
  {
    "id": "%qD is an enumeration template",
    "pattern": "'(.+?)' is an enumeration template",
    "replacement": "'$1' 是一个枚举模板"
  },
  {
    "id": "%qD does not name an enumeration in %qT",
    "pattern": "'(.+?)' does not name an enumeration in '(.+?)'",
    "replacement": "'$1' 不是 '$2' 中的枚举名"
  },
  {
    "id": "unnamed scoped enum is not allowed",
    "pattern": "unnamed scoped enum is not allowed",
    "replacement": "不允许使用有作用域的无名枚举"
  },
  {
    "id": "expected %<;%> or %<{%>",
    "pattern": "expected ';' or '{'",
    "replacement": "期望 ';' 或 '{'"
  },
  {
    "id": "cannot add an enumerator list to a template instantiation",
    "pattern": "cannot add an enumerator list to a template instantiation",
    "replacement": "不能向模板实例化添加枚举项列表"
  },
  {
    "id": "nested name specifier %qT for enum declaration does not name a class or namespace",
    "pattern": "nested name specifier '(.+?)' for enum declaration does not name a class or namespace",
    "replacement": "枚举声明的嵌套类说明符 '$1' 不指名一个类或命名空间"
  },
  {
    "id": "declaration of %qD in namespace %qD which does not enclose %qD",
    "pattern": "declaration of '(.+?)' in namespace '(.+?)' which does not enclose '(.+?)'",
    "replacement": "'$1' 的声明出现在命名空间 '$2' 中，而后者不包含 '$3'"
  },
  {
    "id": "declaration of %qD in %qD which does not enclose %qD",
    "pattern": "declaration of '(.+?)' in '(.+?)' which does not enclose '(.+?)'",
    "replacement": "'$1' 声明出现在 '$2' 中，而后者不包含 '$3'"
  },
  {
    "id": "extra qualification not allowed",
    "pattern": "extra qualification not allowed",
    "replacement": "不允许有多余的限定"
  },
  {
    "id": "ISO C++ forbids empty unnamed enum",
    "pattern": "ISO C\\+\\+ forbids empty unnamed enum",
    "replacement": "ISO C++ 禁止空的无名枚举"
  },
  {
    "id": "opaque-enum-specifier without name",
    "pattern": "opaque-enum-specifier without name",
    "replacement": "不可见枚举说明符没有名字"
  },
  {
    "id": "opaque-enum-specifier must use a simple identifier",
    "pattern": "opaque-enum-specifier must use a simple identifier",
    "replacement": "不可见枚举说明符必须使用简单标识符"
  },
  {
    "id": "%qD is not a namespace-name; did you mean %qs?",
    "pattern": "'(.+?)' is not a namespace-name; did you mean '(.+?)'\\?",
    "replacement": "'$1' 不是命名空间名；你的意思是 '$2' 吗？"
  },
  {
    "id": "%qD is not a namespace-name",
    "pattern": "'(.+?)' is not a namespace-name",
    "replacement": "'$1' 不是命名空间名"
  },
  {
    "id": "expected namespace-name",
    "pattern": "expected namespace-name",
    "replacement": "期望命名空间名"
  },
  {
    "id": "nested inline namespace definitions only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "nested inline namespace definitions only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "嵌套内联命名空间定义仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "standard attributes on namespaces must precede the namespace name",
    "pattern": "standard attributes on namespaces must precede the namespace name",
    "replacement": "命名空间上的标准特性必须出现在命名空间名之前"
  },
  {
    "id": "nested namespace definitions only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "nested namespace definitions only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "嵌套命名空间定义仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "nested namespace name required",
    "pattern": "nested namespace name required",
    "replacement": "需要嵌套命名空间名"
  },
  {
    "id": "namespace name required",
    "pattern": "namespace name required",
    "replacement": "需要命名空间名"
  },
  {
    "id": "a nested namespace definition cannot have attributes",
    "pattern": "a nested namespace definition cannot have attributes",
    "replacement": "嵌套命名空间定义不能拥有特性"
  },
  {
    "id": "a nested namespace definition cannot be inline",
    "pattern": "a nested namespace definition cannot be inline",
    "replacement": "嵌套命名空间定义不能是内联的"
  },
  {
    "id": "namespace %qD entered",
    "pattern": "namespace '(.+?)' entered",
    "replacement": "进入命名空间 '$1'"
  },
  {
    "id": "%<namespace%> definition is not allowed here",
    "pattern": "'namespace' definition is not allowed here",
    "replacement": "此处不允许使用 'namespace' 定义"
  },
  {
    "id": "pack expansion in using-declaration only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "pack expansion in using-declaration only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "using 声明中的包展开仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "a template-id may not appear in a using-declaration",
    "pattern": "a template-id may not appear in a using-declaration",
    "replacement": "模板标识不允许出现在 using 声明中"
  },
  {
    "id": "comma-separated list in using-declaration only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "comma-separated list in using-declaration only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "using 声明中使用逗号分隔的列表仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "access declarations are deprecated in favour of using-declarations; suggestion: add the %<using%> keyword",
    "pattern": "access declarations are deprecated in favour of using-declarations; suggestion: add the 'using' keyword",
    "replacement": "using 声明弃用了可访问性声明；建议：添加 'using' 关键字"
  },
  {
    "id": "opaque-enum-declaration here",
    "pattern": "opaque-enum-declaration here",
    "replacement": "不可见枚举声明在此"
  },
  {
    "id": "types may not be defined in alias template declarations",
    "pattern": "types may not be defined in alias template declarations",
    "replacement": "不能在别名模板声明中定义类型"
  },
  {
    "id": "%<asm%> in %<constexpr%> function only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "'asm' in 'constexpr' function only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'constexpr' 函数中使用 'asm' 仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "duplicate %<asm%> qualifier %qT",
    "pattern": "duplicate 'asm' qualifier '(.+?)'",
    "replacement": "重复的 'asm' 限定符 '$1'"
  },
  {
    "id": "%<asm%> qualifier %qT ignored outside of function body",
    "pattern": "'asm' qualifier '(.+?)' ignored outside of function body",
    "replacement": "'asm' 限定符 '$1' 在函数体外被忽略"
  },
  {
    "id": "%qT is not an %<asm%> qualifier",
    "pattern": "'(.+?)' is not an 'asm' qualifier",
    "replacement": "'$1' 不是 'asm' 限定符"
  },
  {
    "id": "%<asm%> qualifier outside of function body",
    "pattern": "'asm' qualifier outside of function body",
    "replacement": "'asm' 限定符出现在函数体外"
  },
  {
    "id": "empty parentheses were disambiguated as a function declaration",
    "pattern": "empty parentheses were disambiguated as a function declaration",
    "replacement": "空的括号被消歧义为函数声明"
  },
  {
    "id": "remove parentheses to default-initialize a variable",
    "pattern": "remove parentheses to default-initialize a variable",
    "replacement": "删除括号来默认初始化变量"
  },
  {
    "id": "or replace parentheses with braces to aggregate-initialize a variable",
    "pattern": "or replace parentheses with braces to aggregate-initialize a variable",
    "replacement": "或者将括号替换为花括号来聚合初始化变量"
  },
  {
    "id": "or replace parentheses with braces to value-initialize a variable",
    "pattern": "or replace parentheses with braces to value-initialize a variable",
    "replacement": "或者将括号替换为花括号来值初始化变量"
  },
  {
    "id": "parentheses were disambiguated as a function declaration",
    "pattern": "parentheses were disambiguated as a function declaration",
    "replacement": "括号被消歧义为函数声明"
  },
  {
    "id": "replace parentheses with braces to declare a variable",
    "pattern": "replace parentheses with braces to declare a variable",
    "replacement": "将括号替换为花括号来声明变量"
  },
  {
    "id": "add parentheses to declare a variable",
    "pattern": "add parentheses to declare a variable",
    "replacement": "添加括号来声明变量"
  },
  {
    "id": "a function-definition is not allowed here",
    "pattern": "a function-definition is not allowed here",
    "replacement": "此处不允许函数定义"
  },
  {
    "id": "an %<asm%> specification is not allowed on a function-definition",
    "pattern": "an 'asm' specification is not allowed on a function-definition",
    "replacement": "函数定义中不允许出现 'asm' 说明符"
  },
  {
    "id": "attributes are not allowed on a function-definition",
    "pattern": "attributes are not allowed on a function-definition",
    "replacement": "函数定义上不允许出现特性"
  },
  {
    "id": "expected constructor, destructor, or type conversion",
    "pattern": "expected constructor, destructor, or type conversion",
    "replacement": "期望构造函数、析构函数或类型转换"
  },
  {
    "id": "initializer provided for function",
    "pattern": "initializer provided for function",
    "replacement": "为函数提供了初始化器"
  },
  {
    "id": "attributes after parenthesized initializer ignored",
    "pattern": "attributes after parenthesized initializer ignored",
    "replacement": "括号围起的初始化器后出现的属性被忽略"
  },
  {
    "id": "non-function %qD declared as implicit template",
    "pattern": "non-function '(.+?)' declared as implicit template",
    "replacement": "非函数 '$1' 被声明为隐式模板"
  },
  {
    "id": "array bound is not an integer constant",
    "pattern": "array bound is not an integer constant",
    "replacement": "数组边界不是一个整数常量"
  },
  {
    "id": "cannot define member of dependent typedef %qT",
    "pattern": "cannot define member of dependent typedef '(.+?)'",
    "replacement": "不能定义待决 'typdef' '$1' 的成员"
  },
  {
    "id": "%<%T::%E%> is not a type",
    "pattern": "'(.+?)::(.+?)' is not a type",
    "replacement": "'$1::$2' 不是一个类型"
  },
  {
    "id": "invalid declarator",
    "pattern": "invalid declarator",
    "replacement": "无效的声明符"
  },
  {
    "id": "invalid use of constructor as a template",
    "pattern": "invalid use of constructor as a template",
    "replacement": "将构造函数非法地用作模板"
  },
  {
    "id": "use %<%T::%D%> instead of %<%T::%D%> to name the constructor in a qualified name",
    "pattern": "use '(.+?)::(.+?)' instead of '(.+?)::(.+?)' to name the constructor in a qualified name",
    "replacement": "使用 '$1::$2' 而非 '$3::$4' 来指名限定名中的构造函数"
  },
  {
    "id": "qualified-id in declaration",
    "pattern": "qualified-id in declaration",
    "replacement": "声明中需要一个限定标识"
  },
  {
    "id": "expected declarator",
    "pattern": "expected declarator",
    "replacement": "期望声明符"
  },
  {
    "id": "%qD is a namespace",
    "pattern": "'(.+?)' is a namespace",
    "replacement": "'$1' 是一个命名空间"
  },
  {
    "id": "cannot form pointer to member of non-class %q#T",
    "pattern": "cannot form pointer to member of non-class '(.+?)'",
    "replacement": "不能生成非类类型 '$1' 的成员指针"
  },
  {
    "id": "expected ptr-operator",
    "pattern": "expected ptr-operator",
    "replacement": "期望指针运算符"
  },
  {
    "id": "duplicate cv-qualifier",
    "pattern": "duplicate cv-qualifier",
    "replacement": "重复的 cv-限定符"
  },
  {
    "id": "multiple ref-qualifiers",
    "pattern": "multiple ref-qualifiers",
    "replacement": "重复的引用限定符"
  },
  {
    "id": "%qE requires %<-fgnu-tm%>",
    "pattern": "'(.+?)' requires '-fgnu-tm'",
    "replacement": "'$1' 需要 '-fgnu-tm'"
  },
  {
    "id": "duplicate virt-specifier",
    "pattern": "duplicate virt-specifier",
    "replacement": "重复的虚说明符"
  },
  {
    "id": "missing template arguments after %qT",
    "pattern": "missing template arguments after '(.+?)'",
    "replacement": "'$1' 后缺少模板实参"
  },
  {
    "id": "%qT not permitted in template argument",
    "pattern": "'(.+?)' not permitted in template argument",
    "replacement": "模板实参中不允许 '$1'"
  },
  {
    "id": "types may not be defined in template arguments",
    "pattern": "types may not be defined in template arguments",
    "replacement": "不能在模板实参中定义类型"
  },
  {
    "id": "invalid use of %<auto%> in template argument",
    "pattern": "invalid use of 'auto' in template argument",
    "replacement": "在模板实参中非法地使用了 'auto'"
  },
  {
    "id": "expected type-specifier",
    "pattern": "expected type-specifier",
    "replacement": "期望类型说明符"
  },
  {
    "id": "expected %<,%> or %<...%>",
    "pattern": "expected ',' or '\\.\\.\\.'",
    "replacement": "期望 ',' 或 '...'"
  },
  {
    "id": "types may not be defined in parameter types",
    "pattern": "types may not be defined in parameter types",
    "replacement": "不能在形参类型中定义类型"
  },
  {
    "id": "default arguments are only permitted for function parameters",
    "pattern": "default arguments are only permitted for function parameters",
    "replacement": "默认实参只允许出现在函数形参中"
  },
  {
    "id": "parameter pack %qD cannot have a default argument",
    "pattern": "parameter pack '(.+?)' cannot have a default argument",
    "replacement": "形参包 '$1' 不能拥有默认实参"
  },
  {
    "id": "template parameter pack cannot have a default argument",
    "pattern": "template parameter pack cannot have a default argument",
    "replacement": "模板形参包不能拥有默认实参"
  },
  {
    "id": "parameter pack cannot have a default argument",
    "pattern": "parameter pack cannot have a default argument",
    "replacement": "形参包不能拥有默认实参"
  },
  {
    "id": "function-try-block body of %<constexpr%> constructor only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "function-try-block body of 'constexpr' constructor only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'constexpr' 构造函数的函数 try 块仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "function-try-block body of %<constexpr%> function only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "function-try-block body of 'constexpr' function only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'constexpr' 函数的函数 try 块仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "C++ designated initializers only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "C\\+\\+ designated initializers only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "C++ 指派初始化器仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "ISO C++ does not allow GNU designated initializers",
    "pattern": "ISO C\\+\\+ does not allow GNU designated initializers",
    "replacement": "ISO C++ 不允许 GNU 指派初始化器"
  },
  {
    "id": "ISO C++ does not allow C99 designated initializers",
    "pattern": "ISO C\\+\\+ does not allow C99 designated initializers",
    "replacement": "ISO C++ 不允许 C99 指派初始化器"
  },
  {
    "id": "either all initializer clauses should be designated or none of them should be",
    "pattern": "either all initializer clauses should be designated or none of them should be",
    "replacement": "初始化器子句要么都是指派的，要么都不是"
  },
  {
    "id": "%<...%> not allowed in designated initializer list",
    "pattern": "'\\.\\.\\.' not allowed in designated initializer list",
    "replacement": "指派初始化器列表中不允许 '...'"
  },
  {
    "id": "%<.%s%> designator used multiple times in the same initializer list",
    "pattern": "'.(.*?)' designator used multiple times in the same initializer list",
    "replacement": "同一初始化器列表中 '.$1' 指派符出现了多次"
  },
  {
    "id": "expected class-name",
    "pattern": "expected class-name",
    "replacement": "期望类名"
  },
  {
    "id": "expected %<;%> after class definition",
    "pattern": "expected ';' after class definition",
    "replacement": "类定义后期望 ';'"
  },
  {
    "id": "expected %<;%> after struct definition",
    "pattern": "expected ';' after struct definition",
    "replacement": "结构体定义后期望 ';'"
  },
  {
    "id": "expected %<;%> after union definition",
    "pattern": "expected ';' after union definition",
    "replacement": "联合体定义后期望 ';'"
  },
  {
    "id": "expected %<{%> or %<:%>",
    "pattern": "expected '{' or ':'",
    "replacement": "期望 '{' 或 ':'"
  },
  {
    "id": "cannot specify %<override%> for a class",
    "pattern": "cannot specify 'override' for a class",
    "replacement": "不能为类指定 'override'"
  },
  {
    "id": "global qualification of class name is invalid",
    "pattern": "global qualification of class name is invalid",
    "replacement": "类名的全局限定是无效的"
  },
  {
    "id": "qualified name does not name a class",
    "pattern": "qualified name does not name a class",
    "replacement": "限定名不是一个类名"
  },
  {
    "id": "keyword %<template%> not allowed in class-head-name",
    "pattern": "keyword 'template' not allowed in class-head-name",
    "replacement": "关键字 'template' 不允许在 class-head-name 中使用"
  },
  {
    "id": "invalid class name in declaration of %qD",
    "pattern": "invalid class name in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中类名无效"
  },
  {
    "id": "an explicit specialization must be preceded by %<template <>%>",
    "pattern": "an explicit specialization must be preceded by 'template <>'",
    "replacement": "显式特化必须以 'template <>' 开头"
  },
  {
    "id": "function template %qD redeclared as a class template",
    "pattern": "function template '(.+?)' redeclared as a class template",
    "replacement": "函数模板 '(.+?)' 重声明为类模板"
  },
  {
    "id": "could not resolve typename type",
    "pattern": "could not resolve typename type",
    "replacement": "缺少用以解析类型名的上下文"
  },
  {
    "id": "previous definition of %q#T",
    "pattern": "previous definition of '(.+?)'",
    "replacement": "'$1' 之前的定义"
  },
  {
    "id": "expected class-key",
    "pattern": "expected class-key",
    "replacement": "期望 'class'、'struct' 或 'union'"
  },
  {
    "id": "ISO C++ forbids typename key in template template parameter; use %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "ISO C\\+\\+ forbids typename key in template template parameter; use '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "ISO C++ 禁止模板模板形参中使用 typename 关键字；使用 '-std=c++17' 或 '-std=gnu++17'"
  },
  {
    "id": "expected %<class%> or %<typename%>",
    "pattern": "expected 'class' or 'typename'",
    "replacement": "期望 'class'、'typename' 或 'template'"
  },
  {
    "id": "in C++03 a class-key must be used when declaring a friend",
    "pattern": "in C\\+\\+03 a class-key must be used when declaring a friend",
    "replacement": "C++03 中，声明友元时必须使用 class、struct 或 union 关键字"
  },
  {
    "id": "friend declaration does not name a class or function",
    "pattern": "friend declaration does not name a class or function",
    "replacement": "友元声明没有指定类或函数名"
  },
  {
    "id": "a storage class on an anonymous aggregate in class scope is not allowed",
    "pattern": "a storage class on an anonymous aggregate in class scope is not allowed",
    "replacement": "类作用域中的匿名聚合体上不允许出现存储类"
  },
  {
    "id": "default member initializers for bit-fields only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "default member initializers for bit-fields only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "位域的默认成员初始化器仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "default member initializer for unnamed bit-field",
    "pattern": "default member initializer for unnamed bit-field",
    "replacement": "无名位域使用了默认成员初始化器"
  },
  {
    "id": "ISO C++ allows bit-field attributes only before the %<:%> token",
    "pattern": "ISO C\\+\\+ allows bit-field attributes only before the ':' token",
    "replacement": "ISO C++ 只允许位域特性出现在 ':' 标记前"
  },
  {
    "id": "bit-field %qD has non-integral type %qT",
    "pattern": "bit-field '(.+?)' has non-integral type '(.+?)'",
    "replacement": "位域 '$1' 具有非整数类型 '$2'"
  },
  {
    "id": "pure-specifier on function-definition",
    "pattern": "pure-specifier on function-definition",
    "replacement": "函数定义中出现纯说明符"
  },
  {
    "id": "extra %<;%> after in-class function definition",
    "pattern": "extra ';' after in-class function definition",
    "replacement": "类内函数定义后出现多余的 ';'"
  },
  {
    "id": "stray %<,%> at end of member declaration",
    "pattern": "stray ',' at end of member declaration",
    "replacement": "成员声明的结尾出现游离的 ','"
  },
  {
    "id": "expected %<;%> at end of member declaration",
    "pattern": "expected ';' at end of member declaration",
    "replacement": "成员声明的结尾期望 ';'"
  },
  {
    "id": "invalid pure specifier (only %<= 0%> is allowed)",
    "pattern": "invalid pure specifier (only '= 0' is allowed)",
    "replacement": "无效的纯说明符（仅允许 '= 0'）"
  },
  {
    "id": "a brace-enclosed initializer is not allowed here",
    "pattern": "a brace-enclosed initializer is not allowed here",
    "replacement": "此处不允许花括号初始化器"
  },
  {
    "id": "%<virtual%> specified more than once in base-specifier",
    "pattern": "'virtual' specified more than once in base-specifier",
    "replacement": "在基类限定中指定了多于一次的 'virtual'"
  },
  {
    "id": "more than one access specifier in base-specifier",
    "pattern": "more than one access specifier in base-specifier",
    "replacement": "基类说明符中出现多于一次的访问说明符"
  },
  {
    "id": "keyword %<typename%> not allowed outside of templates",
    "pattern": "keyword 'typename' not allowed outside of templates",
    "replacement": "关键字 'typename' 不能在模板以外使用"
  },
  {
    "id": "keyword %<typename%> not allowed in this context (the base class is implicitly a type)",
    "pattern": "keyword 'typename' not allowed in this context \\(the base class is implicitly a type\\)",
    "replacement": "关键字 'typename' 不允许出现在此语境下（基类隐式地是一个类型）"
  },
  {
    "id": "types may not be defined in an exception-specification",
    "pattern": "types may not be defined in an exception-specification",
    "replacement": "异常说明中不能定义类型"
  },
  {
    "id": "ISO C++17 does not allow dynamic exception specifications",
    "pattern": "ISO C\\+\\+17 does not allow dynamic exception specifications",
    "replacement": "ISO C++17 不允许动态异常说明"
  },
  {
    "id": "dynamic exception specifications are deprecated in C++11",
    "pattern": "dynamic exception specifications are deprecated in C\\+\\+11",
    "replacement": "动态异常说明在 C++11 中弃用"
  },
  {
    "id": "invalid use of %<auto%> in exception-specification",
    "pattern": "invalid use of 'auto' in exception-specification",
    "replacement": "异常说明中非法地使用了 'auto'"
  },
  {
    "id": "%<try%> in %<constexpr%> function only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "'try' in 'constexpr' function only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "'constexpr' 函数中的 'try' 仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "types may not be defined in exception-declarations",
    "pattern": "types may not be defined in exception-declarations",
    "replacement": "不能在异常说明中定义类型"
  },
  {
    "id": "attribute using prefix used together with scoped attribute token",
    "pattern": "attribute using prefix used together with scoped attribute token",
    "replacement": "带前缀的特性与带作用域的特性同时使用"
  },
  {
    "id": "expected an identifier for the attribute name",
    "pattern": "expected an identifier for the attribute name",
    "replacement": "特姓名需要标识符"
  },
  {
    "id": "parentheses must be omitted if %qE attribute argument list is empty",
    "pattern": "parentheses must be omitted if '(.+?)' attribute argument list is empty",
    "replacement": "如果 '$1' 特性实参列表为空，则必须删除括号"
  },
  {
    "id": "attribute %qs specified multiple times",
    "pattern": "attribute '(.+?)' specified multiple times",
    "replacement": "'$1' 特性被多次指定"
  },
  {
    "id": "expected attribute before %<...%>",
    "pattern": "expected attribute before '\\.\\.\\.'",
    "replacement": "'...' 前期望特性"
  },
  {
    "id": "attribute using prefix only available with %<-std=c++17%> or %<-std=gnu++17%>",
    "pattern": "attribute using prefix only available with '-std=c\\+\\+17' or '-std=gnu\\+\\+17'",
    "replacement": "带前缀的特性仅在 '-std=c++17' 或 '-std=gnu++17' 下可用"
  },
  {
    "id": "expression must be enclosed in parentheses",
    "pattern": "expression must be enclosed in parentheses",
    "replacement": "表达式必须被括号围起"
  },
  {
    "id": "missing additional %<requires%> to start a requires-expression",
    "pattern": "missing additional 'requires' to start a requires-expression",
    "replacement": "缺少额外的 'requires' 来开始一个 requires 表达式"
  },
  {
    "id": "result type is not a plain type-constraint",
    "pattern": "result type is not a plain type-constraint",
    "replacement": "结果类型不是单纯的类型约束"
  },
  {
    "id": "return-type-requirement is not a type-constraint",
    "pattern": "return-type-requirement is not a type-constraint",
    "replacement": "返回类型约束不是类型约束"
  },
  {
    "id": "specializing member %<%T::%E%> requires %<template<>%> syntax",
    "pattern": "specializing member '(.+?)::(.+?)' requires 'template<>' syntax",
    "replacement": "特化成员 '$1::$2' 需要 'template<>' 语法"
  },
  {
    "id": "invalid declaration of %<%T::%E%>",
    "pattern": "invalid declaration of '(.+?)::(.+?)'",
    "replacement": "'$1::$2' 的声明无效"
  },
  {
    "id": "too few template-parameter-lists",
    "pattern": "too few template-parameter-lists",
    "replacement": "模板形参列表太少"
  },
  {
    "id": "too many template-parameter-lists",
    "pattern": "too many template-parameter-lists",
    "replacement": "模板形参列表太多"
  },
  {
    "id": "named return values are no longer supported",
    "pattern": "named return values are no longer supported",
    "replacement": "具名返回值不再受支持"
  },
  {
    "id": "ISO C++ did not adopt string literal operator templates taking an argument pack of characters",
    "pattern": "ISO C\\+\\+ did not adopt string literal operator templates taking an argument pack of characters",
    "replacement": "ISO C++ 不采纳接受字符实参包的字符串字面量运算符模板"
  },
  {
    "id": "literal operator template %qD has invalid parameter list; expected non-type template parameter pack %<<char...>%> or single non-type parameter of class type",
    "pattern": "literal operator template '(.+?)' has invalid parameter list; expected non-type template parameter pack '<char...>' or single non-type parameter of class type",
    "replacement": "字面量运算符模板 '$1' 的实参列表无效；期望非类型模板形参包 '<char...>' 或单个类类型的非类型形参"
  },
  {
    "id": "literal operator template %qD has invalid parameter list; expected non-type template parameter pack %<<char...>%>",
    "pattern": "literal operator template '(.+?)' has invalid parameter list; expected non-type template parameter pack '<char...>'",
    "replacement": "字面量运算符模板 '$1' 的实参列表无效；期望非类型模板形参包 '<char...>'"
  },
  {
    "id": "template-introductions are not part of C++20 concepts; use %qs to enable",
    "pattern": "template-introductions are not part of C\\+\\+20 concepts; use '(.+?)' to enable",
    "replacement": "模板引入不是 C++20 概念的一部分；使用 '$1' 来启用"
  },
  {
    "id": "no matching concept for template-introduction",
    "pattern": "no matching concept for template-introduction",
    "replacement": "没有找到与模板引入匹配的概念"
  },
  {
    "id": "invalid declaration of member template in local class",
    "pattern": "invalid declaration of member template in local class",
    "replacement": "局部类中对成员模板的声明无效"
  },
  {
    "id": "template with C linkage",
    "pattern": "template with C linkage",
    "replacement": "模板具有 C 连接"
  },
  {
    "id": "invalid explicit specialization",
    "pattern": "invalid explicit specialization",
    "replacement": "显式特化无效"
  },
  {
    "id": "template declaration of %<typedef%>",
    "pattern": "template declaration of 'typedef'",
    "replacement": "'typedef' 的模板声明"
  },
  {
    "id": "a class template declaration must not declare anything else",
    "pattern": "a class template declaration must not declare anything else",
    "replacement": "类模板声明不能再声明任何其它东西"
  },
  {
    "id": "explicit template specialization cannot have a storage class",
    "pattern": "explicit template specialization cannot have a storage class",
    "replacement": "显式模板特化不能拥有存储类"
  },
  {
    "id": "%<>>%> should be %<> >%> within a nested template argument list",
    "pattern": "'>>' should be '> >' within a nested template argument list",
    "replacement": "在嵌套模板实参列表中应当使用 '> >' 而非 '>>'"
  },
  {
    "id": "spurious %<>>%>, use %<>%> to terminate a template argument list",
    "pattern": "spurious '>>', use '>' to terminate a template argument list",
    "replacement": "可疑的 '>>'，使用 '>' 来结束模板实参列表"
  },
  {
    "id": "%<sizeof...%> argument must be surrounded by parentheses",
    "pattern": "'sizeof...' argument must be surrounded by parentheses",
    "replacement": "'sizeof...' 的实参必须被括号围起"
  },
  {
    "id": "invalid use of %qD in linkage specification",
    "pattern": "invalid use of '(.+?)' in linkage specification",
    "replacement": "连接说明中非法地使用了 '$1'"
  },
  {
    "id": "%<__thread%> before %qD",
    "pattern": "'__thread' before '(.+?)'",
    "replacement": "'__thread' 出现在 '$1' 之前"
  },
  {
    "id": "ISO C++ 1998 does not support %<long long%>",
    "pattern": "ISO C\\+\\+ 1998 does not support 'long long'",
    "replacement": "ISO C++ 1998 不支持 'long long'"
  },
  {
    "id": "both %<__thread%> and %<thread_local%> specified",
    "pattern": "both '__thread' and 'thread_local' specified",
    "replacement": "'__thread' 和 'thread_local' 被同时指明"
  },
  {
    "id": "duplicate %qD",
    "pattern": "duplicate '(.+?)'",
    "replacement": "重复的 '$1'"
  },
  {
    "id": "expected %<new%>",
    "pattern": "expected 'new'",
    "replacement": "期望 'new'"
  },
  {
    "id": "expected %<delete%>",
    "pattern": "expected 'delete'",
    "replacement": "期望 'delete'"
  },
  {
    "id": "expected %<return%>",
    "pattern": "expected 'return'",
    "replacement": "期望 'return'"
  },
  {
    "id": "expected %<extern%>",
    "pattern": "expected 'extern'",
    "replacement": "期望 'extern'"
  },
  {
    "id": "expected %<static_assert%>",
    "pattern": "expected 'static_assert'",
    "replacement": "期望 'static_assert'"
  },
  {
    "id": "expected %<decltype%>",
    "pattern": "expected 'decltype'",
    "replacement": "期望 'decltype'"
  },
  {
    "id": "expected %<operator%>",
    "pattern": "expected 'operator'",
    "replacement": "期望 'operator'"
  },
  {
    "id": "expected %<class%>",
    "pattern": "expected 'class'",
    "replacement": "期望 'class'"
  },
  {
    "id": "expected %<template%>",
    "pattern": "expected 'template'",
    "replacement": "期望 'template'"
  },
  {
    "id": "expected %<namespace%>",
    "pattern": "expected 'namespace'",
    "replacement": "期望 'namespace'"
  },
  {
    "id": "expected %<using%>",
    "pattern": "expected 'using'",
    "replacement": "期望 'using'"
  },
  {
    "id": "expected %<asm%>",
    "pattern": "expected 'asm'",
    "replacement": "期望 'asm'"
  },
  {
    "id": "expected %<try%>",
    "pattern": "expected 'try'",
    "replacement": "期望 'try'"
  },
  {
    "id": "expected %<catch%>",
    "pattern": "expected 'catch'",
    "replacement": "期望 'catch'"
  },
  {
    "id": "expected %<throw%>",
    "pattern": "expected 'throw'",
    "replacement": "期望 'throw'"
  },
  {
    "id": "expected %<auto%>",
    "pattern": "expected 'auto'",
    "replacement": "期望 'auto'"
  },
  {
    "id": "expected %<__label__%>",
    "pattern": "expected '__label__'",
    "replacement": "期望 '__label__'"
  },
  {
    "id": "expected %<@try%>",
    "pattern": "expected '@try'",
    "replacement": "期望 '@try'"
  },
  {
    "id": "expected %<@synchronized%>",
    "pattern": "expected '@synchronized'",
    "replacement": "期望 '@synchronized'"
  },
  {
    "id": "expected %<@throw%>",
    "pattern": "expected '@throw'",
    "replacement": "期望 '@throw'"
  },
  {
    "id": "expected %<__transaction_atomic%>",
    "pattern": "expected '__transaction_atomic'",
    "replacement": "期望 '__transcation_atomic'"
  },
  {
    "id": "expected %<__transaction_relaxed%>",
    "pattern": "expected '__transaction_relaxed'",
    "replacement": "期望 '__transaction_relaxed'"
  },
  {
    "id": "expected %<co_yield%>",
    "pattern": "expected 'co_yield'",
    "replacement": "期望 'co_yield'"
  },
  {
    "id": "expected %<::%>",
    "pattern": "expected '::'",
    "replacement": "期望 '::'"
  },
  {
    "id": "expected %<...%>",
    "pattern": "expected '\\.\\.\\.'",
    "replacement": "期望 '...'"
  },
  {
    "id": "expected %<*%>",
    "pattern": "expected '\\*'",
    "replacement": "期望 '*'"
  },
  {
    "id": "expected %<~%>",
    "pattern": "expected '~'",
    "replacement": "期望 '~'"
  },
  {
    "id": "expected %<:%> or %<::%>",
    "pattern": "expected ':' or '::'",
    "replacement": "期望 ':' 或 '::'"
  },
  {
    "id": "expected %<class%>, %<typename%>, or %<template%>",
    "pattern": "expected 'class', 'typename', or 'template'",
    "replacement": "期望 'class'、'typename' 或 'template'"
  },
  {
    "id": "redundant enum-key %<enum%s%> in reference to %q#T",
    "pattern": "redundant enum-key 'enum(.*?)' in reference to '(.+?)'",
    "replacement": "到 '$2' 的引用中出现冗余的枚举关键字 'enum$1'"
  },
  {
    "id": "%qs tag used in naming %q#T",
    "pattern": "'(.+?)' tag used in naming '(.+?)'",
    "replacement": "在命名 '$2' 时使用了 '$1' 标签"
  },
  {
    "id": "%q#T was previously declared here",
    "pattern": "'(.+?)' was previously declared here",
    "replacement": "'$1' 之前在此声明"
  },
  {
    "id": "redundant class-key %qs in reference to %q#T",
    "pattern": "redundant class-key '(.+?)' in reference to '(.+?)'",
    "replacement": "到 '$2' 的引用中出现冗余的类关键字 '$1'"
  },
  {
    "id": "%qT declared with a mismatched class-key %qs",
    "pattern": "'(.+?)' declared with a mismatched class-key '(.+?)'",
    "replacement": "'$1' 以不匹配的类关键字 '$2' 声明"
  },
  {
    "id": "remove the class-key or replace it with %qs",
    "pattern": "remove the class-key or replace it with '(.+?)'",
    "replacement": "移除类关键字或者将其替换为 '$1'"
  },
  {
    "id": "replace the class-key with %qs",
    "pattern": "replace the class-key with '(.+?)'",
    "replacement": "替换类关键字为 '$1'"
  },
  {
    "id": "%qT defined as %qs here",
    "pattern": "'(.+?)' defined as '(.+?)' here",
    "replacement": "'$1' 在此处定义为 '$2'"
  },
  {
    "id": "%qT first declared as %qs here",
    "pattern": "'(.+?)' first declared as '(.+?)' here",
    "replacement": "'$1' 首次在此处声明为 '$2'"
  },
  {
    "id": "%qD redeclared with different access",
    "pattern": "'(.+?)' redeclared with different access",
    "replacement": "'$1' 重声明时具有不同的可访问性"
  },
  {
    "id": "in C++98 %<template%> (as a disambiguator) is only allowed within templates",
    "pattern": "in C\\+\\+98 'template' \\(as a disambiguator\\) is only allowed within templates",
    "replacement": "C++98 中用作消歧义符的 'template' 只能在模板中使用"
  },
  {
    "id": "file ends in default argument",
    "pattern": "file ends in default argument",
    "replacement": "文件在默认实参处结束"
  },
  {
    "id": "misplaced %<@%D%> Objective-C++ construct",
    "pattern": "misplaced '@(.+?)' Objective-C\\+\\+ construct",
    "replacement": "位置错误的 '@$1' Objective-C++ 构造"
  },
  {
    "id": "objective-c++ message receiver expected",
    "pattern": "objective-c\\+\\+ message receiver expected",
    "replacement": "期望 objective-c++ 消息接收者"
  },
  {
    "id": "objective-c++ message argument(s) are expected",
    "pattern": "objective-c\\+\\+ message argument(s) are expected",
    "replacement": "期望 objective-c++ 消息实参"
  },
  {
    "id": "%<@encode%> must specify a type as an argument",
    "pattern": "'@encode' must specify a type as an argument",
    "replacement": "'@encode' 必须指定一个类型作为实参"
  },
  {
    "id": "invalid Objective-C++ selector name",
    "pattern": "invalid Objective-C\\+\\+ selector name",
    "replacement": "无效的 Objective-C++ 选择器名"
  },
  {
    "id": "objective-c++ method declaration is expected",
    "pattern": "objective-c\\+\\+ method declaration is expected",
    "replacement": "期望 objective-c++ 方法声明"
  },
  {
    "id": "method attributes must be specified at the end",
    "pattern": "method attributes must be specified at the end",
    "replacement": "方法特性必须在结尾指明"
  },
  {
    "id": "stray %qs between Objective-C++ methods",
    "pattern": "stray '(.+?)' between Objective-C\\+\\+ methods",
    "replacement": "Objective-C++ 方法中出现游离的 '$1'"
  },
  {
    "id": "invalid type for instance variable",
    "pattern": "invalid type for instance variable",
    "replacement": "实例变量类型不一致"
  },
  {
    "id": "identifier expected after %<@protocol%>",
    "pattern": "identifier expected after '@protocol'",
    "replacement": "'@protocol' 后期望标识符"
  },
  {
    "id": "attributes may not be specified before the %<@%D%> Objective-C++ keyword",
    "pattern": "attributes may not be specified before the '@(.+?)' Objective-C\\+\\+ keyword",
    "replacement": "不能在 '@$1' Objective-C++ 关键字前指定特性"
  },
  {
    "id": "prefix attributes are ignored before %<@%D%>",
    "pattern": "prefix attributes are ignored before '@(.+?)'",
    "replacement": "'$1' 前的前缀特性被忽略"
  },
  {
    "id": "invalid type for property",
    "pattern": "invalid type for property",
    "replacement": "属性的类型无效"
  },
  {
    "id": "unknown property attribute %qE",
    "pattern": "unknown property attribute '(.+?)'",
    "replacement": "未知的属性特性 '$1'"
  },
  {
    "id": "expected integer expression list",
    "pattern": "expected integer expression list",
    "replacement": "期望整数表达式列表"
  },
  {
    "id": "%<wait%> expression must be integral",
    "pattern": "'wait' expression must be integral",
    "replacement": "'wait' 表达式必须为整数类型"
  },
  {
    "id": "invalid reduction-identifier",
    "pattern": "invalid reduction-identifier",
    "replacement": "无效的归约标识符"
  },
  {
    "id": "types may not be defined in iterator type",
    "pattern": "types may not be defined in iterator type",
    "replacement": "不能在迭代器类型中定义类型"
  },
  {
    "id": "parenthesized initialization is not allowed in OpenMP %<for%> loop",
    "pattern": "parenthesized initialization is not allowed in OpenMP 'for' loop",
    "replacement": "不允许在 OpenMP 'for' 循环中使用括号围起的初始化"
  },
  {
    "id": "%<ordered%> clause with parameter on range-based %<for%> loop",
    "pattern": "'ordered' clause with parameter on range-based 'for' loop",
    "replacement": "基于范围的 'for' 循环中出现带形参的 'ordered' 子句"
  },
  {
    "id": "iteration variable %qD should not be reduction",
    "pattern": "iteration variable '(.+?)' should not be reduction",
    "replacement": "迭代变量 '$1' 不应当是归约"
  },
  {
    "id": "not enough for loops to collapse",
    "pattern": "not enough for loops to collapse",
    "replacement": "折叠没有足够的 for 循环"
  },
  {
    "id": "%<#pragma omp declare %s%> followed by %<#pragma omp declare %s%>",
    "pattern": "'#pragma omp declare (.*?)' followed by '#pragma omp declare (.*?)'",
    "replacement": "'#pragma omp declare $1' 跟在 '#pragma omp declare $2' 后"
  },
  {
    "id": "invalid initializer clause",
    "pattern": "invalid initializer clause",
    "replacement": "无效的初始器子句"
  },
  {
    "id": "expected id-expression (arguments)",
    "pattern": "expected id-expression \\(arguments\\)",
    "replacement": "期望标识表达式（实参）"
  },
  {
    "id": "one of the initializer call arguments should be %<omp_priv%> or %<&omp_priv%>",
    "pattern": "one of the initializer call arguments should be 'omp_priv' or '&omp_priv'",
    "replacement": "初始化器调用实参之一应为 'omp_priv' 或 '&omp_priv'"
  },
  {
    "id": "types may not be defined in declare reduction type list",
    "pattern": "types may not be defined in declare reduction type list",
    "replacement": "归约类型列表中不能定义类型"
  },
  {
    "id": "predeclared arithmetic type %qT in %<#pragma omp declare reduction%>",
    "pattern": "predeclared arithmetic type '(.+?)' in '#pragma omp declare reduction'",
    "replacement": "'#pragma omp declare reduction' 中提前声明了算术类型 '$1'"
  },
  {
    "id": "function or array type %qT in %<#pragma omp declare reduction%>",
    "pattern": "function or array type '(.+?)' in '#pragma omp declare reduction'",
    "replacement": "'#pragma omp declare reduction' 中出现函数或数组类型 '$1'"
  },
  {
    "id": "reference type %qT in %<#pragma omp declare reduction%>",
    "pattern": "reference type '(.+?)' in '#pragma omp declare reduction'",
    "replacement": "'#pragma omp declare reduction' 中出现引用类型 '$1'"
  },
  {
    "id": "%<const%>, %<volatile%> or %<__restrict%>-qualified type %qT in %<#pragma omp declare reduction%>",
    "pattern": "'const', 'volatile' or '__restrict'-qualified type '(.+?)' in '#pragma omp declare reduction'",
    "replacement": "'#pragma omp declare reduction' 中出现 'const'、'volatile' 或 '__restrict' 限定类型 '$1'"
  },
  {
    "id": "%<#pragma acc routine%> names a set of overloads",
    "pattern": "'#pragma acc routine' names a set of overloads",
    "replacement": "'#pragma acc routine' 指名了一个重载集"
  },
  {
    "id": "%qD does not refer to a namespace scope function",
    "pattern": "'(.+?)' does not refer to a namespace scope function",
    "replacement": "'$1' 不指示命名空间作用域的函数"
  },
  {
    "id": "%<__transaction_relaxed%> without transactional memory support enabled",
    "pattern": "'__transaction_relaxed' without transactional memory support enabled",
    "replacement": "无需事务内存支持的 '__transaction_relaxed' 已启用"
  },
  {
    "id": "%<__transaction_atomic%> without transactional memory support enabled",
    "pattern": "'__transaction_atomic' without transactional memory support enabled",
    "replacement": "无需事务内存支持的 '__transaction_atomic' 已启用"
  },
  {
    "id": "outer %<__transaction_cancel%> not within outer %<__transaction_atomic%>",
    "pattern": "outer '__transaction_cancel' not within outer '__transaction_atomic'",
    "replacement": "外层 '__transaction_cancel'无法外层 '__transaction_atomic' 之内"
  },
  {
    "id": "  or a %<transaction_may_cancel_outer%> function",
    "pattern": "  or a 'transaction_may_cancel_outer' function",
    "replacement": "  或 'transaction_may_cancel_outer' 函数"
  },
  {
    "id": "malformed %<#pragma GCC pch_preprocess%>",
    "pattern": "malformed '#pragma GCC pch_preprocess'",
    "replacement": "'#pragma GCC pch_preprocess' 格式错误"
  },
  {
    "id": "%<#pragma omp requires%> may only be used at file or namespace scope",
    "pattern": "'#pragma omp requires' may only be used at file or namespace scope",
    "replacement": "'#pragma omp requires' 只能在文件或命名空间作用域下使用"
  },
  {
    "id": "%<#pragma GCC ivdep%> must be inside a function",
    "pattern": "'#pragma GCC ivdep' must be inside a function",
    "replacement": "'#pragma GCC ivdep' 必须出现在函数内"
  },
  {
    "id": "%<#pragma GCC unroll%> must be inside a function",
    "pattern": "'#pragma GCC unroll' must be inside a function",
    "replacement": "#pragma GCC unroll' 必须出现在函数内"
  },
  {
    "id": "multi-source compilation not implemented for C++",
    "pattern": "multi-source compilation not implemented for C\\+\\+",
    "replacement": "C++ 尚未实现多源编译"
  },
  {
    "id": "placeholder type not allowed in this context",
    "pattern": "placeholder type not allowed in this context",
    "replacement": "此语境下不允许占位符类型"
  },
  {
    "id": "implicit templates may not be %<virtual%>",
    "pattern": "implicit templates may not be 'virtual'",
    "replacement": "隐式模板不能是 'virtual' 的"
  },
  {
    "id": "%<extern \\\"C\\\"%> linkage started here",
    "pattern": "'extern \"C\"' linkage started here",
    "replacement": "'extern \"C\"' 连接在此处开始"
  },
  {
    "id": "data member %qD cannot be a member template",
    "pattern": "data member '(.+?)' cannot be a member template",
    "replacement": "数据成员 '$1' 不能是成员模板"
  },
  {
    "id": "invalid member template declaration %qD",
    "pattern": "invalid member template declaration '(.+?)'",
    "replacement": "无效的成员模板声明 '$1'"
  },
  {
    "id": "explicit specialization in non-namespace scope %qD",
    "pattern": "explicit specialization in non-namespace scope '(.+?)'",
    "replacement": "显式特化出现在非命名空间作用域 '$1' 中"
  },
  {
    "id": "enclosing class templates are not explicitly specialized",
    "pattern": "enclosing class templates are not explicitly specialized",
    "replacement": "所包含的类模板并未被显式特化"
  },
  {
    "id": "specialization of %qD must appear at namespace scope",
    "pattern": "specialization of '(.+?)' must appear at namespace scope",
    "replacement": "'$1' 的特化必须出现在命名空间作用域内"
  },
  {
    "id": "specialization of %qD in different namespace",
    "pattern": "specialization of '(.+?)' in different namespace",
    "replacement": "在不同命名空间内对 '$1' 的特化"
  },
  {
    "id": "explicit instantiation of %qD in namespace %qD (which does not enclose namespace %qD)",
    "pattern": "explicit instantiation of '(.+?)' in namespace '(.+?)' \\(which does not enclose namespace '(.+?)'\\)",
    "replacement": "'$1' 的显式实例化出现在命名空间 '$2' 中，而后者并不包含命名空间 '$3'"
  },
  {
    "id": "name of class shadows template template parameter %qD",
    "pattern": "name of class shadows template template parameter '(.+?)'",
    "replacement": "类名隐藏了模板模板形参 '$1'"
  },
  {
    "id": "specialization of alias template %qD",
    "pattern": "specialization of alias template '(.+?)'",
    "replacement": "别名模板 '$1' 的特化"
  },
  {
    "id": "explicit specialization of non-template %qT",
    "pattern": "explicit specialization of non-template '(.+?)'",
    "replacement": "显式特化非模板 '$1'"
  },
  {
    "id": "specialization of %qT after instantiation",
    "pattern": "specialization of '(.+?)' after instantiation",
    "replacement": "'$1' 在其实例化后特化"
  },
  {
    "id": "from definition of %q#D",
    "pattern": "from definition of '(.+?)'",
    "replacement": "从 '$1' 的定义中"
  },
  {
    "id": "specialization %qT after instantiation %qT",
    "pattern": "specialization '(.+?)' after instantiation '(.+?)'",
    "replacement": "'$1' 在 '$2' 实例化后特化"
  },
  {
    "id": "template specialization of %qD not allowed by ISO C++",
    "pattern": "template specialization of '(.+?)' not allowed by ISO C\\+\\+",
    "replacement": "ISO C++ 不允许 '$1' 的模板特化"
  },
  {
    "id": "%qD is not a function template",
    "pattern": "'(.+?)' is not a function template",
    "replacement": "'$1' 不是函数模板"
  },
  {
    "id": "%qD is not a variable template",
    "pattern": "'(.+?)' is not a variable template",
    "replacement": "'$1' 不是变量模板"
  },
  {
    "id": "template-id %qD for %q+D does not match any template declaration",
    "pattern": "template-id '(.+?)' for '(.+?)' does not match any template declaration",
    "replacement": "'$2' 的模板标识 '$1' 不匹配任何模板声明"
  },
  {
    "id": "saw %d %<template<>%>, need %d for specializing a member function template",
    "pattern": "saw (\\d+) 'template<>', need (\\d+) for specializing a member function template",
    "replacement": "发现 $1 个'template<>'，需要 $2 个来特化成员函数模板"
  },
  {
    "id": "ambiguous template specialization %qD for %q+D",
    "pattern": "ambiguous template specialization '(.+?)' for %q+D",
    "replacement": "'$2' 存在歧义的模板特化 '$1'"
  },
  {
    "id": "variable templates only available with %<-std=c++14%> or %<-std=gnu++14%>",
    "pattern": "variable templates only available with '-std=c\\+\\+14' or '-std=gnu\\+\\+14'",
    "replacement": "变量模板仅在 '-std=c++14' 或 '-std=gnu++14' 下可用"
  },
  {
    "id": "too many template headers for %qD (should be %d)",
    "pattern": "too many template headers for '(.+?)' \\(should be (\\d+)\\)",
    "replacement": "'$1' 的模板头太多（应该为 $2 个）"
  },
  {
    "id": "members of an explicitly specialized class are defined without a template header",
    "pattern": "members of an explicitly specialized class are defined without a template header",
    "replacement": "显式特化类的成员的定义不应带有模板头"
  },
  {
    "id": "explicit specialization of %qD outside its namespace must use a nested-name-specifier",
    "pattern": "explicit specialization of '(.+?)' outside its namespace must use a nested-name-specifier",
    "replacement": "'$1' 在其命名空间外的显式特化应使用嵌套名说明符"
  },
  {
    "id": "explicit instantiation of %qD outside its namespace must use a nested-name-specifier",
    "pattern": "explicit instantiation of '(.+?)' outside its namespace must use a nested-name-specifier",
    "replacement": "'$1' 在其命名空间外的显式实例应使用嵌套名说明符"
  },
  {
    "id": "explicit specialization %q#D may be missing attributes",
    "pattern": "explicit specialization '(.+?)' may be missing attributes",
    "replacement": "'$1' 的显式特化可能缺少特性"
  },
  {
    "id": "missing primary template attributes %s",
    "pattern": "missing primary template attributes? (.*?)",
    "replacement": "缺少主模板特性 '$1'"
  },
  {
    "id": "template-id %qE in declaration of primary template",
    "pattern": "template-id '(.+?)' in declaration of primary template",
    "replacement": "模板标识 '$1' 出现在主模板的声明中"
  },
  {
    "id": "template parameter list used in explicit instantiation",
    "pattern": "template parameter list used in explicit instantiation",
    "replacement": "显式实例化中出现了模板形参列表"
  },
  {
    "id": "definition provided for explicit instantiation",
    "pattern": "definition provided for explicit instantiation",
    "replacement": "为显式实例化提供的定义"
  },
  {
    "id": "too many template parameter lists in declaration of %qD",
    "pattern": "too many template parameter lists in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中模板形参列表太多"
  },
  {
    "id": "too few template parameter lists in declaration of %qD",
    "pattern": "too few template parameter lists in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中模板形参列表太少"
  },
  {
    "id": "explicit specialization of %qD must be introduced by %<template <>%>",
    "pattern": "explicit specialization of '(.+?)' must be introduced by 'template <>'",
    "replacement": "'$1' 的显式特化必须由 'template <>' 引入"
  },
  {
    "id": "explicit specialization declared %<concept%>",
    "pattern": "explicit specialization declared 'concept'",
    "replacement": "显式特化被声明为 'concept'"
  },
  {
    "id": "non-type partial specialization %qE is not allowed",
    "pattern": "non-type partial specialization '(.+?)' is not allowed",
    "replacement": "不允许非类型偏特化 '$1'"
  },
  {
    "id": "non-class, non-variable partial specialization %qE is not allowed",
    "pattern": "non-class, non-variable partial specialization '(.+?)' is not allowed",
    "replacement": "不允许非类、非变量偏特化 '$1'"
  },
  {
    "id": "default argument specified in explicit specialization",
    "pattern": "default argument specified in explicit specialization",
    "replacement": "显式特化时指定了默认实参"
  },
  {
    "id": "%qD is not a template function",
    "pattern": "'(.+?)' is not a template function",
    "replacement": "'$1' 不是模板函数"
  },
  {
    "id": "specialization of implicitly-declared special member function",
    "pattern": "specialization of implicitly-declared special member function",
    "replacement": "特化隐式声明了特殊成员函数"
  },
  {
    "id": "no member function %qD declared in %qT",
    "pattern": "no member function '(.+?)' declared in '(.+?)'",
    "replacement": "'$2' 中没有声明成员函数 '$1'"
  },
  {
    "id": "friend declaration %qD is not visible to explicit specialization",
    "pattern": "friend declaration '(.+?)' is not visible to explicit specialization",
    "replacement": "友元声明 '$1' 对显式特化不可见"
  },
  {
    "id": "friend declaration here",
    "pattern": "friend declaration here",
    "replacement": "友元在此声明"
  },
  {
    "id": "explicit specialization of function concept %qD",
    "pattern": "explicit specialization of function concept '(.+?)'",
    "replacement": "显式特化函数概念 '$1'"
  },
  {
    "id": "argument to %<__integer_pack%> must be between 0 and %d",
    "pattern": "argument to '__integer_pack' must be between 0 and (\\d+)",
    "replacement": "'__integer_pack' 的实参必须介于 0 和 $1 之间"
  },
  {
    "id": "base initializer expansion %qT contains no parameter packs",
    "pattern": "base initializer expansion '(.+?)' contains no parameter packs",
    "replacement": "基类初始化器展开 '$1' 不包含形参包"
  },
  {
    "id": "expansion pattern %qT contains no parameter packs",
    "pattern": "expansion pattern '(.+?)' contains no parameter packs",
    "replacement": "模式展开 '$1' 不包含形参包"
  },
  {
    "id": "parameter packs not expanded with %<...%>:",
    "pattern": "parameter packs not expanded with '\\.\\.\\.':",
    "replacement": "形参包在 '...' 中未展开"
  },
  {
    "id": "declaration of template parameter %q+D shadows template parameter",
    "pattern": "declaration of template parameter '(.+?)' shadows template parameter",
    "replacement": "模板形参 '$1' 的声明隐藏了模板形参"
  },
  {
    "id": "declaration of %q+#D shadows template parameter",
    "pattern": "declaration of '(.+?)' shadows template parameter",
    "replacement": "'$1' 的声明隐藏了一个形参"
  },
  {
    "id": "template parameter %qD declared here",
    "pattern": "template parameter '(.+?)' declared here",
    "replacement": "模板形参 '$1' 在此声明"
  },
  {
    "id": "specialization of variable concept %q#D",
    "pattern": "specialization of variable concept '(.+?)'",
    "replacement": "变量概念 '$1' 的特化"
  },
  {
    "id": "template parameters not deducible in partial specialization:",
    "pattern": "template parameters not deducible in partial specialization:",
    "replacement": "偏特化中模板形参不可推导"
  },
  {
    "id": "partial specialization %q+D does not specialize any template arguments; to define the primary template, remove the template argument list",
    "pattern": "partial specialization '(.+?)' does not specialize any template arguments; to define the primary template, remove the template argument list",
    "replacement": "偏特化 '$1' 不包含任何模板实参；若要定义主模板，请移除模板实参列表"
  },
  {
    "id": "partial specialization %q+D does not specialize any template arguments and is not more constrained than the primary template; to define the primary template, remove the template argument list",
    "pattern": "partial specialization '(.+?)' does not specialize any template arguments and is not more constrained than the primary template; to define the primary template, remove the template argument list",
    "replacement": "偏特化 '$1' 不特化任何模板实参，且它相对主模板没有任何限制；若要定义主模板，请移除模板实参列表"
  },
  {
    "id": "primary template here",
    "pattern": "primary template here",
    "replacement": "主模板在此"
  },
  {
    "id": "partial specialization is not more specialized than the primary template because it replaces multiple parameters with a pack expansion",
    "pattern": "partial specialization is not more specialized than the primary template because it replaces multiple parameters with a pack expansion",
    "replacement": "偏特化相比主模板不更特殊，因为它使用包展开替换了多个形参"
  },
  {
    "id": "too many arguments for partial specialization %qT",
    "pattern": "too many arguments for partial specialization '(.+?)'",
    "replacement": "提供给偏特化 '$1' 的实参太多"
  },
  {
    "id": "partial specialization %qD is not more specialized than",
    "pattern": "partial specialization '(.+?)' is not more specialized than",
    "replacement": "偏特化 '$1' 并不更特殊于"
  },
  {
    "id": "primary template %qD",
    "pattern": "primary template '(.+?)'",
    "replacement": "主模板 '$1'"
  },
  {
    "id": "parameter pack argument %qE must be at the end of the template argument list",
    "pattern": "parameter pack argument '(.+?)' must be at the end of the template argument list",
    "replacement": "形参包实参 '$1' 必须出现在模板实参表末尾"
  },
  {
    "id": "template argument %qE involves template parameter(s)",
    "pattern": "template argument '(.+?)' involves template parameter\\(s\\)",
    "replacement": "模板实参 '(.+?)' 引入了模板形参"
  },
  {
    "id": "type %qT of template argument %qE depends on a template parameter",
    "pattern": "type '(.+?)' of template argument '(.+?)' depends on (a )?template parameters?",
    "replacement": "模板实参 '$1' 的类型 '$2' 依赖于模板形参"
  },
  {
    "id": "declaration of %qD ambiguates earlier template instantiation for %qD",
    "pattern": "declaration of '(.+?)' ambiguates earlier template instantiation for '(.+?)'",
    "replacement": "'$1' 的声明使得早先 '$2' 的模板实例化出现歧义"
  },
  {
    "id": "partial specialization of %qD after instantiation of %qD",
    "pattern": "partial specialization of '(.+?)' after instantiation of '(.+?)'",
    "replacement": "'$1' 的偏特化出现在 '$2' 的实例化之后"
  },
  {
    "id": "no default argument for %qD",
    "pattern": "no default argument for '(.+?)'",
    "replacement": "'$1' 没有默认实参"
  },
  {
    "id": "parameter pack %q+D must be at the end of the template parameter list",
    "pattern": "parameter pack %q+D must be at the end of the template parameter list",
    "replacement": "形参包 '$1' 必须出现在模板形参列表末尾"
  },
  {
    "id": "default template arguments may not be used in function template friend re-declaration",
    "pattern": "default template arguments may not be used in function template friend re-declaration",
    "replacement": "默认模板实参不能用在函数模板友元重声明中"
  },
  {
    "id": "default template arguments may not be used in template friend declarations",
    "pattern": "default template arguments may not be used in template friend declarations",
    "replacement": "默认模板实参不能用在模板友元声明中"
  },
  {
    "id": "default template arguments may not be used in function templates without %<-std=c++11%> or %<-std=gnu++11%>",
    "pattern": "default template arguments may not be used in function templates without '-std=c\\+\\+11' or '-std=gnu\\+\\+11'",
    "replacement": "在未指定 '-std=c++11' 或 '-std=gnu++11' 时，函数模板中不能使用默认模板实参"
  },
  {
    "id": "default template arguments may not be used in partial specializations",
    "pattern": "default template arguments may not be used in partial specializations",
    "replacement": "默认模板实参不能在偏特化中使用"
  },
  {
    "id": "default argument for template parameter for class enclosing %qD",
    "pattern": "default argument for template parameter for class enclosing '(.+?)'",
    "replacement": "包含 '$1' 的类的模板形参拥有默认实参"
  },
  {
    "id": "template %qD declared",
    "pattern": "template '(.+?)' declared",
    "replacement": "声明了模板 '$1'"
  },
  {
    "id": "template class without a name",
    "pattern": "template class without a name",
    "replacement": "模板类没有名字"
  },
  {
    "id": "member template %qD may not have virt-specifiers",
    "pattern": "member template '(.+?)' may not have virt-specifiers",
    "replacement": "成员模板 '$1' 不能拥有虚限定符"
  },
  {
    "id": "invalid template declaration of %qD",
    "pattern": "invalid template declaration of '(.+?)'",
    "replacement": "'$1' 的模板声明无效"
  },
  {
    "id": "template definition of non-template %q#D",
    "pattern": "template definition of non-template '(.+?)'",
    "replacement": "对非模板 '$1' 的模板定义"
  },
  {
    "id": "expected %d levels of template parms for %q#D, got %d",
    "pattern": "expected (\\d+) levels of template parms for '(.+?)', got (\\d+)",
    "replacement": "需要 $1 级的 '$2' 模板形参，却给出了 $3 级"
  },
  {
    "id": "got %d template parameters for %q#D",
    "pattern": "got (\\d+) template parameters for '(.+?)'",
    "replacement": "为 '$2' 得到 $1 个模板形参"
  },
  {
    "id": "  but %d required",
    "pattern": "  but (\\d+) required",
    "replacement": "  但实际需要 $1 个"
  },
  {
    "id": "template arguments to %qD do not match original template %qD",
    "pattern": "template arguments to '(.+?)' do not match original template '(.+?)'",
    "replacement": "给 '$2' 的模板实参不匹配原先的模板 '$1'"
  },
  {
    "id": "use %<template<>%> for an explicit specialization",
    "pattern": "use 'template<>' for an explicit specialization",
    "replacement": "使用 'template<>' 来显式特例化"
  },
  {
    "id": "%qT is not a template type",
    "pattern": "'(.+?)' is not a template type",
    "replacement": "'$1' 不是模板类型"
  },
  {
    "id": "template specifiers not specified in declaration of %qD",
    "pattern": "template specifiers not specified in declaration of '(.+?)'",
    "replacement": "'$1' 的声明中没有模板说明符"
  },
  {
    "id": "redeclared with %d template parameter",
    "pattern": "redeclared with (\\d+) template parameters?",
    "replacement": "重声明为具有 $1 个模板形参"
  },
  {
    "id": "previous declaration %qD used %d template parameter",
    "pattern": "previous declaration '(.+?)' used (\\d+) template parameters?",
    "replacement": "先前的声明 '$1' 使用了 $2 个模板形参"
  },
  {
    "id": "template parameter %q+#D",
    "pattern": "template parameter '(.+?)'",
    "replacement": "模板形参 '$1'"
  },
  {
    "id": "redeclared here as %q#D",
    "pattern": "redeclared here as '(.+?)'",
    "replacement": "此处重声明为 '(.+?)'"
  },
  {
    "id": "declaration of template parameter %q+#D with different constraints",
    "pattern": "declaration of template parameter '(.+?)' with different constraints",
    "replacement": "模板实参 '$1' 的声明带有不同的约束"
  },
  {
    "id": "original declaration appeared here",
    "pattern": "original declaration appeared here",
    "replacement": "原始声明在此出现"
  },
  {
    "id": "redefinition of default argument for %q#D",
    "pattern": "redefinition of default argument for '(.+?)'",
    "replacement": "重定义 '$1' 的默认实参"
  },
  {
    "id": "original definition appeared here",
    "pattern": "original definition appeared here",
    "replacement": "原始定义在此出现"
  },
  {
    "id": "redeclaration %q#D with different constraints",
    "pattern": "redeclaration '(.+?)' with different constraints",
    "replacement": "重声明 '$1' 带有不同的约束"
  },
  {
    "id": "%qE is not a valid template argument for type %qT",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)'",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参"
  },
  {
    "id": "it must be the address of a function with external linkage",
    "pattern": "it must be the address of a function with external linkage",
    "replacement": "它必须是一个具有外部连接的函数的地址"
  },
  {
    "id": "it must be the name of a function with external linkage",
    "pattern": "it must be the name of a function with external linkage",
    "replacement": "它必须是一个具有外部连接的函数的名字"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because %qD has no linkage",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because '(.+?)' has no linkage",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为 '$3' 是无连接的"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because %qD does not have external linkage",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because '(.+?)' does not have external linkage",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为 '$3' 没有外部连接"
  },
  {
    "id": "it must be a pointer-to-member of the form %<&X::Y%>",
    "pattern": "it must be a pointer-to-member of the form '&X::Y'",
    "replacement": "它必须是形如 '&X::Y' 的成员指针"
  },
  {
    "id": "because it is a member of %qT",
    "pattern": "because it is a member of '(.+?)'",
    "replacement": "因为它不是 '$1' 的成员"
  },
  {
    "id": "  couldn%'t deduce template parameter %qD",
    "pattern": "  couldn't deduce template parameter '(.+?)'",
    "replacement": "不能推导模板形参 '$1'"
  },
  {
    "id": "  types %qT and %qT have incompatible cv-qualifiers",
    "pattern": "  types '(.+?)' and '(.+?)' have incompatible cv-qualifiers",
    "replacement": "  类型 '$1' 和 '$2' 有不兼容的 cv-限定符"
  },
  {
    "id": "  mismatched types %qT and %qT",
    "pattern": "  mismatched types '(.+?)' and '(.+?)'",
    "replacement": "  类型 '$1' 和 '$2' 不匹配"
  },
  {
    "id": "  template parameter %qD is not a parameter pack, but argument %qD is",
    "pattern": "  template parameter '(.+?)' is not a parameter pack, but argument '(.+?)' is",
    "replacement": "  模板形参 '$1' 不是形参包，但实参 '$1' 是"
  },
  {
    "id": "  template argument %qE does not match pointer-to-member constant %qE",
    "pattern": "  template argument '(.+?)' does not match pointer-to-member constant '(.+?)'",
    "replacement": "  模板实参 '$1' 与只读成员指针 '$2' 不匹配"
  },
  {
    "id": "  %qE is not equivalent to %qE",
    "pattern": "  '(.+?)' is not equivalent to '(.+?)'",
    "replacement": "  '$1' 不等价于 '$2'"
  },
  {
    "id": "  inconsistent parameter pack deduction with %qT and %qT",
    "pattern": "  inconsistent parameter pack deduction with '(.+?)' and '(.+?)'",
    "replacement": "  不一致的形参包推导 '$1' 和 '$2'"
  },
  {
    "id": "  deduced conflicting types for parameter %qT (%qT and %qT)",
    "pattern": "  deduced conflicting types for parameter '(.+?)' \\('(.+?)' and '(.+?)'\\)",
    "replacement": "  形参 '$1' 的类型推导不一致：（'$2' 和 '$3'）"
  },
  {
    "id": "  deduced conflicting values for non-type parameter %qE (%qE and %qE)",
    "pattern": "  deduced conflicting values for non-type parameter '(.+?)' \\('(.+?)' and '(.+?)'\\)",
    "replacement": "  非类型形参 '$1' 的值推导不一致：（'$2' 和 '$3'）"
  },
  {
    "id": "  variable-sized array type %qT is not a valid template argument",
    "pattern": "  variable-sized array type '(.+?)' is not a valid template argument",
    "replacement": "  变长数组类型 '$1' 不是有效的模板实参"
  },
  {
    "id": "  member function type %qT is not a valid template argument",
    "pattern": "  member function type '(.+?)' is not a valid template argument",
    "replacement": "  成员函数类型 '$1' 不是有效的模板实参"
  },
  {
    "id": "  candidate expects at least %d argument, %d provided",
    "pattern": "candidate expects at least (\\d+) arguments?, (\\d+) provided",
    "replacement": "备选需要至少 $1 个实参，但提供了 $2 个"
  },
  {
    "id": "  cannot convert %qE (type %qT) to type %qT",
    "pattern": "  cannot convert '(.+?)' \\(type '(.+?)'\\) to type '(.+?)'",
    "replacement": "  无法将 '$1'（'$2' 类型）转换到 '$3' 类型"
  },
  {
    "id": "  %qT is an ambiguous base class of %qT",
    "pattern": "  '(.+?)' is an ambiguous base class of '(.+?)'",
    "replacement": "  '$1' 是 '$2' 的有歧义基类"
  },
  {
    "id": "  %qT is not derived from %qT",
    "pattern": "  '(.+?)' is not derived from '(.+?)'",
    "replacement": "  '$1' 不是从 '$2' 派生的"
  },
  {
    "id": "  template parameters of a template template argument are inconsistent with other deduced template arguments",
    "pattern": "  template parameters of a template template argument are inconsistent with other deduced template arguments",
    "replacement": "  模板模板实参的模板形参与其它推导得到的模板实参不一致"
  },
  {
    "id": "  cannot deduce a template for %qT from non-template type %qT",
    "pattern": "  cannot deduce a template for '(.+?)' from non-template type '(.+?)'",
    "replacement": "  不能从非模板类型 '$2' 推导 '$1' 的模板"
  },
  {
    "id": "  template argument %qE does not match %qE",
    "pattern": "  template argument '(.+?)' does not match '(.+?)'",
    "replacement": "  模板实参 '$1' 不匹配 '$2'"
  },
  {
    "id": "%qE is not a valid template argument of type %qT because %qE is not a variable",
    "pattern": "'(.+?)' is not a valid template argument of type '(.+?)' because '(.+?)' is not a variable",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为 '$3' 不是一个变量"
  },
  {
    "id": "%qE is not a valid template argument of type %qT in C++98 because %qD does not have external linkage",
    "pattern": "'(.+?)' is not a valid template argument of type '(.+?)' in C\\+\\+98 because '(.+?)' does not have external linkage",
    "replacement": "在 C++98 中，'$1' 不是类型 '$2' 的有效模板实参，因为函数 '$3' 没有外部连接"
  },
  {
    "id": "%qE is not a valid template argument of type %qT because %qD has no linkage",
    "pattern": "'(.+?)' is not a valid template argument of type '(.+?)' because '(.+?)' has no linkage",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为 '$3' 是无连接的"
  },
  {
    "id": "the address of %qD is not a valid template argument",
    "pattern": "the address of '(.+?)' is not a valid template argument",
    "replacement": "'$1' 的地址不是有效的模板实参"
  },
  {
    "id": "the address of the %qT subobject of %qD is not a valid template argument",
    "pattern": "the address of the '(.+?)' subobject of '(.+?)' is not a valid template argument",
    "replacement": "'$2' 的子对象 '$1' 的地址不是有效的模板实参"
  },
  {
    "id": "the address of %qD is not a valid template argument because it does not have static storage duration",
    "pattern": "the address of '(.+?)' is not a valid template argument because it does not have static storage duration",
    "replacement": "'$1' 的地址不是有效的模板实参，因为它不具有静态存储期"
  },
  {
    "id": "%qD is not a valid template argument because %qD is a variable, not the address of a variable",
    "pattern": "'(.+?)' is not a valid template argument because '(.+?)' is a variable, not the address of a variable",
    "replacement": "'$1' 不是有效的模板实参，因为 '$2' 是一个变量而非变量的地址"
  },
  {
    "id": "%qE is not a valid template argument for %qT because it is not the address of a variable",
    "pattern": "'(.+?)' is not a valid template argument for '(.+?)' because it is not the address of a variable",
    "replacement": "'$1' 不是 '$2' 的有效模板实参，因为它不是变量的地址"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because string literals can never be used in this context",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because string literals can never be used in this context",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为字符串字面量不能在此语境下使用"
  },
  {
    "id": "in template argument for type %qT",
    "pattern": "in template argument for type '(.+?)'",
    "replacement": "类型 '$1' 的模板实参中"
  },
  {
    "id": "template argument %qE for type %qT not a compile-time constant",
    "pattern": "template argument '(.+?)' for type '(.+?)' not a compile-time constant",
    "replacement": "类型 '$2' 的模板实参 '$1' 不是编译期常量"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because of conflicts in cv-qualification",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because of conflicts in cv-qualification",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为它们的 cv-限定冲突"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because it is not an lvalue",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because it is not an lvalue",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为它不是一个左值"
  },
  {
    "id": "%q#D is not a valid template argument for type %qT because a reference variable does not have a constant address",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because a reference variable does not have a constant address",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为一个引用变量没有常量地址"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because it is a pointer",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because it is a pointer",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为它是一个指针"
  },
  {
    "id": "try using %qE instead",
    "pattern": "try using '(.+?)' instead",
    "replacement": "尝试使用 '$1' 代替"
  },
  {
    "id": "%qE is not a valid template argument for type %qT because it is of type %qT",
    "pattern": "'(.+?)' is not a valid template argument for type '(.+?)' because it is of type '(.+?)'",
    "replacement": "'$1' 不是类型 '$2' 的有效模板实参，因为它具有 '$3' 类型"
  },
  {
    "id": "ignoring attributes on template argument %qT",
    "pattern": "ignoring attributes on template argument '(.+?)'",
    "replacement": "忽略模板实参 '$1' 上的特性"
  },
  {
    "id": "ignoring attributes in template argument %qE",
    "pattern": "ignoring attributes in template argument '(.+?)'",
    "replacement": "忽略模板实参 '$1' 中的特性"
  },
  {
    "id": "injected-class-name %qD used as template template argument",
    "pattern": "injected-class-name '(.+?)' used as template template argument",
    "replacement": "注入类名 '$1' 被用作模板模板实参"
  },
  {
    "id": "invalid use of destructor %qE as a type",
    "pattern": "invalid use of destructor '(.+?)' as a type",
    "replacement": "将析构函数 '$1' 非法地作为类型使用"
  },
  {
    "id": "to refer to a type member of a template parameter, use %<typename %E%>",
    "pattern": "to refer to a type member of a template parameter, use 'typename (.+?)'",
    "replacement": "若要指示某个模板形参的类型成员，请使用 'typename (.+?)'"
  },
  {
    "id": "type/value mismatch at argument %d in template parameter list for %qD",
    "pattern": "type/value mismatch at argument (\\d+) in template parameter list for '(.+?)'",
    "replacement": "在 '$2' 的模板形参列表中，第 $1 个实参的类型/值不匹配，"
  },
  {
    "id": "  expected a constant of type %qT, got %qT",
    "pattern": "  expected a constant of type '(.+?)', got '(.+?)'",
    "replacement": "  期望一个 '$1' 类型的常量，却得到了 '$2'"
  },
  {
    "id": "  ambiguous template argument for non-type template parameter is treated as function type",
    "pattern": "  ambiguous template argument for non-type template parameter is treated as function type",
    "replacement": "  非类型模板形参的有歧义实参被当做是函数类型"
  },
  {
    "id": "  expected a class template, got %qE",
    "pattern": "  expected a class template, got '(.+?)'",
    "replacement": "  期望一个类模板，却得到了 '$1'"
  },
  {
    "id": "  expected a type, got %qE",
    "pattern": "  expected a type, got '(.+?)'",
    "replacement": "  期望一个类型，却得到了 '$1'"
  },
  {
    "id": "  expected a template of type %qD, got %qT",
    "pattern": "  expected a template of type '(.+?)', got '(.+?)'",
    "replacement": "  期望 '$1' 类型的模板，却得到了 '$2'"
  },
  {
    "id": "constraint mismatch at argument %d in template parameter list for %qD",
    "pattern": "constraint mismatch at argument (\\d+) in template parameter list for '(.+?)'",
    "replacement": "'$2' 的模板形参列表中，第 $1 个实参约束不匹配"
  },
  {
    "id": "  expected %qD but got %qD",
    "pattern": "  expected '(.+?)' but got '(.+?)'",
    "replacement": "  期望 '$1'，却得到了 '$2'"
  },
  {
    "id": "could not convert template argument %qE from %qT to %qT",
    "pattern": "could not convert template argument '(.+?)' from '(.+?)' to '(.+?)'",
    "replacement": "不能将模板实参 '$1' 从 '$2' 转换到 '$3'"
  },
  {
    "id": "template argument %d is invalid",
    "pattern": "template argument (\\d+) is invalid",
    "replacement": "模板第 $1 个实参无效"
  },
  {
    "id": "wrong number of template arguments (%d, should be %d)",
    "pattern": "wrong number of template arguments \\((\\d+), should be (\\d+)\\)",
    "replacement": "模板实参个数错误（不应是 $1 个而应是 $2 个）"
  },
  {
    "id": "wrong number of template arguments (%d, should be at least %d)",
    "pattern": "wrong number of template arguments \\((\\d+), should be at least (\\d+)\\)",
    "replacement": "模板实参个数错误（不应是 $1 个而应是至少 $2 个）"
  },
  {
    "id": "provided for %qD",
    "pattern": "provided for '(.+?)'",
    "replacement": "提供给 '$1'"
  },
  {
    "id": "pack expansion argument for non-pack parameter %qD of alias template %qD",
    "pattern": "pack expansion argument for non-pack parameter '(.+?)' of alias template '(.+?)'",
    "replacement": "包展开实参提供给了别名模板 '$2' 的非包形参 '$1'"
  },
  {
    "id": "pack expansion argument for non-pack parameter %qD of concept %qD",
    "pattern": "pack expansion argument for non-pack parameter '(.+?)' of concept '(.+?)'",
    "replacement": "包展开实参提供给了概念 '$2' 的非包形参 '$1'"
  },
  {
    "id": "so any instantiation with a non-empty parameter pack would be ill-formed",
    "pattern": "so any instantiation with a non-empty parameter pack would be ill-formed",
    "replacement": "因此任何非空形参包的实例化将是非良构的"
  },
  {
    "id": "%q#D is not a function template",
    "pattern": "'(.+?)' is not a function template",
    "replacement": "'$1' 不是函数模板"
  },
  {
    "id": "non-template type %qT used as a template",
    "pattern": "non-template type '(.+?)' used as a template",
    "replacement": "非模板类型 '$1' 被用作模板"
  },
  {
    "id": "for template declaration %q+D",
    "pattern": "for template declaration '(.+?)'",
    "replacement": "对于模板声明 '$1'"
  },
  {
    "id": "template constraint failure for %qD",
    "pattern": "template constraint failure for '(.+?)'",
    "replacement": "'$1' 模板约束失败"
  },
  {
    "id": "use of invalid variable template %qE",
    "pattern": "use of invalid variable template '(.+?)'",
    "replacement": "使用无效的变量模板 '$1'"
  },
  {
    "id": "template instantiation depth exceeds maximum of %d (use %<-ftemplate-depth=%> to increase the maximum)",
    "pattern": "template instantiation depth exceeds maximum of (\\d+) \\(use '-ftemplate-depth=' to increase the maximum\\)",
    "replacement": "模板实例化的深度超过最大值 $1（使用 '-ftemplate-depth=' 来增加最大值）"
  },
  {
    "id": "flexible array member %qD in union",
    "pattern": "flexible array member '(.+?)' in union",
    "replacement": "联合体中出现柔性数组成员 '$1'"
  },
  {
    "id": "fold of empty expansion over %O",
    "pattern": "fold of empty expansion over (.*?)",
    "replacement": "$1 上空展开的折叠表达式"
  },
  {
    "id": "%qE is not the entire pattern of the pack expansion",
    "pattern": "'(.+?)' is not the entire pattern of the pack expansion",
    "replacement": "'$1' 不是整个包展开的模式"
  },
  {
    "id": "mismatched argument pack lengths while expanding %qT",
    "pattern": "mismatched argument pack lengths while expanding '(.+?)'",
    "replacement": "展开 '$1' 时形参包长度不匹配"
  },
  {
    "id": "  when instantiating default argument for call to %qD",
    "pattern": "  when instantiating default argument for call to '(.+?)'",
    "replacement": "  当实例化调用 '$1' 的默认实参"
  },
  {
    "id": "creating pointer to member function of non-class type %qT",
    "pattern": "creating pointer to member function of non-class type '(.+?)'",
    "replacement": "创建非类类型 '$1' 的成员函数指针"
  },
  {
    "id": "variable %qD has function type",
    "pattern": "variable '(.+?)' has function type",
    "replacement": "变量 '$1' 具有函数类型"
  },
  {
    "id": "invalid parameter type %qT",
    "pattern": "invalid parameter type '(.+?)'",
    "replacement": "无效的形参类型 '$1'"
  },
  {
    "id": "in declaration %q+D",
    "pattern": "in declaration '(.+?)'",
    "replacement": "在声明 '$1' 中"
  },
  {
    "id": "function returning an array",
    "pattern": "function returning an array",
    "replacement": "函数返回了一个数组"
  },
  {
    "id": "function returning a function",
    "pattern": "function returning a function",
    "replacement": "函数返回了一个函数"
  },
  {
    "id": "forming reference to void",
    "pattern": "forming reference to void",
    "replacement": "形成对 void 的引用"
  },
  {
    "id": "forming pointer to reference type %qT",
    "pattern": "forming pointer to reference type '(.+?)'",
    "replacement": "生成指向引用类型 '$1' 的指针"
  },
  {
    "id": "forming reference to reference type %qT",
    "pattern": "forming reference to reference type '(.+?)'",
    "replacement": "生成到引用类型 '$1' 的引用"
  },
  {
    "id": "forming pointer to qualified function type %qT",
    "pattern": "forming pointer to qualified function type '(.+?)'",
    "replacement": "生成指向带限定的函数类型 '$1' 的指针"
  },
  {
    "id": "forming reference to qualified function type %qT",
    "pattern": "forming reference to qualified function type '(.+?)'",
    "replacement": "生成到带限定的函数类型 '$1' 的引用"
  },
  {
    "id": "creating pointer to member of non-class type %qT",
    "pattern": "creating pointer to member of non-class type '(.+?)'",
    "replacement": "创建指向非类类型 '$1' 的成员指针"
  },
  {
    "id": "creating pointer to member reference type %qT",
    "pattern": "creating pointer to member reference type '(.+?)'",
    "replacement": "创建指向引用类型 '$1' 的成员指针"
  },
  {
    "id": "creating pointer to member of type void",
    "pattern": "creating pointer to member of type void",
    "replacement": "创建指向 void 类型的成员指针"
  },
  {
    "id": "%qD is instantiated for an empty pack",
    "pattern": "'(.+?)' is instantiated for an empty pack",
    "replacement": "'$1' 使用空形参包实例化"
  },
  {
    "id": "%qT is not a class, struct, or union type",
    "pattern": "'(.+?)' is not a class, struct, or union type",
    "replacement": "'$1' 不是类、结构体或联合体类型"
  },
  {
    "id": "%qT resolves to %qT, which is not an enumeration type",
    "pattern": "'(.+?)' resolves to '(.+?)', which is not an enumeration type",
    "replacement": "'$1' 被解析为非枚举类型 '$2'"
  },
  {
    "id": "%qT resolves to %qT, which is not a class type",
    "pattern": "'(.+?)' resolves to '(.+?)', which is not a class type",
    "replacement": "'$1' 被解析为非类类型 '$2'"
  },
  {
    "id": "use of %qs in template",
    "pattern": "use of '(.+?)' in template",
    "replacement": "在模板中使用 '$1'"
  },
  {
    "id": "qualifying type %qT does not match destructor name ~%qT",
    "pattern": "qualifying type '(.+?)' does not match destructor name ~'(.+?)'",
    "replacement": "带限定的类型 '$1' 不匹配析构函数名 ~'$2'"
  },
  {
    "id": "dependent-name %qE is parsed as a non-type, but instantiation yields a type",
    "pattern": "dependent-name '(.+?)' is parsed as a non-type, but instantiation yields a type",
    "replacement": "待决名 '$1' 被解析为非类型，但实例化却产生了一个类型"
  },
  {
    "id": "say %<typename %E%> if a type is meant",
    "pattern": "say 'typename (.+?)' if a type is meant",
    "replacement": "如果你认为它是类型，请使用 'typename $1'"
  },
  {
    "id": "initializer for %q#D expands to an empty list of expressions",
    "pattern": "initializer for '(.+?)' expands to an empty list of expressions",
    "replacement": "'$1' 的初始化器展开为空的表达式列表"
  },
  {
    "id": "using invalid field %qD",
    "pattern": "using invalid field '(.+?)'",
    "replacement": "使用无效字段 '$1'"
  },
  {
    "id": "invalid use of pack expansion expression",
    "pattern": "invalid use of pack expansion expression",
    "replacement": "对包展开表达式的无效使用"
  },
  {
    "id": "use %<...%> to expand argument pack",
    "pattern": "use '\\.\\.\\.' to expand argument pack",
    "replacement": "使用 '...' 来展开实参包"
  },
  {
    "id": "empty initializer in lambda init-capture",
    "pattern": "empty initializer in lambda init-capture",
    "replacement": "lambda 初始化闭包中出现空初始化器"
  },
  {
    "id": "%qD was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation",
    "pattern": "'(.+?)' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation",
    "replacement": "'$1' 未被声明在此作用域，且在此实例化点处没有通过实参依赖查找找到任何声明"
  },
  {
    "id": "declarations in dependent base %qT are not found by unqualified lookup",
    "pattern": "declarations in dependent base '(.+?)' are not found by unqualified lookup",
    "replacement": "依赖基类 '$1' 中的声明在无限定查找中未找到"
  },
  {
    "id": "use %<this->%D%> instead",
    "pattern": "use 'this->(.+?)' instead",
    "replacement": "使用 'this->$1' 代替"
  },
  {
    "id": "use %<%T::%D%> instead",
    "pattern": "use '(.+?)::(.+?)' instead",
    "replacement": "使用 '$1::$2' 代替"
  },
  {
    "id": "%qD declared here, later in the translation unit",
    "pattern": "'(.+?)' declared here, later in the translation unit",
    "replacement": "'$1' 在此声明（此翻译单元的稍后位置）"
  },
  {
    "id": "wrong number of arguments to %<__builtin_convertvector%>",
    "pattern": "wrong number of arguments to '__builtin_convertvector'",
    "replacement": "传递给 '__builtin_convertvector' 的实参个数错误"
  },
  {
    "id": "%qT is not a class or namespace",
    "pattern": "'(.+?)' is not a class or namespace",
    "replacement": "'$1' 不是类或命名空间"
  },
  {
    "id": "%qT is/uses unnamed type",
    "pattern": "'(.+?)' is/uses unnamed type",
    "replacement": "'$1' 是无名类型，或使用了无名类型"
  },
  {
    "id": "template argument for %qD uses local type %qT",
    "pattern": "template argument for '(.+?)' uses local type '(.+?)'",
    "replacement": "'$1' 的模板实参使用了局部类型 '$2'"
  },
  {
    "id": "%qT is a variably modified type",
    "pattern": "'(.+?)' is a variably modified type",
    "replacement": "'$1' 是一个可变修改类型"
  },
  {
    "id": "integral expression %qE is not constant",
    "pattern": "integral expression '(.+?)' is not constant",
    "replacement": "整型表达式 '$1' 不是常量"
  },
  {
    "id": "  trying to instantiate %qD",
    "pattern": "  trying to instantiate '(.+?)'",
    "replacement": "  试图实例化 '$1'"
  },
  {
    "id": "ambiguous template instantiation for %q#T",
    "pattern": "ambiguous template instantiation for '(.+?)'",
    "replacement": "'$1' 的模板实例化有歧义"
  },
  {
    "id": "explicit instantiation of non-template %q#D",
    "pattern": "explicit instantiation of non-template '(.+?)'",
    "replacement": "对非模板 '$1' 的显式实例化"
  },
  {
    "id": "explicit instantiation of variable concept %q#D",
    "pattern": "explicit instantiation of variable concept '(.+?)'",
    "replacement": "对变量概念 '$1' 的显式实例化"
  },
  {
    "id": "explicit instantiation of function concept %q#D",
    "pattern": "explicit instantiation of function concept '(.+?)'",
    "replacement": "对函数概念 '$1' 的显式实例化"
  },
  {
    "id": "%qD is not a static data member of a class template",
    "pattern": "'(.+?)' is not a static data member of a class template",
    "replacement": "'$1' 不是类模板的静态数据成员"
  },
  {
    "id": "no matching template for %qD found",
    "pattern": "no matching template for '(.+?)' found",
    "replacement": "没有找到与 '$1' 匹配的模板"
  },
  {
    "id": "type %qT for explicit instantiation %qD does not match declared type %qT",
    "pattern": "type '(.+?)' for explicit instantiation '(.+?)' does not match declared type '(.+?)'",
    "replacement": "用于显式实例化 '$2' 的类型 '$1' 与其所声明的类型 '$3' 不匹配"
  },
  {
    "id": "explicit instantiation of %q#D",
    "pattern": "explicit instantiation of '(.+?)'",
    "replacement": "对 '$1' 的显式实例化"
  },
  {
    "id": "duplicate explicit instantiation of %q#D",
    "pattern": "duplicate explicit instantiation of '(.+?)'",
    "replacement": "对 '$1' 重复的显式实例化"
  },
  {
    "id": "ISO C++ 1998 forbids the use of %<extern%> on explicit instantiations",
    "pattern": "ISO C\\+\\+ 1998 forbids the use of 'extern' on explicit instantiations",
    "replacement": "ISO C++ 1998 禁止在显式实例化时使用 'extern'"
  },
  {
    "id": "storage class %qD applied to template instantiation",
    "pattern": "storage class '(.+?)' applied to template instantiation",
    "replacement": "为模板实例化应用了存储类 '$1'"
  },
  {
    "id": "explicit instantiation of non-class template %qD",
    "pattern": "explicit instantiation of non-class template '(.+?)'",
    "replacement": "对非类模板类型 '$1' 显式实例化"
  },
  {
    "id": "explicit instantiation of non-template type %qT",
    "pattern": "explicit instantiation of non-template type '(.+?)'",
    "replacement": "对非模板类型 '$1' 显式实例化"
  },
  {
    "id": "explicit instantiation of %q#T before definition of template",
    "pattern": "explicit instantiation of '(.+?)' before definition of template",
    "replacement": "'$1' 的显式实例化出现在其模板定义之前"
  },
  {
    "id": "ISO C++ forbids the use of %qE on explicit instantiations",
    "pattern": "ISO C\\+\\+ forbids the use of '(.+?)' on explicit instantiations",
    "replacement": "ISO C++ 禁止在显式实例化时使用 '(.+?)'"
  },
  {
    "id": "exception specification of %qD depends on itself",
    "pattern": "exception specification of '(.+?)' depends on itself",
    "replacement": "'$1' 的异常说明依赖于其自身"
  },
  {
    "id": "explicit instantiation of %qD but no definition available",
    "pattern": "explicit instantiation of '(.+?)' but no definition available",
    "replacement": "显式实例化了 '(.+?)'，但没有可用的定义"
  },
  {
    "id": "template instantiation depth exceeds maximum of %d instantiating %q+D, possibly from virtual table generation (use %<-ftemplate-depth=%> to increase the maximum)",
    "pattern": "template instantiation depth exceeds maximum of (\\d+) instantiating %q+D, possibly from virtual table generation \\(use '-ftemplate-depth=' to increase the maximum\\)",
    "replacement": "在实例化 $2 时模板实例化深度超过了最大值 $1，这可能是生成虚表导致的（使用 '-ftemplate-depth=' 来增加最大值）"
  },
  {
    "id": "non-type template parameters of deduced class type only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "non-type template parameters of deduced class type only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "推导类类型的非类型模板形参仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "%qT is not a valid type for a template non-type parameter because it is not structural",
    "pattern": "'(.+?)' is not a valid type for a template non-type parameter because it is not structural",
    "replacement": "'$1' 不是非类型模板形参的有效类型，因为它不是结构化的"
  },
  {
    "id": "non-type template parameters of class type only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "non-type template parameters of class type only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "类类型的非类型模板实参仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "invalid template non-type parameter",
    "pattern": "invalid template non-type parameter",
    "replacement": "无效的非类型模板形参"
  },
  {
    "id": "%q#T is not a valid type for a template non-type parameter",
    "pattern": "'(.+?)' is not a valid type for a template non-type parameter",
    "replacement": "'$1' 不是非类型模板形参的有效类型"
  },
  {
    "id": "keyword %<template%> not allowed in declarator-id",
    "pattern": "keyword 'template' not allowed in declarator-id",
    "replacement": "声明符标识中不能出现 'template' 关键字"
  },
  {
    "id": "a concept cannot be constrained",
    "pattern": "a concept cannot be constrained",
    "replacement": "概念不能被约束"
  },
  {
    "id": "concept %qE not in namespace scope",
    "pattern": "concept '(.+?)' not in namespace scope",
    "replacement": "概念 '$1' 不在命名空间作用域"
  },
  {
    "id": "deducing from brace-enclosed initializer list requires %<#include <initializer_list>%>",
    "pattern": "deducing from brace-enclosed initializer list requires '#include <initializer_list>'",
    "replacement": "从花括号初始化器列表推导需要 '#include <initializer_list>'"
  },
  {
    "id": "non-deducible template %qT used without template arguments",
    "pattern": "non-deducible template '(.+?)' used without template arguments",
    "replacement": "不可推导的模板 '$1' 使用时未给出模板实参"
  },
  {
    "id": "alias template deduction only available with %<-std=c++20%> or %<-std=gnu++20%>",
    "pattern": "alias template deduction only available with '-std=c\\+\\+20' or '-std=gnu\\+\\+20'",
    "replacement": "别名模板推导仅在 '-std=c++20' 或 '-std=gnu++20' 下可用"
  },
  {
    "id": "cannot deduce template arguments for copy-initialization of %qT, as it has no non-explicit deduction guides or user-declared constructors",
    "pattern": "cannot deduce template arguments for copy-initialization of '(.+?)', as it has no non-explicit deduction guides or user-declared constructors",
    "replacement": "不能从 '$1' 的复制初始化推导模板实参，因为它没有显式的推导指引或者用户声明的构造函数"
  },
  {
    "id": "cannot deduce template arguments of %qT, as it has no viable deduction guides",
    "pattern": "cannot deduce template arguments of '(.+?)', as it has no viable deduction guides",
    "replacement": "不能推导 '$1' 的模板实参，因为它没有可行的推导指引"
  },
  {
    "id": "class template argument deduction failed:",
    "pattern": "class template argument deduction failed:",
    "replacement": "类模板实参推导失败："
  },
  {
    "id": "explicit deduction guides not considered for copy-initialization",
    "pattern": "explicit deduction guides not considered for copy-initialization",
    "replacement": "复制初始化不考虑显式推导指引"
  },
  {
    "id": "class template argument deduction for %qT failed: explicit deduction guide selected in copy-list-initialization",
    "pattern": "class template argument deduction for '(.+?)' failed: explicit deduction guide selected in copy-list-initialization",
    "replacement": "'$1' 的类模板实参推导失败：复制列表初始化选择了显式推导指引"
  },
  {
    "id": "explicit deduction guide declared here",
    "pattern": "explicit deduction guide declared here",
    "replacement": "显式推导指引在此声明"
  },
  {
    "id": "%qT may not intend to support class template argument deduction",
    "pattern": "'(.+?)' may not intend to support class template argument deduction",
    "replacement": "'$1' 不能用于类模板实参推导"
  },
  {
    "id": "add a deduction guide to suppress this warning",
    "pattern": "add a deduction guide to suppress this warning",
    "replacement": "添加一个推导指引来避免显示此警告"
  },
  {
    "id": "direct-list-initialization of %<auto%> requires exactly one element",
    "pattern": "direct-list-initialization of 'auto' requires exactly one element",
    "replacement": "'auto' 的直接列表初始化仅需要一个元素"
  },
  {
    "id": "for deduction to %<std::initializer_list%>, use copy-list-initialization (i.e. add %<=%> before the %<{%>)",
    "pattern": "for deduction to 'std::initializer_list', use copy-list-initialization \\(i.e. add '=' before the '{'\\)",
    "replacement": "使用复制列表初始化来推导到 'std::initializer_list'（即在 '{' 后添加 '='）"
  },
  {
    "id": "unable to deduce lambda return type from %qE",
    "pattern": "unable to deduce lambda return type from '(.+?)'",
    "replacement": "无法从 '$1' 推导 lambda 返回类型"
  },
  {
    "id": "unable to deduce %qT from %qE",
    "pattern": "unable to deduce '(.+?)' from '(.+?)'",
    "replacement": "无法从 '$2' 推导 '$1'"
  },
  {
    "id": "placeholder constraints not satisfied",
    "pattern": "placeholder constraints not satisfied",
    "replacement": "占位符约束未满足"
  },
  {
    "id": "deduced initializer does not satisfy placeholder constraints",
    "pattern": "deduced initializer does not satisfy placeholder constraints",
    "replacement": "推导得到的初始化器不满足占位符约束"
  },
  {
    "id": "deduced return type does not satisfy placeholder constraints",
    "pattern": "deduced return type does not satisfy placeholder constraints",
    "replacement": "推导得到的返回类型不满足占位符约束"
  },
  {
    "id": "deduced expression type does not satisfy placeholder constraints",
    "pattern": "deduced expression type does not satisfy placeholder constraints",
    "replacement": "推到得到的表达式类型不满足占位符约束"
  },
  {
    "id": "invalid use of %qT in template argument",
    "pattern": "invalid use of '(.+?)' in template argument",
    "replacement": "模板实参中非法地使用了 '$1'"
  },
  {
    "id": "cannot use %<typeid%> with %<-fno-rtti%>",
    "pattern": "cannot use 'typeid' with '-fno-rtti'",
    "replacement": "不能在指定 '-fno-rtti' 时使用 'typeid'"
  },
  {
    "id": "must %<#include <typeinfo>%> before using %<typeid%>",
    "pattern": "must '#include <typeinfo>' before using 'typeid'",
    "replacement": "在使用 'typeid' 之前必须先 '#include <typeinfo>'"
  },
  {
    "id": "cannot create type information for type %qT because it involves types of variable size",
    "pattern": "cannot create type information for type '(.+?)' because it involves types of variable size",
    "replacement": "无法为类型 '$1' 创建类型信息，因为它引入了大小可变的类型"
  },
  {
    "id": "%<typeid%> of qualified function type %qT",
    "pattern": "'typeid' of qualified function type '(.+?)'",
    "replacement": "有限定的函数类型 '$1' 的 'typeid'"
  },
  {
    "id": "%<dynamic_cast<%#T>(%#D)%> can never succeed",
    "pattern": "'dynamic_cast<(.+?)>\\((.+?)\\)' can never succeed",
    "replacement": "'dynamic_cast<$1>($2)' 永远不会成功"
  },
  {
    "id": "%<dynamic_cast%> not permitted with %<-fno-rtti%>",
    "pattern": "'dynamic_cast' not permitted with '-fno-rtti'",
    "replacement": "不能在指定 '-fno-rtti' 时使用 'dynamic_cast'"
  },
  {
    "id": "cannot %<dynamic_cast%> %qE (of type %q#T) to type %q#T (%s)",
    "pattern": "cannot 'dynamic_cast' '(.+?)' \\(of type '(.+?)'\\) to type '(.+?)' \\((.*?)\\)",
    "replacement": "不能将 '$2' 类型的 '$1' 'dynamic_cast' 到类型 '$3' ($4)"
  },
  {
    "id": "%qT is an ambiguous base of %qT",
    "pattern": "'(.+?)' is an ambiguous base of '(.+?)'",
    "replacement": "'$1' 是 '$2' 的有歧义基类"
  },
  {
    "id": "%qT is an inaccessible base of %qT",
    "pattern": "'(.+?)' is an inaccessible base of '(.+?)'",
    "replacement": "'$1' 是 '$2' 的不可访问基类"
  },
  {
    "id": "looser exception specification on overriding virtual function %q+#F",
    "pattern": "looser exception specification on overriding virtual function '(.+?)'",
    "replacement": "覆盖虚函数 '$1' 时给出了更宽松的异常说明"
  },
  {
    "id": "overridden function is %q#F",
    "pattern": "overridden function is '(.+?)'",
    "replacement": "被覆盖的函数是 '$1'"
  },
  {
    "id": "invalid covariant return type for %q#D",
    "pattern": "invalid covariant return type for '(.+?)'",
    "replacement": "'$1' 的协变返回类型无效"
  },
  {
    "id": "conflicting return type specified for %q+#D",
    "pattern": "conflicting return type specified for '(.+?)'",
    "replacement": "为 '$1' 指定了冲突的返回类型"
  },
  {
    "id": "conflicting type attributes specified for %q+#D",
    "pattern": "conflicting type attributes specified for '(.+?)'",
    "replacement": "为 '$1' 指定了冲突的特性"
  },
  {
    "id": "%<consteval%> function %q+D overriding non-%<consteval%> function",
    "pattern": "'consteval' function '(.+?)' overriding non-'consteval' function",
    "replacement": "'consteval' 函数 '$1' 覆盖了非 'consteval' 函数"
  },
  {
    "id": "non-%<consteval%> function %q+D overriding %<consteval%> function",
    "pattern": "non-'consteval' function '(.+?)' overriding 'consteval' function",
    "replacement": "非 'consteval' 函数 '$1' 覆盖了 'consteval' 函数"
  },
  {
    "id": "%qD declared %<transaction_safe_dynamic%>",
    "pattern": "'(.+?)' declared 'transaction_safe_dynamic'",
    "replacement": "'$1' 被声明为 'transaction_safe_dynamic'"
  },
  {
    "id": "overriding %qD declared %<transaction_safe%>",
    "pattern": "overriding '(.+?)' declared 'transaction_safe'",
    "replacement": "覆盖了声明为 'transcation_safe' 的 '$1'"
  },
  {
    "id": "deleted function %q+D overriding non-deleted function",
    "pattern": "deleted function '(.+?)' overriding non-deleted function",
    "replacement": "已删除的函数 '$1' 覆盖了未删除的函数"
  },
  {
    "id": "non-deleted function %q+D overriding deleted function",
    "pattern": "non-deleted function '(.+?)' overriding deleted function",
    "replacement": "未删除的函数 '$1' 覆盖了已删除的函数"
  },
  {
    "id": "virtual function %q+D overriding final function",
    "pattern": "virtual function '(.+?)' overriding final function",
    "replacement": "虚函数 '$1' 覆盖了最终函数"
  },
  {
    "id": "%q+#D cannot be declared",
    "pattern": "'(.+?)' cannot be declared",
    "replacement": "无法声明 '$1'"
  },
  {
    "id": "  since %q+#D declared in base class",
    "pattern": "  since '(.+?)' declared in base class",
    "replacement": "因为 '$1' 已在基类中声明"
  },
  {
    "id": "%qs always evaluates to true in %<if constexpr%>",
    "pattern": "'(.+?)' always evaluates to true in 'if constexpr'",
    "replacement": "'if constexpr' 中的 '$1' 总是求值为真"
  },
  {
    "id": "suggest explicit braces around empty body in %<do%> statement",
    "pattern": "suggest explicit braces around empty body in 'do' statement",
    "replacement": "建议在 'do' 的空语句体周围显式地加上花括号"
  },
  {
    "id": "catching polymorphic type %q#T by value",
    "pattern": "catching polymorphic type '(.+?)' by value",
    "replacement": "按值捕捉了多态类型 '$1'"
  },
  {
    "id": "catching type %q#T by value",
    "pattern": "catching type '(.+?)' by value",
    "replacement": "按值捕捉了类型 '$1'"
  },
  {
    "id": "catching non-reference type %q#T",
    "pattern": "catching non-reference type '(.+?)'",
    "replacement": "捕捉了非引用类型 '$1'"
  },
  {
    "id": "type of %<asm%> operand %qE could not be determined",
    "pattern": "type of 'asm' operand '(.+?)' could not be determined",
    "replacement": "无法确定 asm 操作数 '(.+?)' 的类型"
  },
  {
    "id": "%<__label__%> declarations are only allowed in function scopes",
    "pattern": "'__label__' declarations are only allowed in function scopes",
    "replacement": "'__label__' 声明只能出现在函数作用域中"
  },
  {
    "id": "invalid use of member %qD in static member function",
    "pattern": "invalid use of member '(.+?)' in static member function",
    "replacement": "在静态成员函数中非法地使用了 '$1' 成员"
  },
  {
    "id": "%qE missing template arguments",
    "pattern": "'(.+?)' missing template arguments",
    "replacement": "'$1' 缺少模板实参"
  },
  {
    "id": "a statement expression is an insufficient context for overload resolution",
    "pattern": "a statement expression is an insufficient context for overload resolution",
    "replacement": "语句表达式不足以确定重载函数的上下文"
  },
  {
    "id": "cannot call a concept as a function",
    "pattern": "cannot call a concept as a function",
    "replacement": "'不能像函数一样调用概念"
  },
  {
    "id": "arguments to destructor are not allowed",
    "pattern": "arguments to destructor are not allowed",
    "replacement": "不能传递实参给析构函数"
  },
  {
    "id": "%<this%> is unavailable for static member functions",
    "pattern": "'this' is unavailable for static member functions",
    "replacement": "静态成员函数中 'this' 不可用"
  },
  {
    "id": "invalid use of %<this%> in non-member function",
    "pattern": "invalid use of 'this' in non-member function",
    "replacement": "在非成员函数中非法地使用了 'this'"
  },
  {
    "id": "invalid use of %<this%> at top level",
    "pattern": "invalid use of 'this' at top level",
    "replacement": "在顶层非法地使用了 'this'"
  },
  {
    "id": "invalid qualifying scope in pseudo-destructor name",
    "pattern": "invalid qualifying scope in pseudo-destructor name",
    "replacement": "伪析构函数名的限定作用域无效"
  },
  {
    "id": "qualified type %qT does not match destructor name ~%qT",
    "pattern": "qualified type '(.+?)' does not match destructor name ~'(.+?)'",
    "replacement": "带限定的类型 '$1' 不匹配析构函数名 ~'$2'"
  },
  {
    "id": "%qE is not of type %qT",
    "pattern": "'(.+?)' is not of type '(.+?)'",
    "replacement": "'$1' 的类型不是 '$2'"
  },
  {
    "id": "compound literal of non-object type %qT",
    "pattern": "compound literal of non-object type '(.+?)'",
    "replacement": "非对象类型 '$1' 的复合字面常量"
  },
  {
    "id": "template type parameters must use the keyword %<class%> or %<typename%>",
    "pattern": "template type parameters must use the keyword 'class' or 'typename'",
    "replacement": "类型模板形参必须使用 'class' 或 'typename' 关键字"
  },
  {
    "id": "invalid use of type %qT as a default value for a template template-parameter",
    "pattern": "invalid use of type '(.+?)' as a default value for a template template-parameter",
    "replacement": "将类型 '$1' 非法地用作模板模板形参的默认值"
  },
  {
    "id": "invalid default argument for a template template parameter",
    "pattern": "invalid default argument for a template template parameter",
    "replacement": "模板模板形参的默认实参无效"
  },
  {
    "id": "definition of %q#T inside template parameter list",
    "pattern": "definition of '(.+?)' inside template parameter list",
    "replacement": "在模板形参列表中定义了 '$1'"
  },
  {
    "id": "invalid definition of qualified type %qT",
    "pattern": "invalid definition of qualified type '(.+?)'",
    "replacement": "对限定类型 '$1' 的定义无效"
  },
  {
    "id": "invalid base-class specification",
    "pattern": "invalid base-class specification",
    "replacement": "无效的基类说明符"
  },
  {
    "id": "cannot capture member %qD of anonymous union",
    "pattern": "cannot capture member '(.+?)' of anonymous union",
    "replacement": "不能捕获匿名联合体的成员 '$1'"
  },
  {
    "id": "%qD is not captured",
    "pattern": "'(.+?)' is not captured",
    "replacement": "'$1' 未被捕获"
  },
  {
    "id": "the lambda has no capture-default",
    "pattern": "the lambda has no capture-default",
    "replacement": "lambda 没有默认捕获"
  },
  {
    "id": "lambda in local class %q+T cannot capture variables from the enclosing context",
    "pattern": "lambda in local class '(.+?)' cannot capture variables from the enclosing context",
    "replacement": "局部类 '$1' 中的 lambda 不能捕获其所在语境的变量"
  },
  {
    "id": "use of local variable with automatic storage from containing function",
    "pattern": "use of local variable with automatic storage from containing function",
    "replacement": "在包含它的函数中使用具有自动存储期的局部变量"
  },
  {
    "id": "use of parameter from containing function",
    "pattern": "use of parameter from containing function",
    "replacement": "在包含它的函数中使用形参"
  },
  {
    "id": "use of parameter outside function body",
    "pattern": "use of parameter outside function body",
    "replacement": "在函数体外使用形参"
  },
  {
    "id": "missing template arguments",
    "pattern": "missing template arguments",
    "replacement": "缺少模板实参"
  },
  {
    "id": "template parameter %qD of type %qT is not allowed in an integral constant expression because it is not of integral or enumeration type",
    "pattern": "template parameter '(.+?)' of type '(.+?)' is not allowed in an integral constant expression because it is not of integral or enumeration type",
    "replacement": "类型为 '$2' 的模板形参 '$1' 不允许出现在整数表达式中，因为它的不是整数类型或枚举类型"
  },
  {
    "id": "use of class template %qT as expression",
    "pattern": "use of class template '(.+?)' as expression",
    "replacement": "将类模板 '$1' 用作表达式"
  },
  {
    "id": "request for member %qD is ambiguous in multiple inheritance lattice",
    "pattern": "request for member '(.+?)' is ambiguous in multiple inheritance lattice",
    "replacement": "在多继承网格中对 '$1' 成员的请求有歧义"
  },
  {
    "id": "%qD cannot appear in a constant-expression",
    "pattern": "'(.+?)' cannot appear in a constant-expression",
    "replacement": "'$1' 不能出现在常量表达式中"
  },
  {
    "id": "type of %qE is unknown",
    "pattern": "type of '(.+?)' is unknown",
    "replacement": "'$1' 的类型未知"
  },
  {
    "id": "%qT is not an enumeration type",
    "pattern": "'(.+?)' is not an enumeration type",
    "replacement": "'$1' 不是枚举类型"
  },
  {
    "id": "parameter pack %<__bases%> only valid in template declaration",
    "pattern": "parameter pack '__bases' only valid in template declaration",
    "replacement": "形参包 '__bases' 仅在模板声明中可用"
  },
  {
    "id": "cannot apply %<offsetof%> to destructor %<~%T%>",
    "pattern": "cannot apply 'offsetof' to destructor '~(.+?)'",
    "replacement": "不能为析构函数 '~$1' 应用 'offsetof'"
  },
  {
    "id": "cannot apply %<offsetof%> to member function %qD",
    "pattern": "cannot apply 'offsetof' to member function '(.+?)'",
    "replacement": "不能为成员函数 '$1' 应用 'offsetof'"
  },
  {
    "id": "cannot apply %<offsetof%> to member function",
    "pattern": "cannot apply 'offsetof' to member function",
    "replacement": "不能为成员函数应用 'offsetof'"
  },
  {
    "id": "cannot apply %<offsetof%> to an enumerator %qD",
    "pattern": "cannot apply 'offsetof' to an enumerator '(.+?)'",
    "replacement": "不能为枚举项 '$1' 应用 'offsetof'"
  },
  {
    "id": "%<offsetof%> within non-standard-layout type %qT is conditionally-supported",
    "pattern": "'offsetof' within non-standard-layout type '(.+?)' is conditionally-supported",
    "replacement": "非标准布局类型 '$1' 中的 'offsetof' 是条件性支持的"
  },
  {
    "id": "%<this%> allowed in OpenMP only in %<declare simd%> clauses",
    "pattern": "'this' allowed in OpenMP only in 'declare simd' clauses",
    "replacement": "OpenMP 中仅在 'declare simd' 子句中允许 'this'"
  },
  {
    "id": "user defined reduction lookup is ambiguous",
    "pattern": "user defined reduction lookup is ambiguous",
    "replacement": "用户定义的归约查找有歧义"
  },
  {
    "id": "%qE in %<reduction%> clause is a zero size array",
    "pattern": "'(.+?)' in 'reduction' clause is a zero size array",
    "replacement": "'reduction' 子句中的 '$1' 是零长度数组"
  },
  {
    "id": "%qE has const type for %<reduction%>",
    "pattern": "'(.+?)' has const type for 'reduction'",
    "replacement": "'reduction' 中的 '$1' 具有只读类型"
  },
  {
    "id": "user defined reduction with constructor initializer for base class %qT",
    "pattern": "user defined reduction with constructor initializer for base class '(.+?)'",
    "replacement": "基类 '$1' 中带有构造函数初始化器的用户定义归约"
  },
  {
    "id": "linear clause with %qs modifier applied to non-reference variable with %qT type",
    "pattern": "linear clause with '(.+?)' modifier applied to non-reference variable with '(.+?)' type",
    "replacement": "带 '$1' 修饰符的线性子句应用于 '$2' 类型的非引用变量上"
  },
  {
    "id": "linear clause applied to non-integral non-pointer variable with %qT type",
    "pattern": "linear clause applied to non-integral non-pointer variable with '(.+?)' type",
    "replacement": "线性子句应用于 '$1' 类型的非整数、非指针变量上"
  },
  {
    "id": "linear step expression must be integral",
    "pattern": "linear step expression must be integral",
    "replacement": "线性不仅表达式必须是整数类型"
  },
  {
    "id": "%qD is not a variable in clause %qs",
    "pattern": "'(.+?)' is not a variable in clause '(.+?)'",
    "replacement": "'$1' 不是 '$2' 子句中的变量"
  },
  {
    "id": "%qD is not a variable in clause %<firstprivate%>",
    "pattern": "'(.+?)' is not a variable in clause 'firstprivate'",
    "replacement": "'$1' 不是 'firstprivate' 子句中的变量"
  },
  {
    "id": "%qD is not a variable in clause %<lastprivate%>",
    "pattern": "'(.+?)' is not a variable in clause 'lastprivate'",
    "replacement": "'$1' 不是 'lastprivate' 子句中的变量"
  },
  {
    "id": "%<gang%> static expression must be integral",
    "pattern": "'gang' static expression must be integral",
    "replacement": "'gang' 静态变量必须是整数类型"
  },
  {
    "id": "%<gang%> static value must be positive",
    "pattern": "'gang' static value must be positive",
    "replacement": "'gang' 静态值必须是正的"
  },
  {
    "id": "%<gang%> num expression must be integral",
    "pattern": "'gang' num expression must be integral",
    "replacement": "'gang' 数量表达式必须是整数类型"
  },
  {
    "id": "%<vector%> length expression must be integral",
    "pattern": "'vector' length expression must be integral",
    "replacement": "'vector' 长度表达式必须是整数类型"
  },
  {
    "id": "%<worker%> num expression must be integral",
    "pattern": "'worker' num expression must be integral",
    "replacement": "'worker' 数量表达式必须是整数类型"
  },
  {
    "id": "%<gang%> num value must be positive",
    "pattern": "'gang' num value must be positive",
    "replacement": "'gang' 数量值必须是正的"
  },
  {
    "id": "%<vector%> length value must be positive",
    "pattern": "'vector' length value must be positive",
    "replacement": "'vector' 长度值必须是正的"
  },
  {
    "id": "%<worker%> num value must be positive",
    "pattern": "'worker' num value must be positive",
    "replacement": "'worker' 数量值必须是正的"
  },
  {
    "id": "schedule chunk size expression must be integral",
    "pattern": "schedule chunk size expression must be integral",
    "replacement": "调度块大小表达式必须是整数类型"
  },
  {
    "id": "%qs length expression must be integral",
    "pattern": "'(.+?)' length expression must be integral",
    "replacement": "'$1' 长度表达式必须是整数类型"
  },
  {
    "id": "%qs length expression must be positive constant integer expression",
    "pattern": "'(.+?)' length expression must be positive constant integer expression",
    "replacement": "'$1' 长度表达式必须是正整数常量表达式"
  },
  {
    "id": "%<async%> expression must be integral",
    "pattern": "'async' expression must be integral",
    "replacement": "'async' 表达式必须是整数类型"
  },
  {
    "id": "%<thread_limit%> expression must be integral",
    "pattern": "'thread_limit' expression must be integral",
    "replacement": "'thread_limit' 表达式必须是整数类型"
  },
  {
    "id": "%<device%> id must be integral",
    "pattern": "'device' id must be integral",
    "replacement": "'device' 标识必须是整数类型"
  },
  {
    "id": "%<dist_schedule%> chunk size expression must be integral",
    "pattern": "'dist_schedule' chunk size expression must be integral",
    "replacement": "'dist_schedule' 块大小表达式必须为整型"
  },
  {
    "id": "%qD is not a variable in %<aligned%> clause",
    "pattern": "'(.+?)' is not a variable in 'aligned' clause",
    "replacement": "'$1' 不是 'aligned' 子句中的变量"
  },
  {
    "id": "%qE in %<aligned%> clause is neither a pointer nor an array nor a reference to pointer or array",
    "pattern": "'(.+?)' in 'aligned' clause is neither a pointer nor an array nor a reference to pointer or array",
    "replacement": "'aligned' 子句中的 '$1' 既不是指针、也不是数组，也不是到指针或数组的引用"
  },
  {
    "id": "%qD appears more than once in %<aligned%> clauses",
    "pattern": "'(.+?)' appears more than once in 'aligned' clauses",
    "replacement": "'$1' 在 'aligned' 子句中多于一次出现"
  },
  {
    "id": "%<aligned%> clause alignment expression must be integral",
    "pattern": "'aligned' clause alignment expression must be integral",
    "replacement": "'aligned' 子句对齐表达式必须是整数类型"
  },
  {
    "id": "%qD is not a variable in %<nontemporal%> clause",
    "pattern": "'(.+?)' is not a variable in 'nontemporal' clause",
    "replacement": "'$1' 不是 'nontemporal' 子句中的变量"
  },
  {
    "id": "%qD appears more than once in %<nontemporal%> clauses",
    "pattern": "'(.+?)' appears more than once in 'nontemporal' clauses",
    "replacement": "'$1' 在 'nontemporal' 子句中多于一次出现"
  },
  {
    "id": "%<this%> not allowed in %<allocate%> clause",
    "pattern": "'this' not allowed in 'allocate' clause",
    "replacement": "'allocate' 子句中不允许出现 'this'"
  },
  {
    "id": "%qD is not a variable in %<allocate%> clause",
    "pattern": "'(.+?)' is not a variable in 'allocate' clause",
    "replacement": "'$1' 不是 'allocate' 子句中的变量"
  },
  {
    "id": "%qD appears more than once in %<allocate%> clauses",
    "pattern": "'(.+?)' appears more than once in 'allocate' clauses",
    "replacement": "'(.+?)' 在 'allocate' 子句中多次出现"
  },
  {
    "id": "%qD is not lvalue expression nor array section in %<depend%> clause",
    "pattern": "'(.+?)' is not lvalue expression nor array section in 'depend' clause",
    "replacement": "'depend' 子句中的 '$1' 既不是左值也不是数组节"
  },
  {
    "id": "template %qE in clause %qs",
    "pattern": "template '(.+?)' in clause '(.+?)'",
    "replacement": "子句 '$2' 中出现模板 '$1'"
  },
  {
    "id": "overloaded function name %qE in clause %qs",
    "pattern": "overloaded function name '(.+?)' in clause '(.+?)'",
    "replacement": "子句 '$2' 中出现重载函数名 '$1'"
  },
  {
    "id": "%<grainsize%> expression must be integral",
    "pattern": "'grainsize' expression must be integral",
    "replacement": "'grainsize' 表达式必须是整数类型"
  },
  {
    "id": "%<priority%> expression must be integral",
    "pattern": "'priority' expression must be integral",
    "replacement": "'priority' 表达式必须是整数类型"
  },
  {
    "id": "%<hint%> expression must be integral",
    "pattern": "'hint' expression must be integral",
    "replacement": "'hint' 表达式必须是整数类型"
  },
  {
    "id": "%<hint%> expression must be constant integer expression",
    "pattern": "'hint' expression must be constant integer expression",
    "replacement": "'hint' 表达式必须是整数常量表达式"
  },
  {
    "id": "%qs variable is neither a pointer nor reference to pointer",
    "pattern": "'(.+?)' variable is neither a pointer nor reference to pointer",
    "replacement": "'$1' 变量既不是指针也不是到指针的引用"
  },
  {
    "id": "%qs variable is neither a pointer, nor an array nor reference to pointer or array",
    "pattern": "'(.+?)' variable is neither a pointer, nor an array nor reference to pointer or array",
    "replacement": "'$1' 既不是指针、也不是数组，也不是到指针或数组的引用"
  },
  {
    "id": "%<tile%> argument needs integral type",
    "pattern": "'tile' argument needs integral type",
    "replacement": "'tile 实参需要整数类型"
  },
  {
    "id": "%<const%> qualified %qE without %<mutable%> member may appear only in %<shared%> or %<firstprivate%> clauses",
    "pattern": "'const' qualified '(.+?)' without 'mutable' member may appear only in 'shared' or 'firstprivate' clauses",
    "replacement": "不带 'mutable' 的 'const' 限定 '$1' 成员只能出现在 'shared' 或 'firstprivate' 子句中"
  },
  {
    "id": "%<threadprivate%> %qD is not file, namespace or block scope variable",
    "pattern": "'threadprivate' '(.+?)' is not file, namespace or block scope variable",
    "replacement": "'threadprivate' '$1' 不是一个文件、命名空间或块作用域变量"
  },
  {
    "id": "%<threadprivate%> %qE directive not in %qT definition",
    "pattern": "'threadprivate' '(.+?)' directive not in '(.+?)' definition",
    "replacement": "'threadprivate' '$1' 指令不在 '$2' 定义中"
  },
  {
    "id": "difference between %qE and %qD does not have integer type",
    "pattern": "difference between '(.+?)' and '(.+?)' does not have integer type",
    "replacement": "'$1' 和 '$2' 之间的差不具有整数类型"
  },
  {
    "id": "%<#pragma omp simd%> used with class iteration variable %qE",
    "pattern": "'#pragma omp simd' used with class iteration variable '(.+?)'",
    "replacement": "'#pragma omp simd' 使用了类迭代变量 '$1'"
  },
  {
    "id": "%<#pragma omp atomic update%> uses two different expressions for memory",
    "pattern": "'#pragma omp atomic update' uses two different expressions for memory",
    "replacement": "'#pragma omp atomic update' 使用了两个不同的变量用于内存"
  },
  {
    "id": "static assertion failed: %s",
    "pattern": "static assertion failed: (.*?)",
    "replacement": "静态断言失败：$1"
  },
  {
    "id": "%qE evaluates to false",
    "pattern": "'(.+?)' evaluates to false",
    "replacement": "'$1' 求值为假"
  },
  {
    "id": "non-constant condition for static assertion",
    "pattern": "non-constant condition for static assertion",
    "replacement": "静态断言中出现非常量条件"
  },
  {
    "id": "argument to %<decltype%> must be an expression",
    "pattern": "argument to 'decltype' must be an expression",
    "replacement": "'decltype' 的实参必须是一个表达式"
  },
  {
    "id": "%<decltype%> cannot resolve address of overloaded function",
    "pattern": "'decltype' cannot resolve address of overloaded function",
    "replacement": "'decltype' 无法解析重载函数的地址"
  },
  {
    "id": "operand of fold expression has no unexpanded parameter packs",
    "pattern": "operand of fold expression has no unexpanded parameter packs",
    "replacement": "折叠表达式的操作数没有未展开的形参包"
  },
  {
    "id": "both arguments in binary fold have unexpanded parameter packs",
    "pattern": "both arguments in binary fold have unexpanded parameter packs",
    "replacement": "折叠二元表达式的两个实参都含有未展开的形参包"
  },
  {
    "id": "no unexpanded parameter packs in binary fold",
    "pattern": "no unexpanded parameter packs in binary fold",
    "replacement": "折叠二元表达式没有未展开的形参包"
  },
  {
    "id": "non-pointer argument to %<__builtin_launder%>",
    "pattern": "non-pointer argument to '__builtin_launder'",
    "replacement": "传递给 '__builtin_launder' 非指针实参"
  },
  {
    "id": "%<__builtin_bit_cast%> destination type %qT is an array type",
    "pattern": "'__builtin_bit_cast' destination type '(.+?)' is an array type",
    "replacement": "'__builtin_bit_cast' 目标类型 '$1' 是数组类型"
  },
  {
    "id": "%<__builtin_bit_cast%> destination type %qT is not trivially copyable",
    "pattern": "'__builtin_bit_cast' destination type '(.+?)' is not trivially copyable",
    "replacement": "'__builtin_bit_cast' 目标类型 '$1' 不可平凡复制"
  },
  {
    "id": "%<__builtin_bit_cast%> source type %qT is not trivially copyable",
    "pattern": "'__builtin_bit_cast' source type '(.+?)' is not trivially copyable",
    "replacement": "'__builtin_bit_cast' 源类型 '$1' 不可平凡复制"
  },
  {
    "id": "%<__builtin_bit_cast%> source size %qE not equal to destination type size %qE",
    "pattern": "'__builtin_bit_cast' source size '(.+?)' not equal to destination type size '(.+?)'",
    "replacement": "'__builtin_bit_cast' 源大小 '$1' 不等于目标类型大小 '$1'"
  },
  {
    "id": "%qV qualifiers cannot be applied to %qT",
    "pattern": "'(.+?)' qualifiers cannot be applied to '(.+?)'",
    "replacement": "'$1' 限定符不能应用到 '(.+?)' 上"
  },
  {
    "id": "statement-expression in a constant expression",
    "pattern": "statement-expression in a constant expression",
    "replacement": "常量表达式中出现语句表达式"
  },
  {
    "id": "%<-fabi-version=13%> (GCC 8.2) fixes the calling convention for %qT, which was accidentally changed in 8.1",
    "pattern": "'-fabi-version=13' \\(GCC 8.2\\) fixes the calling convention for '(.+?)', which was accidentally changed in 8.1",
    "replacement": "'-fabi-version=13' (GCC 8.2) 修正了 '$1' 的调用约定，它在 8.1 版本中被意外地改变"
  },
  {
    "id": "%<-fabi-version=12%> (GCC 8.1) accidentally changes the calling convention for %qT",
    "pattern": "'-fabi-version=12' \\(GCC 8.1\\) accidentally changes the calling convention for '(.+?)'",
    "replacement": "'-fabi-version=12' (GCC 8.1) 意外地改变了 '$1' 的调用约定"
  },
  {
    "id": " declared here",
    "pattern": " declared here",
    "replacement": " 在此声明"
  },
  {
    "id": "the calling convention for %qT changes in %<-fabi-version=13%> (GCC 8.2)",
    "pattern": "the calling convention for '(.+?)' changes in '-fabi-version=13' \\(GCC 8.2\\)",
    "replacement": "'$1' 的调用约定在 '-fabi-version=13' (GCC 8.2) 中改变"
  },
  {
    "id": " because all of its copy and move constructors are deleted",
    "pattern": " because all of its copy and move constructors are deleted",
    "replacement": " 因为它所有的复制构造函数和移动构造函数都被删除"
  },
  {
    "id": "base class %qT is not public",
    "pattern": "base class '(.+?)' is not public",
    "replacement": "基类 '$1' 不是公开的"
  },
  {
    "id": "%qD is not public",
    "pattern": "'(.+?)' is not public",
    "replacement": "'$1' 不是公开的"
  },
  {
    "id": "%qD is mutable",
    "pattern": "'(.+?)' is mutable",
    "replacement": "'$1' 是可变的"
  },
  {
    "id": "%qD has a non-structural type",
    "pattern": "'(.+?)' has a non-structural type",
    "replacement": "'$1' 不是结构化类型"
  },
  {
    "id": "%qE attribute argument must be a string constant",
    "pattern": "'(.+?)' attribute argument must be a string constant",
    "replacement": "'$1' 特性实参必须是字符串常量"
  },
  {
    "id": "%qE attribute can only be applied to functions or to class or enumeration types",
    "pattern": "'(.+?)' attribute can only be applied to functions or to class or enumeration types",
    "replacement": "'$1' 特性只能应用于函数、类或枚举类型"
  },
  {
    "id": "%qE attribute can only be applied to non-static data members",
    "pattern": "'(.+?)' attribute can only be applied to non-static data members",
    "replacement": "'$1' 特性只能应用于非静态数据成员"
  },
  {
    "id": "%qE attribute cannot be applied to a bit-field",
    "pattern": "'(.+?)' attribute cannot be applied to a bit-field",
    "replacement": "'$1' 特性只能应用于位域"
  },
  {
    "id": "%qE attribute takes no arguments",
    "pattern": "'(.+?)' attribute takes no arguments",
    "replacement": "'$1' 特性不接受实参"
  },
  {
    "id": "ISO C++ %qE attribute does not apply to functions; treating as %<[[gnu::%E]]%>",
    "pattern": "ISO C\\+\\+ '(.+?)' attribute does not apply to functions; treating as '\\[\\[gnu::(.+?)\\]\\]'",
    "replacement": "ISO C++ '$1' 特性不能应用于函数；视其为 '[[gnu::$2]]'"
  },
  {
    "id": "requested %<init_priority%> is not an integer constant",
    "pattern": "requested 'init_priority' is not an integer constant",
    "replacement": "请求的 'init_priority' 不是一个整数常数"
  },
  {
    "id": "can only use %qE attribute on file-scope definitions of objects of class type",
    "pattern": "can only use '(.+?)' attribute on file-scope definitions of objects of class type",
    "replacement": "只能将 '$1' 特性用于类类型的对象的文件作用域定义"
  },
  {
    "id": "requested %<init_priority%> %i is out of range [0, %i]",
    "pattern": "requested 'init_priority' (\\d+) is out of range \\[0, (\\d+)\\]",
    "replacement": "请求的 'init_priority' $1 不在 [0, $2] 范围内"
  },
  {
    "id": "requested %<init_priority%> %i is reserved for internal use",
    "pattern": "requested 'init_priority' (\\d+) is reserved for internal use",
    "replacement": "请求的 'init_priority' $1 保留为内部使用"
  },
  {
    "id": "%qE attribute is not supported on this platform",
    "pattern": "'(.+?)' attribute is not supported on this platform",
    "replacement": "'$1' 特性在此平台上不受支持"
  },
  {
    "id": "redeclaration of %qD adds abi tag %qE",
    "pattern": "redeclaration of '(.+?)' adds abi tag '(.+?)'",
    "replacement": "'$1' 的重声明添加了 ABI 标签 '$2'"
  },
  {
    "id": "the %qE attribute requires arguments",
    "pattern": "the '(.+?)' attribute requires arguments",
    "replacement": "'$1' 特性需要实参"
  },
  {
    "id": "arguments to the %qE attribute must be narrow string literals",
    "pattern": "arguments to the '(.+?)' attribute must be narrow string literals",
    "replacement": "传递给 '$1' 特性的实参必须是窄字符串字面量"
  },
  {
    "id": "arguments to the %qE attribute must contain valid identifiers",
    "pattern": "arguments to the '(.+?)' attribute must contain valid identifiers",
    "replacement": "传递给 '$1' 特性的实参必须包含有效标识符"
  },
  {
    "id": "%<%c%> is not a valid first character for an identifier",
    "pattern": "'(.)' is not a valid first character for an identifier",
    "replacement": "'$1' 不是标识符的有效首字符"
  },
  {
    "id": "%<%c%> is not a valid character in an identifier",
    "pattern": "'(.)' is not a valid character in an identifier",
    "replacement": "'$1' 不是标识符的有效字符"
  },
  {
    "id": "%qE attribute applied to non-class, non-enum type %qT",
    "pattern": "'(.+?)' attribute applied to non-class, non-enum type '(.+?)'",
    "replacement": "'$1' 特性应用于非类、非枚举类型 '$2'"
  },
  {
    "id": "%qE attribute applied to %qT after its definition",
    "pattern": "'(.+?)' attribute applied to '(.+?)' after its definition",
    "replacement": "'$1' 特性在 '$2' 定义后应用于其上"
  },
  {
    "id": "ignoring %qE attribute applied to template instantiation %qT",
    "pattern": "ignoring '(.+?)' attribute applied to template instantiation '(.+?)'",
    "replacement": "忽略应用于模板实例化 '$2' 上的 '$1' 特性"
  },
  {
    "id": "ignoring %qE attribute applied to template specialization %qT",
    "pattern": "ignoring '(.+?)' attribute applied to template specialization '(.+?)'",
    "replacement": "忽略应用于模板特化 '$2' 上的 '$1' 特性"
  },
  {
    "id": "%qE attribute applied to non-function, non-variable %qD",
    "pattern": "'(.+?)' attribute applied to non-function, non-variable '(.+?)'",
    "replacement": "'$1' 特性应用于非函数、非变量的 '$2'"
  },
  {
    "id": "%qE attribute applied to extern \\\"C\\\" declaration %qD",
    "pattern": "'(.+?)' attribute applied to extern \"C\" declaration '(.+?)'",
    "replacement": "'$1' 特性应用于 extern \"C\" 声明 '$2'"
  },
  {
    "id": "zero as null pointer constant",
    "pattern": "zero as null pointer constant",
    "replacement": "将零作为空指针常量"
  },
  {
    "id": "%<lang_*%> check: failed in %s, at %s:%d",
    "pattern": "'lang_\\*' check: failed in (.*?), at",
    "replacement": "'lang_*' 检验：在 $1 中失败，于"
  },
  {
    "id": "comparison between distinct pointer types %qT and %qT lacks a cast",
    "pattern": "comparison between distinct pointer types '(.+?)' and '(.+?)' lacks a cast",
    "replacement": "比较不同类型的指针 '$1' 和 '$2' 需要类型转换"
  },
  {
    "id": "conversion between distinct pointer types %qT and %qT lacks a cast",
    "pattern": "conversion between distinct pointer types '(.+?)' and '(.+?)' lacks a cast",
    "replacement": "不同类型的指针 '$1' 和 '$2' 之间需要显式的类型转换"
  },
  {
    "id": "conditional expression between distinct pointer types %qT and %qT lacks a cast",
    "pattern": "conditional expression between distinct pointer types '(.+?)' and '(.+?)' lacks a cast",
    "replacement": "由不同类型的指针 '$1' 和 '$2' 组成条件表达式时，需要类型转换"
  },
  {
    "id": "ISO C++ forbids comparison between pointer of type %<void *%> and pointer-to-function",
    "pattern": "ISO C\\+\\+ forbids comparison between pointer of type 'void \\*' and pointer-to-function",
    "replacement": "ISO C++ 禁止在 'void *' 和函数指针间比较"
  },
  {
    "id": "ISO C++ forbids conversion between pointer of type %<void *%> and pointer-to-function",
    "pattern": "ISO C\\+\\+ forbids conversion between pointer of type 'void \\*' and pointer-to-function",
    "replacement": "ISO C++ 禁止在 'void *' 和函数指针间转换"
  },
  {
    "id": "ISO C++ forbids conditional expression between pointer of type %<void *%> and pointer-to-function",
    "pattern": "ISO C\\+\\+ forbids conditional expression between pointer of type 'void \\*' and pointer-to-function",
    "replacement": "ISO C++ 禁止 'void *' 和函数指针组成条件表达式"
  },
  {
    "id": "comparison between distinct pointer-to-member types %qT and %qT lacks a cast",
    "pattern": "comparison between distinct pointer-to-member types '(.+?)' and '(.+?)' lacks a cast",
    "replacement": "比较不同类型的成员指针 '$1' 和 '$2' 需要类型转换"
  },
  {
    "id": "conversion between distinct pointer-to-member types %qT and %qT lacks a cast",
    "pattern": "conversion between distinct pointer-to-member types '(.+?)' and '(.+?)' lacks a cast",
    "replacement": "不同类型的成员指针 '$1' 和 '$2' 之间需要显式的类型转换"
  },
  {
    "id": "conditional expression between distinct pointer-to-member types %qT and %qT lacks a cast",
    "pattern": "conditional expression between distinct pointer-to-member types '(.+?)' and '(.+?)' lacks a cast",
    "replacement": "由不同类型的成员指针 '$1' 和 '$2' 组成条件表达式时，需要类型转换"
  },
  {
    "id": "canonical types differ for identical types %qT and %qT",
    "pattern": "canonical types differ for identical types '(.+?)' and '(.+?)'",
    "replacement": "相同类型 '$1' 和 '$2' 的正规类型不同"
  },
  {
    "id": "same canonical type node for different types %qT and %qT",
    "pattern": "same canonical type node for different types '(.+?)' and '(.+?)'",
    "replacement": "不同类型 '$1' 和 '$2' 具有相同的正规类型节点"
  },
  {
    "id": "invalid application of %qs to a member function",
    "pattern": "invalid application of '(.+?)' to a member function",
    "replacement": "对成员函数应用 '$1' 无效"
  },
  {
    "id": "invalid application of %<sizeof%> to a bit-field",
    "pattern": "invalid application of 'sizeof' to a bit-field",
    "replacement": "对位段应用 'sizeof' 无效"
  },
  {
    "id": "ISO C++ forbids applying %<sizeof%> to an expression of function type",
    "pattern": "ISO C\\+\\+ forbids applying 'sizeof' to an expression of function type",
    "replacement": "ISO C++ 不允许将 'sizeof' 应用到函数类型的表达式上"
  },
  {
    "id": "invalid application of %<__alignof%> to a bit-field",
    "pattern": "invalid application of '__alignof' to a bit-field",
    "replacement": "对位段应用 '__alignof' 无效"
  },
  {
    "id": "ISO C++ forbids applying %<__alignof%> to an expression of function type",
    "pattern": "ISO C\\+\\+ forbids applying '__alignof' to an expression of function type",
    "replacement": "ISO C++ 不允许将 '__alignof' 应用到函数类型的表达式上"
  },
  {
    "id": "%<alignas%> argument has non-integral type %qT",
    "pattern": "'alignas' argument has non-integral type '(.+?)'",
    "replacement": "'alignas' 实参具有非整数类型 '$1'"
  },
  {
    "id": "invalid use of non-static member function of type %qT",
    "pattern": "invalid use of non-static member function of type '(.+?)'",
    "replacement": "非法地使用了 '$1' 类型的非静态成员函数"
  },
  {
    "id": "taking address of temporary array",
    "pattern": "taking address of temporary array",
    "replacement": "取临时数组的地址"
  },
  {
    "id": "ISO C++ forbids converting a string constant to %qT",
    "pattern": "ISO C\\+\\+ forbids converting a string constant to '(.+?)'",
    "replacement": "ISO C++ 禁止从字符串常量转换到 '$1'"
  },
  {
    "id": "deprecated conversion from string constant to %qT",
    "pattern": "deprecated conversion from string constant to '(.+?)'",
    "replacement": "从字符串常量到'(.+?)'的转换已弃用"
  },
  {
    "id": "request for member %qD in %qE, which is of pointer type %qT (maybe you meant to use %<->%> ?)",
    "pattern": "request for member '(.+?)' in '(.+?)', which is of pointer type '(.+?)' \\(maybe you meant to use '->' \\?\\)",
    "replacement": "对成员 '$1' 的请求出现在 '$2' 中，而后者是指针类型 '$3'（或许你的意思是使用 '->' ？）"
  },
  {
    "id": "request for member %qD in %qE, which is of non-class type %qT",
    "pattern": "request for member '(.+?)' in '(.+?)', which is of non-class type '(.+?)'",
    "replacement": "对成员 '$1' 的请求出现在 '$2' 中，而后者具有非类类型 '$3'"
  },
  {
    "id": "invalid use of non-static data member %qE",
    "pattern": "invalid use of non-static data member '(.+?)'",
    "replacement": "非法地使用了非静态数据成员 '$1'"
  },
  {
    "id": "invalid access to non-static data member %qD in virtual base of NULL object",
    "pattern": "invalid access to non-static data member '(.+?)' in virtual base of NULL object",
    "replacement": "对 NULL 对象的虚基类的非静态数据成员 '$1' 的访问非法"
  },
  {
    "id": "object type %qT does not match destructor name ~%qT",
    "pattern": "object type '(.+?)' does not match destructor name ~'(.+?)'",
    "replacement": "对象类型 '$1' 的析构函数名 ~'$2'不匹配"
  },
  {
    "id": "the type being destroyed is %qT, but the destructor refers to %qT",
    "pattern": "the type being destroyed is '(.+?)', but the destructor refers to '(.+?)'",
    "replacement": "被销毁的类型是 '$1'，但析构函数却使用了 '$2'"
  },
  {
    "id": "field %q#D can be accessed via %q#D",
    "pattern": "field '(.+?)' can be accessed via '(.+?)'",
    "replacement": "字段 '$1' 可以通过 '$2' 被访问"
  },
  {
    "id": "%q#T has no member named %qE",
    "pattern": "'(.+?)' has no member named '(.+?)'",
    "replacement": "'$1' 没有名为 '$2' 的成员"
  },
  {
    "id": "%q#T has no member named %qE; did you mean %q#D? (accessible via %q#D)",
    "pattern": "'(.+?)' has no member named '(.+?)'; did you mean '(.+?)'\\? \\(accessible via '(.+?)'\\)",
    "replacement": "'$1' 没有名为 '$2' 的成员；你的意思是 '$3' 吗？（可通过 '$4' 访问）"
  },
  {
    "id": "%q#T has no member named %qE; did you mean %q#D? (not accessible from this context)",
    "pattern": "'(.+?)' has no member named '(.+?)'; did you mean '(.+?)'\\? \\(not accessible from this context\\)",
    "replacement": "'$1' 没有名为 '$2' 的成员；你的意思是 '$3' 吗？（此语境下不可访问）"
  },
  {
    "id": "%q#T has no member named %qE; did you mean %qE?",
    "pattern": "'(.+?)' has no member named '(.+?)'; did you mean '(.+?)'\\?",
    "replacement": "'$1' 没有名为 '$2' 的成员；你的意思是 '$3' 吗？"
  },
  {
    "id": "%<%D::%D%> is not a member of %qT",
    "pattern": "'(.+?)::(.+?)' is not a member of '(.+?)'",
    "replacement": "'$1::$2' 不是 '$3' 的成员"
  },
  {
    "id": "%qT is not a base of %qT",
    "pattern": "'(.+?)' is not a base of '(.+?)'",
    "replacement": "'$1' 不是 '$2' 的基类"
  },
  {
    "id": "%qD is not a member template function",
    "pattern": "'(.+?)' is not a member template function",
    "replacement": "'$1' 不是成员模板函数"
  },
  {
    "id": "%qT is not a pointer-to-object type",
    "pattern": "'(.+?)' is not a pointer-to-object type",
    "replacement": "'$1' 不是指向对象的类型"
  },
  {
    "id": "invalid use of array indexing on pointer to member",
    "pattern": "invalid use of array indexing on pointer to member",
    "replacement": "非法地对成员指针使用了数组索引"
  },
  {
    "id": "invalid use of unary %<*%> on pointer to member",
    "pattern": "invalid use of unary '\\*' on pointer to member",
    "replacement": "非法地对成员指针使用了一元 '*' 运算符"
  },
  {
    "id": "invalid use of implicit conversion on pointer to member",
    "pattern": "invalid use of implicit conversion on pointer to member",
    "replacement": "非法地对成员指针使用隐式转换"
  },
  {
    "id": "left hand operand of %<->*%> must be a pointer to class, but is a pointer to member of type %qT",
    "pattern": "left hand operand of '->\\*' must be a pointer to class, but is a pointer to member of type '(.+?)'",
    "replacement": "'->*' 的左侧操作数必须是一个指向类的指针，但它是 '$1' 类型的成员指针"
  },
  {
    "id": "subscript missing in array reference",
    "pattern": "subscript missing in array reference",
    "replacement": "数组引用缺少下标"
  },
  {
    "id": "subscripting array declared %<register%>",
    "pattern": "subscripting array declared 'register'",
    "replacement": "按下标访问声明为 'register' 的数组"
  },
  {
    "id": "subscripted value is neither array nor pointer",
    "pattern": "subscripted value is neither array nor pointer",
    "replacement": "下标运算的左操作数既不是数组，也不是指针"
  },
  {
    "id": "object missing in use of %qE",
    "pattern": "object missing in use of '(.+?)'",
    "replacement": "使用 '$1' 时缺少对象"
  },
  {
    "id": "ISO C++ forbids calling %<::main%> from within program",
    "pattern": "ISO C\\+\\+ forbids calling '::main' from within program",
    "replacement": "ISO C++ 不允许在程序里调用 '::main'"
  },
  {
    "id": "must use %<.*%> or %<->*%> to call pointer-to-member function in %<%E (...)%>, e.g. %<(... ->* %E) (...)%>",
    "pattern": "must use '\\.\\*' or '->\\*' to call pointer-to-member function in '(.+?) \\(\\.\\.\\.\\)', e.g. '\\(\\.\\.\\. ->\\* (.+?)\\) \\(\\.\\.\\.\\)'",
    "replacement": "必须用 '.*' 或 '->*' 调用 '$1 (...)' 中的成员函数指针，例如 '(... ->* $2) (...)'"
  },
  {
    "id": "%qE cannot be used as a function",
    "pattern": "'(.+?)' cannot be used as a function",
    "replacement": "'$1' 不能被用作函数"
  },
  {
    "id": "expression cannot be used as a function",
    "pattern": "expression cannot be used as a function",
    "replacement": "表达式不能用作函数"
  },
  {
    "id": "too many arguments to constructor %q#D",
    "pattern": "too many arguments to constructor '(.+?)'",
    "replacement": "传递给构造函数 '$1' 的实参太多"
  },
  {
    "id": "too few arguments to constructor %q#D",
    "pattern": "too few arguments to constructor '(.+?)'",
    "replacement": "传递给构造函数 '$1' 的实参太少"
  },
  {
    "id": "too many arguments to member function %q#D",
    "pattern": "too many arguments to member function '(.+?)'",
    "replacement": "传递给成员函数 '$1' 的实参太多"
  },
  {
    "id": "too few arguments to member function %q#D",
    "pattern": "too few arguments to member function '(.+?)'",
    "replacement": "传递给成员函数 '$1' 的实参太少"
  },
  {
    "id": "too many arguments to function %q#D",
    "pattern": "too many arguments to function '(.+?)'",
    "replacement": "传递给函数 '$1' 的实参太多"
  },
  {
    "id": "too few arguments to function %q#D",
    "pattern": "too few arguments to function '(.+?)'",
    "replacement": "传递给函数 '$1' 的实参太少"
  },
  {
    "id": "too many arguments to method %q#D",
    "pattern": "too many arguments to method '(.+?)'",
    "replacement": "传递给方法 '$1' 的实参太多"
  },
  {
    "id": "too few arguments to method %q#D",
    "pattern": "too few arguments to method '(.+?)'",
    "replacement": "传递给方法 '$1' 的实参太少"
  },
  {
    "id": "too many arguments to function",
    "pattern": "too many arguments to function",
    "replacement": "传递给函数的实参太多"
  },
  {
    "id": "too few arguments to function",
    "pattern": "too few arguments to function",
    "replacement": "传递给函数的实参太少"
  },
  {
    "id": "parameter %P of %qD has incomplete type %qT",
    "pattern": "parameter (.*?) of '(.+?)' has incomplete type '(.+?)'",
    "replacement": "'$2' 的第 $1 个形参具有不完整类型 '$3'"
  },
  {
    "id": "parameter %P has incomplete type %qT",
    "pattern": "parameter (.*?) has incomplete type '(.+?)'",
    "replacement": "第 $1 个形参具有不完整类型 '$2'"
  },
  {
    "id": "the address of %qD will never be NULL",
    "pattern": "the address of '(.+?)' will never be NULL",
    "replacement": "'$1' 的地址永远不会为 NULL"
  },
  {
    "id": "the compiler can assume that the address of %qD will never be NULL",
    "pattern": "the compiler can assume that the address of '(.+?)' will never be NULL",
    "replacement": "编译器可假设 '$1' 的地址永远不会是 NULL"
  },
  {
    "id": "bitwise operation between different enumeration types %qT and %qT is deprecated",
    "pattern": "bitwise operation between different enumeration types '(.+?)' and '(.+?)' is deprecated",
    "replacement": "不同的枚举类型 '$1' 和 '$2' 之间的位运算被弃用"
  },
  {
    "id": "arithmetic between different enumeration types %qT and %qT is deprecated",
    "pattern": "arithmetic between different enumeration types '(.+?)' and '(.+?)' is deprecated",
    "replacement": "不同的枚举类型 '$1' 和 '$2' 之间的算术运算被弃用"
  },
  {
    "id": "comparison of enumeration type %qT with floating-point type %qT is deprecated",
    "pattern": "comparison of enumeration type '(.+?)' with floating-point type '(.+?)' is deprecated",
    "replacement": "枚举类型 '$1' 和浮点类型 '$2' 之间的比较被弃用"
  },
  {
    "id": "comparison of floating-point type %qT with enumeration type %qT is deprecated",
    "pattern": "comparison of floating-point type '(.+?)' with enumeration type '(.+?)' is deprecated",
    "replacement": "浮点类型 '$1' 和枚举类型 '$2' 之间的比较被弃用"
  },
  {
    "id": "arithmetic between enumeration type %qT and floating-point type %qT is deprecated",
    "pattern": "arithmetic between enumeration type '(.+?)' and floating-point type '(.+?)' is deprecated",
    "replacement": "枚举类型 '$1' 和浮点类型 '$2' 之间的算术运算被弃用"
  },
  {
    "id": "arithmetic between floating-point type %qT and enumeration type %qT is deprecated",
    "pattern": "arithmetic between floating-point type '(.+?)' and enumeration type '(.+?)' is deprecated",
    "replacement": "浮点类型 '$1' 和枚举类型 '$2' 之间的算术运算被弃用"
  },
  {
    "id": "assuming cast to type %qT from overloaded function",
    "pattern": "assuming cast to type '(.+?)' from overloaded function",
    "replacement": "假定从重载函数转换到类型 '$1'"
  },
  {
    "id": "NULL used in arithmetic",
    "pattern": "NULL used in arithmetic",
    "replacement": "算术表达式中使用了 NULL"
  },
  {
    "id": "ISO C++ forbids comparison between pointer and integer",
    "pattern": "ISO C\\+\\+ forbids comparison between pointer and integer",
    "replacement": "ISO C++ 不允许比较指针和整数的值"
  },
  {
    "id": "operand types are %qT and %qT",
    "pattern": "operand types are '(.+?)' and '(.+?)'",
    "replacement": "操作数类型是 '$1' 和 '$2'"
  },
  {
    "id": "three-way comparison of vectors",
    "pattern": "three-way comparison of vectors",
    "replacement": "向量之间的三路比较"
  },
  {
    "id": "ordered comparison of pointer with integer zero (%qT and %qT)",
    "pattern": "ordered comparison of pointer with integer zero \\('(.+?)' and '(.+?)'\\)",
    "replacement": "指针与整数零（'$1' 和 '$2'）之间的有序比较"
  },
  {
    "id": "unordered comparison on non-floating-point argument",
    "pattern": "unordered comparison on non-floating-point argument",
    "replacement": "非浮点实参之间的无序比较"
  },
  {
    "id": "implicit conversion from %qH to %qI to match other operand of binary expression",
    "pattern": "implicit conversion from '(.+?)' to '(.+?)' to match other operand of binary expression",
    "replacement": "为了匹配二元表达式的其它操作数，发生从 '$1' 到 '$2' 的隐式转换"
  },
  {
    "id": "invalid operands of types %qT and %qT to binary %qO",
    "pattern": "invalid operands of types '(.+?)' and '(.+?)' to binary '(.+?)'",
    "replacement": "二元 '$1' 的操作数 '$1' 和 '$2' 无效"
  },
  {
    "id": "ISO C++ forbids using pointer of type %<void *%> in subtraction",
    "pattern": "ISO C\\+\\+ forbids using pointer of type 'void \\*' in subtraction",
    "replacement": "ISO C++ 不允许在减法中使用 'void *' 类型的指针"
  },
  {
    "id": "ISO C++ forbids using pointer to a function in subtraction",
    "pattern": "ISO C\\+\\+ forbids using pointer to a function in subtraction",
    "replacement": "ISO C++ 不允许在减法中使用函数指针"
  },
  {
    "id": "ISO C++ forbids using pointer to a method in subtraction",
    "pattern": "ISO C\\+\\+ forbids using pointer to a method in subtraction",
    "replacement": "ISO C++ 不允许在减法中使用指向方法的指针"
  },
  {
    "id": "invalid use of a pointer to an incomplete type in pointer arithmetic",
    "pattern": "invalid use of a pointer to an incomplete type in pointer arithmetic",
    "replacement": "在指针算术运算中非法使用了指向不完整类型的指针"
  },
  {
    "id": "taking address of constructor %qD",
    "pattern": "taking address of constructor '(.+?)'",
    "replacement": "取构造函数 '$1' 的地址"
  },
  {
    "id": "taking address of destructor %qD",
    "pattern": "taking address of destructor '(.+?)'",
    "replacement": "取析构函数 '$1' 的地址"
  },
  {
    "id": "invalid use of %qE to form a pointer-to-member-function",
    "pattern": "invalid use of '(.+?)' to form a pointer-to-member-function",
    "replacement": "非法地使用 '$1' 生成成员函数指针"
  },
  {
    "id": "  a qualified-id is required",
    "pattern": "  a qualified-id is required",
    "replacement": "  需要一个限定标识符"
  },
  {
    "id": "parentheses around %qE cannot be used to form a pointer-to-member-function",
    "pattern": "parentheses around '(.+?)' cannot be used to form a pointer-to-member-function",
    "replacement": "'$1' 两边的括号不能用来生成成员函数指针"
  },
  {
    "id": "ISO C++ forbids taking the address of an unqualified or parenthesized non-static member function to form a pointer to member function.  Say %<&%T::%D%>",
    "pattern": "ISO C\\+\\+ forbids taking the address of an unqualified or parenthesized non-static member function to form a pointer to member function.  Say '&(.+?)::(.+?)'",
    "replacement": "ISO C++ 禁止通过对未限定或带括号的非静态成员函数取地址来生成成员函数指针。请使用 '&$1::$2'"
  },
  {
    "id": "ISO C++ forbids taking the address of a bound member function to form a pointer to member function.  Say %<&%T::%D%>",
    "pattern": "ISO C\\+\\+ forbids taking the address of a bound member function to form a pointer to member function.  Say '&(.+?)::(.+?)'",
    "replacement": "ISO C++ 禁止通过取已绑定的成员函数的地址来生成成员函数指针。请使用 '&$1::$2'"
  },
  {
    "id": "taking address of rvalue",
    "pattern": "taking address of rvalue",
    "replacement": "取右值的地址"
  },
  {
    "id": "ISO C++ forbids taking address of function %<::main%>",
    "pattern": "ISO C\\+\\+ forbids taking address of function '::main'",
    "replacement": "ISO C++ 不允许取函数 '::main' 的地址"
  },
  {
    "id": "cannot create pointer to reference member %qD",
    "pattern": "cannot create pointer to reference member '(.+?)'",
    "replacement": "不能创建指向引用成员 '(.+?)' 的指针"
  },
  {
    "id": "attempt to take address of bit-field",
    "pattern": "attempt to take address of bit-field",
    "replacement": "试图取位域的地址"
  },
  {
    "id": "taking address of an immediate function %qD",
    "pattern": "taking address of an immediate function '(.+?)'",
    "replacement": "取立即函数 '$1' 的地址"
  },
  {
    "id": "%<~%> on an expression of type %<bool%>",
    "pattern": "'~' on an expression of type 'bool'",
    "replacement": "'~' 作用于 'bool' 类型的表达式"
  },
  {
    "id": "did you mean to use logical not (%<!%>)?",
    "pattern": "did you mean to use logical not \\('!'\\)\\?",
    "replacement": "你的意思是使用逻辑非（!）吗？"
  },
  {
    "id": "ISO C++ forbids incrementing an enum",
    "pattern": "ISO C\\+\\+ forbids incrementing an enum",
    "replacement": "ISO C++ 不允许枚举自增"
  },
  {
    "id": "ISO C++ forbids decrementing an enum",
    "pattern": "ISO C\\+\\+ forbids decrementing an enum",
    "replacement": "ISO C++ 不允许枚举自减"
  },
  {
    "id": "cannot increment a pointer to incomplete type %qT",
    "pattern": "cannot increment a pointer to incomplete type '(.+?)'",
    "replacement": "指向不完整类型 '$1' 的指针不能自增"
  },
  {
    "id": "cannot decrement a pointer to incomplete type %qT",
    "pattern": "cannot decrement a pointer to incomplete type '(.+?)'",
    "replacement": "指向不完整类型 '$1' 的指针不能自减"
  },
  {
    "id": "ISO C++ forbids incrementing a pointer of type %qT",
    "pattern": "ISO C\\+\\+ forbids incrementing a pointer of type '(.+?)'",
    "replacement": "ISO C++ 不允许自增 '$1' 类型的指针"
  },
  {
    "id": "ISO C++ forbids decrementing a pointer of type %qT",
    "pattern": "ISO C\\+\\+ forbids decrementing a pointer of type '(.+?)'",
    "replacement": "ISO C++ 不允许自减 '$1' 类型的指针"
  },
  {
    "id": "%qs expression of %<volatile%>-qualified type is deprecated",
    "pattern": "'(.+?)' expression of 'volatile'-qualified type is deprecated",
    "replacement": "'volatile' 限定类型的 '$1' 表达式被弃用"
  },
  {
    "id": "use of an operand of type %qT in %<operator--%> is forbidden",
    "pattern": "use of an operand of type '(.+?)' in 'operator--' is forbidden",
    "replacement": "禁止在 'operator--' 中使用 '$1' 类型的操作数"
  },
  {
    "id": "use of an operand of type %qT in %<operator++%> is forbidden in C++17",
    "pattern": "use of an operand of type '(.+?)' in 'operator\\+\\+' is forbidden in C\\+\\+17",
    "replacement": "C++17 禁止在 'operator++' 中使用 '$1' 类型的操作数"
  },
  {
    "id": "use of an operand of type %qT in %<operator++%> is deprecated",
    "pattern": "use of an operand of type '(.+?)' in 'operator\\+\\+' is deprecated",
    "replacement": "在 'operator++' 中使用 '$1' 类型的操作数被弃用"
  },
  {
    "id": "cannot take the address of %<this%>, which is an rvalue expression",
    "pattern": "cannot take the address of 'this', which is an rvalue expression",
    "replacement": "不能取 'this' 的地址，因为它是右值表达式"
  },
  {
    "id": "address of explicit register variable %qD requested",
    "pattern": "address of explicit register variable '(.+?)' requested",
    "replacement": "请求显式寄存器变量 '$1' 的地址。"
  },
  {
    "id": "address requested for %qD, which is declared %<register%>",
    "pattern": "address requested for '(.+?)', which is declared 'register'",
    "replacement": "请求声明为 'register' 的 '$1' 的地址"
  },
  {
    "id": "list-initializer for non-class type must not be parenthesized",
    "pattern": "list-initializer for non-class type must not be parenthesized",
    "replacement": "非类类型的列表初始化器不能被括号围起"
  },
  {
    "id": "expression list treated as compound expression in initializer",
    "pattern": "expression list treated as compound expression in initializer",
    "replacement": "初始化器中的表达式列表被视为复合表达式"
  },
  {
    "id": "expression list treated as compound expression in mem-initializer",
    "pattern": "expression list treated as compound expression in mem-initializer",
    "replacement": "内存初始化器中的表达式列表被视为复合表达式"
  },
  {
    "id": "expression list treated as compound expression in functional cast",
    "pattern": "expression list treated as compound expression in functional cast",
    "replacement": "函数式类型转换中的表达式列表被视为复合表达式"
  },
  {
    "id": "%s expression list treated as compound expression",
    "pattern": "(.*?) expression list treated as compound expression",
    "replacement": "表达式列表 '$1' 被视为复合表达式"
  },
  {
    "id": "no context to resolve type of %qE",
    "pattern": "no context to resolve type of '(.+?)'",
    "replacement": "缺少用以解析 '$1' 类型的语境"
  },
  {
    "id": "cast from type %qT to type %qT casts away qualifiers",
    "pattern": "cast from type '(.+?)' to type '(.+?)' casts away qualifiers",
    "replacement": "从 '$1' 类型到 '$2' 类型的转换丢失了限定符"
  },
  {
    "id": "%<static_cast%> from type %qT to type %qT casts away qualifiers",
    "pattern": "'static_cast' from type '(.+?)' to type '(.+?)' casts away qualifiers",
    "replacement": "从 '$1' 类型到 '$2' 类型的 'static_cast' 丢失了限定符"
  },
  {
    "id": "%<reinterpret_cast%> from type %qT to type %qT casts away qualifiers",
    "pattern": "'reinterpret_cast' from type '(.+?)' to type '(.+?)' casts away qualifiers",
    "replacement": "从 '$1' 类型到 '$2' 类型的 'reinterpret_cast' 丢失了限定符"
  },
  {
    "id": "useless cast to type %q#T",
    "pattern": "useless cast to type '(.+?)'",
    "replacement": "到 '$1' 类型的转换没有用"
  },
  {
    "id": "type qualifiers ignored on cast result type",
    "pattern": "type qualifiers ignored on cast result type",
    "replacement": "忽略类型转换结果中的类型限定符"
  },
  {
    "id": "invalid %<static_cast%> from type %qT to type %qT",
    "pattern": "invalid 'static_cast' from type '(.+?)' to type '(.+?)'",
    "replacement": "从 '$1' 类型到 '$2' 类型的 'static_cast' 无效"
  },
  {
    "id": "class type %qT is incomplete",
    "pattern": "class type '(.+?)' is incomplete",
    "replacement": "类类型 '$1' 是不完整类型"
  },
  {
    "id": "converting from %qH to %qI",
    "pattern": "converting from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 转换到 '$2'"
  },
  {
    "id": "invalid cast of a prvalue expression of type %qT to type %qT",
    "pattern": "invalid cast of a prvalue expression of type '(.+?)' to type '(.+?)'",
    "replacement": "非法地从 '$1' 类型的纯右值表达式转换到 '$2' 类型"
  },
  {
    "id": "cast from %qH to %qI loses precision",
    "pattern": "cast from '(.+?)' to '(.+?)' loses precision",
    "replacement": "从 '$1' 到 '$2' 的转换损失了精度"
  },
  {
    "id": "cast between incompatible function types from %qH to %qI",
    "pattern": "cast between incompatible function types from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 发生不完整函数类型之间的转换"
  },
  {
    "id": "cast between incompatible pointer to member types from %qH to %qI",
    "pattern": "cast between incompatible pointer to member types from '(.+?)' to '(.+?)'",
    "replacement": "从 '$1' 到 '$2' 发生不兼容的成员指针之间的类型转换"
  },
  {
    "id": "cast from %qH to %qI increases required alignment of target type",
    "pattern": "cast from '(.+?)' to '(.+?)' increases required alignment of target type",
    "replacement": "从 '$1' 到 '$2' 的转换增大了目标类型的对齐需求"
  },
  {
    "id": "casting between pointer-to-function and pointer-to-object is conditionally-supported",
    "pattern": "casting between pointer-to-function and pointer-to-object is conditionally-supported",
    "replacement": "函数指针和对象指针之间的转换是条件性支持的"
  },
  {
    "id": "invalid cast from type %qT to type %qT",
    "pattern": "invalid cast from type '(.+?)' to type '(.+?)'",
    "replacement": "非法地从类型 '$1' 转换到类型 '$2'"
  },
  {
    "id": "invalid use of %<const_cast%> with type %qT, which is not a pointer, reference, nor a pointer-to-data-member type",
    "pattern": "invalid use of 'const_cast' with type '(.+?)', which is not a pointer, reference, nor a pointer-to-data-member type",
    "replacement": "在类型 '$1' 上使用 'const_cast' 无效，因为它既不是指针、也不是引用，也不是数据成员指针"
  },
  {
    "id": "invalid use of %<const_cast%> with type %qT, which is a pointer or reference to a function type",
    "pattern": "invalid use of 'const_cast' with type '(.+?)', which is a pointer or reference to a function type",
    "replacement": "在类型 '$1' 上使用 'const_cast' 无效，因为它是一个函数指针或到函数类型的引用"
  },
  {
    "id": "invalid %<const_cast%> of an rvalue of type %qT to type %qT",
    "pattern": "invalid 'const_cast' of an rvalue of type '(.+?)' to type '(.+?)'",
    "replacement": "从 '$1' 类型的右值到 '$2' 类型的 'const_cast' 无效"
  },
  {
    "id": "invalid %<const_cast%> from type %qT to type %qT",
    "pattern": "invalid 'const_cast' from type '(.+?)' to type '(.+?)'",
    "replacement": "从 '$1' 类型到 '$2' 类型的 'const_cast' 无效"
  },
  {
    "id": "ISO C++ forbids casting to an array type %qT",
    "pattern": "ISO C\\+\\+ forbids casting to an array type '(.+?)'",
    "replacement": "ISO C++ 禁止转换为数组类型 '$1'"
  },
  {
    "id": "invalid cast to function type %qT",
    "pattern": "invalid cast to function type '(.+?)'",
    "replacement": "非法地转换到函数类型 '$1'"
  },
  {
    "id": "compound assignment with %<volatile%>-qualified left operand is deprecated",
    "pattern": "compound assignment with 'volatile'-qualified left operand is deprecated",
    "replacement": "带 'volatile' 限定左操作数的复合赋值表达式被弃用"
  },
  {
    "id": "  in evaluation of %<%Q(%#T, %#T)%>",
    "pattern": "  in evaluation of '(.+?)\\((.+?), (.+?)\\)'",
    "replacement": "  在 '$1($2, $3)' 的求值中"
  },
  {
    "id": "assigning to an array from an initializer list",
    "pattern": "assigning to an array from an initializer list",
    "replacement": "从初始化列表向数组赋值"
  },
  {
    "id": "incompatible types in assignment of %qT to %qT",
    "pattern": "incompatible types in assignment of '(.+?)' to '(.+?)'",
    "replacement": "将 '$1' 赋值给 '$2' 时类型不兼容"
  },
  {
    "id": "array used as initializer",
    "pattern": "array used as initializer",
    "replacement": "数组被用作初始化器"
  },
  {
    "id": "invalid array assignment",
    "pattern": "invalid array assignment",
    "replacement": "无效的数组赋值"
  },
  {
    "id": "   in pointer to member function conversion",
    "pattern": "   in pointer to member function conversion",
    "replacement": "   在成员函数指针转换中"
  },
  {
    "id": "pointer to member conversion via virtual base %qT",
    "pattern": "pointer to member conversion via virtual base '(.+?)'",
    "replacement": "成员指针转换经由虚基类 '$1'"
  },
  {
    "id": "   in pointer to member conversion",
    "pattern": "   in pointer to member conversion",
    "replacement": "   在成员指针转换中"
  },
  {
    "id": "invalid conversion to type %qT from type %qT",
    "pattern": "invalid conversion to type '(.+?)' from type '(.+?)'",
    "replacement": "从 '$2' 类型到 '$1' 类型的转换无效"
  },
  {
    "id": "cannot convert %qH to %qI in default argument",
    "pattern": "cannot convert '(.+?)' to '(.+?)' in default argument",
    "replacement": "不能在默认实参中将 '$1' 转换为 '$2'"
  },
  {
    "id": "cannot convert %qH to %qI in argument passing",
    "pattern": "cannot convert '(.+?)' to '(.+?)' in argument passing",
    "replacement": "不能在实参传递时将 '$1' 转换为 '$2'"
  },
  {
    "id": "cannot convert %qH to %qI in initialization",
    "pattern": "cannot convert '(.+?)' to '(.+?)' in initialization",
    "replacement": "不能在初始化时将 '$1' 转换为 '$2'"
  },
  {
    "id": "cannot convert %qH to %qI in return",
    "pattern": "cannot convert '(.+?)' to '(.+?)' in return",
    "replacement": "不能在返回时将 '$1' 转换为 '$2'"
  },
  {
    "id": "cannot convert %qH to %qI in assignment",
    "pattern": "cannot convert '(.+?)' to '(.+?)' in assignment",
    "replacement": "不能在赋值时将 '$1' 转换为 '$2'"
  },
  {
    "id": "parameter %qP of %qD might be a candidate for a format attribute",
    "pattern": "parameter '(.*?)' of '(.+?)' might be a candidate for a format attribute",
    "replacement": "'$2' 的形参 '$1' 可能是 format 特性的备选"
  },
  {
    "id": "parameter might be a candidate for a format attribute",
    "pattern": "parameter might be a candidate for a format attribute",
    "replacement": "形参可能是 format 特性的备选"
  },
  {
    "id": "target of conversion might be a candidate for a format attribute",
    "pattern": "target of conversion might be a candidate for a format attribute",
    "replacement": "转换的目标可能是 format 特性的备选"
  },
  {
    "id": "target of initialization might be a candidate for a format attribute",
    "pattern": "target of initialization might be a candidate for a format attribute",
    "replacement": "初始化的目标可能是 format 特性的备选"
  },
  {
    "id": "left-hand side of assignment might be a candidate for a format attribute",
    "pattern": "left-hand side of assignment might be a candidate for a format attribute",
    "replacement": "赋值的左侧操作数可能是 format 特性的备选"
  },
  {
    "id": "in passing argument %P of %qD",
    "pattern": "in passing argument (.*?) of '(.+?)'",
    "replacement": "在传递 '$2' 的第 $1 个实参时"
  },
  {
    "id": "returning reference to temporary",
    "pattern": "returning reference to temporary",
    "replacement": "返回了到临时变量的引用"
  },
  {
    "id": "returning temporary %<initializer_list%> does not extend the lifetime of the underlying array",
    "pattern": "returning temporary 'initializer_list' does not extend the lifetime of the underlying array",
    "replacement": "返回临时的 'initializer_list' 并不延长底层数组的生命期"
  },
  {
    "id": "reference to local variable %qD returned",
    "pattern": "reference to local variable '(.+?)' returned",
    "replacement": "返回了到局部变量的 '$1' 的引用"
  },
  {
    "id": "returning local %<initializer_list%> variable %qD does not extend the lifetime of the underlying array",
    "pattern": "returning local 'initializer_list' variable '(.+?)' does not extend the lifetime of the underlying array",
    "replacement": "返回局部的 'initializer_list' 变量 '$1' 并不延长底层数组的生命期"
  },
  {
    "id": "address of label %qD returned",
    "pattern": "address of label '(.+?)' returned",
    "replacement": "返回了标号 '$1' 的地址"
  },
  {
    "id": "address of local variable %qD returned",
    "pattern": "address of local variable '(.+?)' returned",
    "replacement": "返回了局部变量 '$1' 的地址"
  },
  {
    "id": "moving a local object in a return statement prevents copy elision",
    "pattern": "moving a local object in a return statement prevents copy elision",
    "replacement": "在 return 语句中移动局部对象将避免原有可能的复制消除"
  },
  {
    "id": "remove %<std::move%> call",
    "pattern": "remove 'std::move' call",
    "replacement": "删除 'std::move' 调用"
  },
  {
    "id": "redundant move in return statement",
    "pattern": "redundant move in return statement",
    "replacement": "return 语句中冗余的移动"
  },
  {
    "id": "returning a value from a destructor",
    "pattern": "returning a value from a destructor",
    "replacement": "析构函数返回了值"
  },
  {
    "id": "cannot return from a handler of a function-try-block of a constructor",
    "pattern": "cannot return from a handler of a function-try-block of a constructor",
    "replacement": "不能从构造函数的函数 try 块的处理代码中返回"
  },
  {
    "id": "returning a value from a constructor",
    "pattern": "returning a value from a constructor",
    "replacement": "构造函数返回了值"
  },
  {
    "id": "return-statement with no value, in function returning %qT",
    "pattern": "return-statement with no value, in function returning '(.+?)'",
    "replacement": "在返回 '$1' 的函数中，return 语句不带返回值"
  },
  {
    "id": "returning initializer list",
    "pattern": "returning initializer list",
    "replacement": "返回了初始化器列表"
  },
  {
    "id": "inconsistent types %qT and %qT deduced for lambda return type",
    "pattern": "inconsistent types '(.+?)' and '(.+?)' deduced for lambda return type",
    "replacement": "lambda 返回类型推导为不一致的类型 '$1' 和 '$2'"
  },
  {
    "id": "inconsistent deduction for auto return type: %qT and then %qT",
    "pattern": "inconsistent deduction for auto return type: '(.+?)' and then '(.+?)'",
    "replacement": "auto 返回类型推导为不一致的类型 '$1' 和 '$2'"
  },
  {
    "id": "return-statement with a value, in function returning %qT",
    "pattern": "return-statement with a value, in function returning '(.+?)'",
    "replacement": "在返回 '$1' 的函数中，return 语句带有返回值"
  },
  {
    "id": "%<operator new%> must not return NULL unless it is declared %<throw()%> (or %<-fcheck-new%> is in effect)",
    "pattern": "'operator new' must not return NULL unless it is declared 'throw()' \\(or '-fcheck-new' is in effect\\)",
    "replacement": "'operator new' 不能返回 NULL，声明为 'throw()' 除外（或 '-fcheck-new' 起作用）"
  },
  {
    "id": "using rvalue as lvalue",
    "pattern": "using rvalue as lvalue",
    "replacement": "将右值用作左值"
  },
  {
    "id": "type %qT is not a base type for type %qT",
    "pattern": "type '(.+?)' is not a base type for type '(.+?)'",
    "replacement": "类型 '$1' 不是类型 '$2' 的基类"
  },
  {
    "id": "assignment of constant field %qD",
    "pattern": "assignment of constant field '(.+?)'",
    "replacement": "向只读字段 '$1' 赋值"
  },
  {
    "id": "constant field %qD used as %<asm%> output",
    "pattern": "constant field '(.+?)' used as 'asm' output",
    "replacement": "只读字段 '$1' 用作 'asm' 的输出"
  },
  {
    "id": "increment of constant field %qD",
    "pattern": "increment of constant field '(.+?)'",
    "replacement": "令只读字段 '$1' 自增"
  },
  {
    "id": "decrement of constant field %qD",
    "pattern": "decrement of constant field '(.+?)'",
    "replacement": "令只读字段 '$1' 自减"
  },
  {
    "id": "assignment of read-only reference %qD",
    "pattern": "assignment of read-only reference '(.+?)'",
    "replacement": "向只读引用 '$1' 赋值"
  },
  {
    "id": "read-only reference %qD used as %<asm%> output",
    "pattern": "read-only reference '(.+?)' used as 'asm' output",
    "replacement": "只读引用 '$1' 被用作 'asm' 的输出"
  },
  {
    "id": "increment of read-only reference %qD",
    "pattern": "increment of read-only reference '(.+?)'",
    "replacement": "令只读引用 '$1' 自增"
  },
  {
    "id": "decrement of read-only reference %qD",
    "pattern": "decrement of read-only reference '(.+?)'",
    "replacement": "令只读引用 '$1' 自减"
  },
  {
    "id": "cannot declare variable %q+D to be of abstract type %qT",
    "pattern": "cannot declare variable '(.+?)' to be of abstract type '(.+?)'",
    "replacement": "不能将变量 '$1' 声明为具有抽象类型 '(.+?)'"
  },
  {
    "id": "cannot declare parameter %q+D to be of abstract type %qT",
    "pattern": "cannot declare parameter '(.+?)' to be of abstract type '(.+?)'",
    "replacement": "不能将形参 '$1' 声明为具有抽象类型 '(.+?)'"
  },
  {
    "id": "cannot declare parameter to be of abstract type %qT",
    "pattern": "cannot declare parameter to be of abstract type '(.+?)'",
    "replacement": "不能将形参声明为具有抽象类型 '(.+?)'"
  },
  {
    "id": "cannot declare field %q+D to be of abstract type %qT",
    "pattern": "cannot declare field '(.+?)' to be of abstract type '(.+?)'",
    "replacement": "不能将字段 '$1' 声明为具有抽象类型 '(.+?)'"
  },
  {
    "id": "invalid abstract return type for member function %q+#D",
    "pattern": "invalid abstract return type for member function '(.+?)",
    "replacement": "成员函数 '$1' 的抽象返回类型无效"
  },
  {
    "id": "invalid abstract return type for function %q+#D",
    "pattern": "invalid abstract return type for function '(.+?)",
    "replacement": "函数 '$1' 的抽象返回类型无效"
  },
  {
    "id": "invalid abstract type %qT for %qE",
    "pattern": "invalid abstract type '(.+?)' for '(.+?)'",
    "replacement": "'$2' 的抽象类型 '$1' 无效，"
  },
  {
    "id": "invalid abstract type for %q+D",
    "pattern": "invalid abstract type for '(.+?)'",
    "replacement": "'$1' 的抽象类型无效"
  },
  {
    "id": "creating array of %qT, which is an abstract class type",
    "pattern": "creating array of '(.+?)', which is an abstract class type",
    "replacement": "生成抽象类类型 '$1' 的数组"
  },
  {
    "id": "invalid cast to abstract class type %qT",
    "pattern": "invalid cast to abstract class type '(.+?)'",
    "replacement": "生成抽象类类型 '(.+?)' 的数组"
  },
  {
    "id": "invalid new-expression of abstract class type %qT",
    "pattern": "invalid new-expression of abstract class type '(.+?)'",
    "replacement": "抽象类类型 '$1' 的 new 表达式无效"
  },
  {
    "id": "invalid abstract return type %qT",
    "pattern": "invalid abstract return type '(.+?)'",
    "replacement": "抽象返回类型 '$1' 无效"
  },
  {
    "id": "invalid abstract parameter type %qT",
    "pattern": "invalid abstract parameter type '(.+?)'",
    "replacement": "抽象形参类型 '$1' 无效"
  },
  {
    "id": "expression of abstract class type %qT cannot be used in throw-expression",
    "pattern": "expression of abstract class type '(.+?)' cannot be used in throw-expression",
    "replacement": "表达式具有抽象类类型 '$1' ，不能用于 throw 表达式中"
  },
  {
    "id": "cannot declare %<catch%> parameter to be of abstract class type %qT",
    "pattern": "cannot declare 'catch' parameter to be of abstract class type '(.+?)'",
    "replacement": "不能将 'catch' 形参声明为抽象类类型 '$1'"
  },
  {
    "id": "cannot allocate an object of abstract type %qT",
    "pattern": "cannot allocate an object of abstract type '(.+?)'",
    "replacement": "无法为抽象类型 '$1' 的对象分配内存"
  },
  {
    "id": "  because the following virtual functions are pure within %qT:",
    "pattern": "  because the following virtual functions are pure within '(.+?)':",
    "replacement": "  因为下列虚函数在 '$1' 中是纯虚的："
  },
  {
    "id": "definition of %q#T is not complete until the closing brace",
    "pattern": "definition of '(.+?)' is not complete until the closing brace",
    "replacement": "'$1' 的定义直至右花括号仍未完成"
  },
  {
    "id": "forward declaration of %q#T",
    "pattern": "forward declaration of '(.+?)'",
    "replacement": "'$1' 的前置声明"
  },
  {
    "id": "declaration of %q#T",
    "pattern": "declaration of '(.+?)'",
    "replacement": "'$1' 的声明"
  },
  {
    "id": "%qD has incomplete type",
    "pattern": "'(.+?)' has incomplete type",
    "replacement": "'$1' 具有不完整类型"
  },
  {
    "id": "invalid use of incomplete type %q#T",
    "pattern": "invalid use of incomplete type '(.+?)'",
    "replacement": "非法地使用了不完整类型 '$1'"
  },
  {
    "id": "invalid use of member function %qD (did you forget the %<()%> ?)",
    "pattern": "invalid use of member function '(.+?)' \\(did you forget the '\\(\\)' \\?\\)",
    "replacement": "非法地使用了成员函数 '$1'（你是否忘记了 '()'？）"
  },
  {
    "id": "invalid use of member %qD (did you forget the %<&%> ?)",
    "pattern": "invalid use of member '(.+?)' (did you forget the '&' ?)",
    "replacement": "非法地使用了成员 '$1'（你是否忘记了 '&'？）"
  },
  {
    "id": "invalid use of placeholder %qT",
    "pattern": "invalid use of placeholder '(.+?)'",
    "replacement": "非法地使用了占位符 '$1'"
  },
  {
    "id": "invalid use of template type parameter %qT",
    "pattern": "invalid use of template type parameter '(.+?)'",
    "replacement": "非法地使用了类型模板形参 '$1'"
  },
  {
    "id": "invalid use of template template parameter %qT",
    "pattern": "invalid use of template template parameter '(.+?)'",
    "replacement": "非法地使用了模板模板形参 '$1'"
  },
  {
    "id": "invalid use of pack expansion %qT",
    "pattern": "invalid use of pack expansion '(.+?)'",
    "replacement": "非法地使用了包展开 '$1'"
  },
  {
    "id": "invalid use of dependent type %qT",
    "pattern": "invalid use of dependent type '(.+?)'",
    "replacement": "非法地使用了待决类型 '$1'"
  },
  {
    "id": "invalid use of brace-enclosed initializer list",
    "pattern": "invalid use of brace-enclosed initializer list",
    "replacement": "非法地使用了花括号初始化器列表"
  },
  {
    "id": "address of overloaded function with no contextual type information",
    "pattern": "address of overloaded function with no contextual type information",
    "replacement": "访问没有上下文类型信息的重载函数的地址"
  },
  {
    "id": "overloaded function with no contextual type information",
    "pattern": "overloaded function with no contextual type information",
    "replacement": "重载函数缺少上下文类型信息"
  },
  {
    "id": "insufficient contextual information to determine type",
    "pattern": "insufficient contextual information to determine type",
    "replacement": "上下文信息不足以确定类型"
  },
  {
    "id": "constructor syntax used, but no constructor declared for type %qT",
    "pattern": "constructor syntax used, but no constructor declared for type '(.+?)'",
    "replacement": "使用了构造函数的语法，但没有为类型 '$1' 声明构造函数"
  },
  {
    "id": "%<constinit%> variable %qD does not have a constant initializer",
    "pattern": "'constinit' variable '(.+?)' does not have a constant initializer",
    "replacement": "'constinit' 变量 '$1' 没有常量初始化器"
  },
  {
    "id": "narrowing conversion of %qE from %qH to %qI is ill-formed in C++11",
    "pattern": "narrowing conversion of '(.+?)' from '(.+?)' to '(.+?)' is ill-formed in C\\+\\+11",
    "replacement": "C++11 中 '$1' 从 '$2' 窄化转换到 '$3' 是非良构的"
  },
  {
    "id": "narrowing conversion of %qE from %qH to %qI",
    "pattern": "narrowing conversion of '(.+?)' from '(.+?)' to '(.+?)'",
    "replacement": "'$1' 从 '$2' 窄化转换到 '$3'"
  },
  {
    "id": " the expression has a constant value but is not a C++ constant-expression",
    "pattern": " the expression has a constant value but is not a C\\+\\+ constant-expression",
    "replacement": " 表达式拥有只读的值，但它不是 C++ 常量表达式"
  },
  {
    "id": "initializer-string for %qT is too long",
    "pattern": "initializer-string for '(.+?)' is too long",
    "replacement": "'$1' 的初始化器字符串太长"
  },
  {
    "id": "initializing a base class of type %qT results in object slicing",
    "pattern": "initializing a base class of type '(.+?)' results in object slicing",
    "replacement": "初始化类型 '$1' 的基类导致对象切片"
  },
  {
    "id": "remove %<{ }%> around initializer",
    "pattern": "remove '\\{ \\}' around initializer",
    "replacement": "移除初始化器两侧的 '{ }'"
  },
  {
    "id": "cannot initialize aggregate of type %qT with a compound literal",
    "pattern": "cannot initialize aggregate of type '(.+?)' with a compound literal",
    "replacement": "不能用复合字面量初始化 '$1' 类型的聚合体"
  },
  {
    "id": "missing initializer for member %qD",
    "pattern": "missing initializer for member '(.+?)'",
    "replacement": "成员 '$1' 缺少初始化器"
  },
  {
    "id": "member %qD is uninitialized reference",
    "pattern": "member '(.+?)' is uninitialized reference",
    "replacement": "成员 '$1' 是未初始化的引用"
  },
  {
    "id": "member %qD with uninitialized reference fields",
    "pattern": "member '(.+?)' with uninitialized reference fields",
    "replacement": "成员 '$1' 带有未初始化的引用字段"
  },
  {
    "id": "designator order for field %qD does not match declaration order in %qT",
    "pattern": "designator order for field '(.+?)' does not match declaration order in '(.+?)'",
    "replacement": "字段 '$1' 的指派顺序与其在 '$2' 中的声明顺序不匹配"
  },
  {
    "id": "no field %qD found in union being initialized",
    "pattern": "no field '(.+?)' found in union being initialized",
    "replacement": "待初始化的联合体中找不到 '$1' 字段"
  },
  {
    "id": "index value instead of field name in union initializer",
    "pattern": "index value instead of field name in union initializer",
    "replacement": "在联合体初始化器中出现了索引值而不是字段名"
  },
  {
    "id": "circular pointer delegation detected",
    "pattern": "circular pointer delegation detected",
    "replacement": "检测到循环指针代理"
  },
  {
    "id": "base operand of %<->%> has non-pointer type %qT",
    "pattern": "base operand of '->' has non-pointer type '(.+?)'",
    "replacement": "'->' 的基操作数具有非指针类型 '$1'"
  },
  {
    "id": "result of %<operator->()%> yields non-pointer result",
    "pattern": "result of 'operator->\\(\\)' yields non-pointer result",
    "replacement": "'operator->\\(\\)' 的结果给出了非指针的结果"
  },
  {
    "id": "base operand of %<->%> is not a pointer",
    "pattern": "base operand of '->' is not a pointer",
    "replacement": "'->' 的基操作数不是一个指针"
  },
  {
    "id": "%qE cannot be used as a member pointer, since it is of type %qT",
    "pattern": "'(.+?)' cannot be used as a member pointer, since it is of type '(.+?)'",
    "replacement": "'$1' 不能用作成员指针，因为它的类型为 '$2'"
  },
  {
    "id": "cannot apply member pointer %qE to %qE, which is of non-class type %qT",
    "pattern": "cannot apply member pointer '(.+?)' to '(.+?)', which is of non-class type '(.+?)'",
    "replacement": "无法将成员指针 '$1' 应用到 '$2' 上，因为后者的类型 '$3' 不是类"
  },
  {
    "id": "pointer to member type %qT incompatible with object type %qT",
    "pattern": "pointer to member type '(.+?)' incompatible with object type '(.+?)'",
    "replacement": "成员指针类型 '$1' 与对象类型 '$2' 不兼容"
  },
  {
    "id": "pointer-to-member-function type %qT requires an rvalue",
    "pattern": "pointer-to-member-function type '(.+?)' requires an rvalue",
    "replacement": "成员函数指针类型 '$1' 需要一个右值"
  },
  {
    "id": "pointer-to-member-function type %qT requires an lvalue",
    "pattern": "pointer-to-member-function type '(.+?)' requires an lvalue",
    "replacement": "成员函数指针类型 '$1' 需要一个左值"
  },
  {
    "id": "pointer-to-member-function type %qT requires an lvalue before C++20",
    "pattern": "pointer-to-member-function type '(.+?)' requires an lvalue before C\\+\\+20",
    "replacement": "成员函数指针类型 '$1' 在 C++20 前需要一个左值"
  },
  {
    "id": "functional cast to array type %qT",
    "pattern": "functional cast to array type '(.+?)'",
    "replacement": "函数式类型转换到数组类型 '$1' "
  },
  {
    "id": "invalid value-initialization of reference type",
    "pattern": "invalid value-initialization of reference type",
    "replacement": "引用类型的值初始化无效"
  },
  {
    "id": "call to function %qD which throws incomplete type %q#T",
    "pattern": "call to function '(.+?)' which throws incomplete type '(.+?)'",
    "replacement": "调用函数 '$1' 会抛出不完整类型 '$2'"
  },
  {
    "id": "call to function which throws incomplete type %q#T",
    "pattern": "call to function which throws incomplete type '(.+?)'",
    "replacement": "调用函数会抛出不完整类型 '$2'"
  },
  {
    "id": "unable to open log file %<vtv_class_set_sizes.log%>: %m",
    "pattern": "unable to open log file 'vtv_class_set_sizes.log': ",
    "replacement": "无法打开日志文件 'vtv_class_set_sizes.log'："
  },
  {
    "id": "unable to open log file %<vtv_set_ptr_data.log%>: %m",
    "pattern": "unable to open log file 'vtv_set_ptr_data.log': ",
    "replacement": "无法打开日志文件 'vtv_set_ptr_data.log'："
  },
  {
    "id": "unable to open log file %<vtv_count_data.log%>: %m",
    "pattern": "unable to open log file 'vtv_count_data.log': ",
    "replacement": "无法打开日志文件 'vtv_count_data.log'："
  },
  {
    "id": "assertion missing after %qs",
    "pattern": "assertion missing after '(.+?)'",
    "replacement": "'$1' 后缺少断言"
  },
  {
    "id": "macro name missing after %qs",
    "pattern": "macro name missing after '(.+?)'",
    "replacement": "'$1' 后缺少宏名"
  },
  {
    "id": "missing path after %qs",
    "pattern": "missing path after '(.+?)'",
    "replacement": "'$1' 后缺少路径"
  },
  {
    "id": "missing makefile target after %qs",
    "pattern": "missing makefile target after '(.+?)'",
    "replacement": "'$1' 后缺少 makefile 目标"
  },
  {
    "id": "argument %qs to %<-Waligned-new%> not recognized",
    "pattern": "argument '(.+?)' to '-Waligned-new' not recognized",
    "replacement": "传递给 '-Wnormalized' 的实参 '$1' 无法识别"
  },
  {
    "id": "argument %qs to %<-Wnormalized%> not recognized",
    "pattern": "argument '(.+?)' to '-Wnormalized' not recognized",
    "replacement": "传递给 '-Wnormalized' 的实参 '$1' 无法识别"
  },
  {
    "id": "no class name specified with %qs",
    "pattern": "no class name specified with '(.+?)'",
    "replacement": "'$1' 没有指定类名"
  },
  {
    "id": "%<-fhandle-exceptions%> has been renamed %<-fexceptions%> (and is now on by default)",
    "pattern": "'-fhandle-exceptions' has been renamed '-fexceptions' \\(and is now on by default\\)",
    "replacement": "'-fhandle-exceptions' 已被重命名为 '-fexceptions' （并且现在默认启用）"
  },
  {
    "id": "missing mapper",
    "pattern": "missing mapper",
    "replacement": "缺少映射器"
  },
  {
    "id": "missing header name",
    "pattern": "missing header name",
    "replacement": "缺少头名"
  },
  {
    "id": "missing module name",
    "pattern": "missing module name",
    "replacement": "缺少模块名"
  },
  {
    "id": "unrecognized ivar visibility value %qs",
    "pattern": "unrecognized ivar visibility value '(.+?)'",
    "replacement": "无法识别的 ivar 可见度值 '$1'"
  },
  {
    "id": "unrecognized scalar storage order value %qs",
    "pattern": "unrecognized scalar storage order value '(.+?)'",
    "replacement": "无法识别的标量存储顺序值 '$1'"
  }
]